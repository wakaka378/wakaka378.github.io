<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>2021前端面试复习 | Wakaka378</title><meta name="description" content="一个在教育行业苦干两年的前端菜鸟，离职后就在准备复习面试，记录一下这次前端复习过程。前端知识是在是太多，持续更新中… 希望对真正找工作的你有所帮助，文末我整理了一下面试文章，感兴趣的可以看看，尤其是2021高频前端面试题汇总系列，帮助很大。文章有所不足的地方还指明。  HTML5、CSS3  HTML5  HTML5新增特性   语义化标签：header、nav、footer、section.."><meta property="og:type" content="article"><meta property="og:title" content="2021前端面试复习"><meta property="og:url" content="https://wakaka378.github.io/fd8759a87419.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="一个在教育行业苦干两年的前端菜鸟，离职后就在准备复习面试，记录一下这次前端复习过程。前端知识是在是太多，持续更新中… 希望对真正找工作的你有所帮助，文末我整理了一下面试文章，感兴趣的可以看看，尤其是2021高频前端面试题汇总系列，帮助很大。文章有所不足的地方还指明。  HTML5、CSS3  HTML5  HTML5新增特性   语义化标签：header、nav、footer、section.."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d56cc46a99b4f7d9f114171e9738058~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp"><meta property="article:published_time" content="2021-08-26T13:10:52.000Z"><meta property="article:modified_time" content="2023-06-14T13:13:09.231Z"><meta property="article:author" content="John Doe"><meta property="article:tag" content="面试"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d56cc46a99b4f7d9f114171e9738058~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp"><link rel="canonical" href="https://wakaka378.github.io/fd8759a87419.html"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/wakaka378" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">wakaka378</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">a Vuer</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Beijing, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/wakaka378" target="_blank" title="Github"><i class="icon icon-github"></i></a></li><li><a href="https://juejin.cn/user/2348212570298807" target="_blank" title="Juejin"><i class="icon icon-juejin"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/DeBug/">DeBug</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/">工程化</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/npm/">npm</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Github/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Github/%E5%B7%A5%E5%85%B7/Node/">Node</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Js/">Js</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Js/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%8Cprettier/">工程化，prettier</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%BB%E7%BB%93/">总结</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DeBug/" rel="tag">DeBug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Js/" rel="tag">Js</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue3/" rel="tag">Vue3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prettier/" rel="tag">prettier</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket-io/" rel="tag">socket.io</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue-cli/" rel="tag">vue@cli</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/" rel="tag">节流防抖</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/" rel="tag">面对对象</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/DeBug/" style="font-size:13px">DeBug</a> <a href="/tags/Git/" style="font-size:13px">Git</a> <a href="/tags/Github/" style="font-size:13px">Github</a> <a href="/tags/Js/" style="font-size:14px">Js</a> <a href="/tags/Node/" style="font-size:13px">Node</a> <a href="/tags/Vue/" style="font-size:13px">Vue</a> <a href="/tags/Vue3/" style="font-size:13px">Vue3</a> <a href="/tags/npm/" style="font-size:13px">npm</a> <a href="/tags/prettier/" style="font-size:13px">prettier</a> <a href="/tags/socket-io/" style="font-size:13px">socket.io</a> <a href="/tags/vue-cli/" style="font-size:13px">vue@cli</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size:13px">工具</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size:13px">工程化</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size:13px">性能优化</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size:13.5px">总结</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:13px">数据结构</a> <a href="/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/" style="font-size:13px">节流防抖</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size:13px">设计模式</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size:13px">队列</a> <a href="/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/" style="font-size:13px">面对对象</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size:13px">面试</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled"><li><div class="item-thumb"><a href="/8e08379d750c.html" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Git/">Git</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/">工程化</a></p><p class="item-title"><a href="/8e08379d750c.html" class="title">还在手动发包? 试试release-it 自动发包吧📦</a></p><p class="item-date"><time datetime="2023-06-11T10:56:36.000Z" itemprop="datePublished">2023-06-11</time></p></div></li><li><div class="item-thumb"><a href="/8d142cc6d228.html" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Vue/">Vue</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Vue/%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%8Cprettier/">工程化，prettier</a></p><p class="item-title"><a href="/8d142cc6d228.html" class="title">记一次vue@cli创建项目prettier失效</a></p><p class="item-date"><time datetime="2023-05-31T13:41:00.000Z" itemprop="datePublished">2023-05-31</time></p></div></li><li><div class="item-thumb"><a href="/b1ab80e28404.html" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Js/">Js</a></p><p class="item-title"><a href="/b1ab80e28404.html" class="title">防抖debounce理解</a></p><p class="item-date"><time datetime="2023-04-09T13:54:09.000Z" itemprop="datePublished">2023-04-09</time></p></div></li><li><div class="item-thumb"><a href="/b5876a494e6d.html" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Js/">Js</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Js/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></p><p class="item-title"><a href="/b5876a494e6d.html" class="title">JavaScript数据结构之——队列</a></p><p class="item-date"><time datetime="2022-12-05T13:02:58.000Z" itemprop="datePublished">2022-12-05</time></p></div></li><li><div class="item-thumb"><a href="/f28e7bfffbb9.html" class="thumb"><span class="thumb-image thumb-none"></span></a></div><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Git/">Git</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Git/DeBug/">DeBug</a></p><p class="item-title"><a href="/f28e7bfffbb9.html" class="title">如何学习github上的项目</a></p><p class="item-date"><time datetime="2022-12-04T13:29:08.000Z" itemprop="datePublished">2022-12-04</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse in" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#html5-css3"><span class="toc-number">1.</span> <span class="toc-text">HTML5、CSS3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#html5"><span class="toc-number">1.1.</span> <span class="toc-text">HTML5</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#html5%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">HTML5新增特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.2.</span> <span class="toc-text">行内元素、块级元素有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iframe%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.3.</span> <span class="toc-text">iframe的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#canvas%E5%92%8Csvg%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.4.</span> <span class="toc-text">canvas和SVG的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98"><span class="toc-number">1.1.5.</span> <span class="toc-text">回流重绘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#src%E5%92%8Chref%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.6.</span> <span class="toc-text">src和href的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css3"><span class="toc-number">1.2.</span> <span class="toc-text">CSS3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#css3%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">CSS3新增特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trastion%E5%92%8Caniamtion%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.3.</span> <span class="toc-text">trastion和aniamtion的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">1.2.4.</span> <span class="toc-text">元素水平垂直居中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#p-em-rem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.5.</span> <span class="toc-text">p、em、rem的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B31px%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.</span> <span class="toc-text">如何解决1px问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFbfc%E5%B8%83%E5%B1%80%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAbfc%E5%B8%83%E5%B1%80"><span class="toc-number">1.2.7.</span> <span class="toc-text">什么是BFC布局，如何创建BFC布局？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#link%E5%92%8Cimport%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.8.</span> <span class="toc-text">link和@import的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.9.</span> <span class="toc-text">CSS选择器优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">JS基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.0.1.</span> <span class="toc-text">基础数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">2.0.2.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">2.0.3.</span> <span class="toc-text">变量提升、作用域、作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">变量提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">2.0.3.3.</span> <span class="toc-text">作用域链</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call-apply-bind%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.4.</span> <span class="toc-text">call、apply、bind区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.5.</span> <span class="toc-text">new操作符干了什么操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-blog%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">2.0.6.</span> <span class="toc-text">[[…&#x2F;…&#x2F;1-blog&#x2F;设计模式&#x2F;js设计模式(一)面向对象—封装#原型和原型链 |原型和原型链 ]]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.0.7.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">2.0.7.1.</span> <span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">2.0.7.2.</span> <span class="toc-text">构造函数继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">2.0.7.3.</span> <span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">2.0.7.4.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">2.0.7.5.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">2.0.7.6.</span> <span class="toc-text">寄生组合式继承</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.0.8.</span> <span class="toc-text">深拷贝、浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.0.8.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.0.8.2.</span> <span class="toc-text">深拷贝</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6eventloop%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">2.0.9.</span> <span class="toc-text">事件循环机制EventLoop（浏览器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88-%E9%98%9F%E5%88%97%E7%90%86%E8%A7%A3"><span class="toc-number">2.0.9.1.</span> <span class="toc-text">栈、队列理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8F%E8%A7%82%E4%BB%BB%E5%8A%A1-%E5%BE%AE%E8%A7%82%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.0.9.2.</span> <span class="toc-text">宏观任务、微观任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.0.9.3.</span> <span class="toc-text">同步任务、异步任务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-study%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%99%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96"><span class="toc-number">2.0.10.</span> <span class="toc-text">[[3-study&#x2F;前端&#x2F;手写基础函数#节流防抖|节流防抖]]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">2.0.11.</span> <span class="toc-text">事件冒泡、事件委托</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9dom%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">2.0.12.</span> <span class="toc-text">对DOM元素进行增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E"><span class="toc-number">2.0.12.1.</span> <span class="toc-text">增</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0"><span class="toc-number">2.0.12.2.</span> <span class="toc-text">删</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9"><span class="toc-number">2.0.12.3.</span> <span class="toc-text">改</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5"><span class="toc-number">2.0.12.4.</span> <span class="toc-text">查</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ajax-axios-fetch%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.13.</span> <span class="toc-text">ajax、axios、fetch区别</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#es6"><span class="toc-number">3.</span> <span class="toc-text">ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var-let-const%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">var、let、const区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-study%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%99%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0promisepromise"><span class="toc-number">3.2.</span> <span class="toc-text">[[3-study&#x2F;前端&#x2F;手写基础函数#promise|Promise]]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.</span> <span class="toc-text">forEach和map的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-map%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.5.</span> <span class="toc-text">Set、Map的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set"><span class="toc-number">3.5.1.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-number">3.5.2.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">3.5.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9es6%E5%AF%B9%E7%90%86%E8%A7%A3"><span class="toc-number">3.6.</span> <span class="toc-text">谈谈你对ES6对理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue"><span class="toc-number">4.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mvvm"><span class="toc-number">4.1.1.</span> <span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.1.2.</span> <span class="toc-text">Vue生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watch%E5%92%8Ccomputed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.3.</span> <span class="toc-text">watch和computed的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-for%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.4.</span> <span class="toc-text">v-for中key的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.5.</span> <span class="toc-text">v-if和v-show的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.6.</span> <span class="toc-text">组件中的data为什么是一个函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">4.1.7.</span> <span class="toc-text">Vue组件通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="toc-number">4.1.7.1.</span> <span class="toc-text">父子组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6"><span class="toc-number">4.1.7.2.</span> <span class="toc-text">兄弟组件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.8.</span> <span class="toc-text">Vuex的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mutation%E5%92%8Caction%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.8.1.</span> <span class="toc-text">mutation和action的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex%E5%92%8Clocalstory%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.9.</span> <span class="toc-text">Vuex和localstory的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-number">4.1.10.</span> <span class="toc-text">路由守卫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E5%92%8Chistory%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.11.</span> <span class="toc-text">hash和history的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hash"><span class="toc-number">4.1.11.1.</span> <span class="toc-text">hash</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#history"><span class="toc-number">4.1.11.2.</span> <span class="toc-text">history</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-number">4.1.12.</span> <span class="toc-text">动态路由</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.12.1.</span> <span class="toc-text">定义方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#router-%E5%92%8Croute"><span class="toc-number">4.1.12.2.</span> <span class="toc-text">router和router 和router和route</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.13.</span> <span class="toc-text">Vue性能优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86"><span class="toc-number">4.2.</span> <span class="toc-text">原理知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.1.</span> <span class="toc-text">双向绑定原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="toc-number">4.2.2.</span> <span class="toc-text">依赖收集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#objectdefineproperty%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%BC%BA%E9%99%B7"><span class="toc-number">4.2.3.</span> <span class="toc-text">Object.defineProperty()数据劫持缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-2"><span class="toc-number">4.2.4.</span> <span class="toc-text">双向绑定原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nexttick%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.5.</span> <span class="toc-text">nextTick的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-vue-%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F-dom"><span class="toc-number">4.2.6.</span> <span class="toc-text">怎么理解 vue 中的虚拟 DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.7.</span> <span class="toc-text">模版编译原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#diff%E7%AE%97%E6%B3%95%E9%80%BB%E8%BE%91"><span class="toc-number">4.2.8.</span> <span class="toc-text">diff算法逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-vue%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.9.</span> <span class="toc-text">new Vue的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#keep-live%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.10.</span> <span class="toc-text">keep-live原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">网站优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text">代码优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%BC%98%E5%8C%96"><span class="toc-number">5.3.</span> <span class="toc-text">请求优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack%E4%BC%98%E5%8C%96"><span class="toc-number">5.4.</span> <span class="toc-text">webpack优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">6.</span> <span class="toc-text">浏览器相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">6.1.</span> <span class="toc-text">跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">6.1.1.</span> <span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.2.</span> <span class="toc-text">解决跨域问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.</span> <span class="toc-text">本地存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie"><span class="toc-number">6.2.1.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sessionstorage"><span class="toc-number">6.2.2.</span> <span class="toc-text">SessionStorage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#localstorage"><span class="toc-number">6.2.3.</span> <span class="toc-text">LocalStorage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA-url-%E5%9C%B0%E5%9D%80%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%8C%E6%88%90%E6%B8%B2%E6%9F%93%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">从输入一个 URL 地址到浏览器完成渲染的整个过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">7.</span> <span class="toc-text">网络协议、安全相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-udp%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.1.</span> <span class="toc-text">TCP、UDP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E5%92%8Chttps%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.</span> <span class="toc-text">HTTP和HTTPS区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">7.3.</span> <span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">7.4.</span> <span class="toc-text">HTTP三次握手、四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">7.4.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">7.4.2.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">7.4.3.</span> <span class="toc-text">为什么需要四次挥手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E7%BC%93%E5%AD%98"><span class="toc-number">7.5.</span> <span class="toc-text">HTTP缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-number">7.5.1.</span> <span class="toc-text">强缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">7.5.2.</span> <span class="toc-text">协商缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-2"><span class="toc-number">7.5.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#post%E5%92%8Cget%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.6.</span> <span class="toc-text">POST和GET的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xss-csrf%E6%94%BB%E5%87%BB"><span class="toc-number">7.7.</span> <span class="toc-text">XSS、csrf攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB"><span class="toc-number">7.7.1.</span> <span class="toc-text">XSS（跨站脚本攻击）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#csrf%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0"><span class="toc-number">7.7.2.</span> <span class="toc-text">CSRF（跨站请求伪造）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-number">7.8.</span> <span class="toc-text">前端工程化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack%E7%9A%84loader%E5%92%8Cplugin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.9.</span> <span class="toc-text">webpack的loader和plugin的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#loader"><span class="toc-number">7.9.1.</span> <span class="toc-text">loader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#plugin"><span class="toc-number">7.9.2.</span> <span class="toc-text">plugin</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">手写系列🤮</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96"><span class="toc-number">8.1.</span> <span class="toc-text">节流防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">8.2.</span> <span class="toc-text">new操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-bind-apply%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.3.</span> <span class="toc-text">call、bind、apply实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.4.</span> <span class="toc-text">发布订阅模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.5.</span> <span class="toc-text">函数柯里化实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#promise"><span class="toc-number">8.5.1.</span> <span class="toc-text">promise</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97"><span class="toc-number">8.6.</span> <span class="toc-text">实现一个队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">8.7.</span> <span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">8.8.</span> <span class="toc-text">深浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-number">8.9.</span> <span class="toc-text">交换两个变量的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-number">8.10.</span> <span class="toc-text">数组扁平化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">9.</span> <span class="toc-text">输出结果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85-2"><span class="toc-number">9.1.</span> <span class="toc-text">闭包</span></a></li></ol></li></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-2021前端面试复习" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">2021前端面试复习</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/fd8759a87419.html" class="article-date"><time datetime="2021-08-26T13:10:52.000Z" itemprop="datePublished">2021-08-26</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/fd8759a87419.html#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 12.3k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 45(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d56cc46a99b4f7d9f114171e9738058~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp" alt=""></p><p>一个在教育行业苦干两年的前端菜鸟，离职后就在准备复习面试，记录一下这次前端复习过程。前端知识是在是太多，持续更新中… 希望对真正找工作的你有所帮助，文末我整理了一下面试文章，感兴趣的可以看看，尤其是<strong>2021高频前端面试题汇总</strong>系列，帮助很大。文章有所不足的地方还指明。</p><h2 id="html5-css3"><a class="markdownIt-Anchor" href="#html5-css3"></a> HTML5、CSS3</h2><h3 id="html5"><a class="markdownIt-Anchor" href="#html5"></a> HTML5</h3><h4 id="html5新增特性"><a class="markdownIt-Anchor" href="#html5新增特性"></a> HTML5新增特性</h4><ul><li><p>语义化标签：<code>header</code>、<code>nav</code>、<code>footer</code>、<code>section...</code></p></li><li><p>媒体标签：<code>audio</code>音频、<code>video视频</code></p></li><li><p>表单类型属性：<code>email</code>、<code>number</code>、<code>时间控件</code>、<code>color颜色拾取器</code>、<code>placeholder</code>、<code>autofocus自动获取焦点...</code></p></li><li><p>cavas绘图</p></li><li><p>web存储：<code>localStorage</code>、<code>sessionStorage</code></p></li></ul><h4 id="行内元素-块级元素有哪些"><a class="markdownIt-Anchor" href="#行内元素-块级元素有哪些"></a> 行内元素、块级元素有哪些</h4><p>行内元素：<code>a</code>、<code>span</code>、<code>img</code>、<code>input...</code></p><p>块级元素：<code>div</code>、<code>ul</code>、<code>li</code>、<code>ol</code>、<code>dt</code>、<code>dh</code>、<code>li</code>、<code>p</code>、<code>h1-6</code></p><h4 id="iframe的优缺点"><a class="markdownIt-Anchor" href="#iframe的优缺点"></a> iframe的优缺点</h4><p><strong>优点</strong>：</p><ul><li>原封不动的吧嵌入网页展示出来</li><li>增加代码的可重用</li><li>用来加载速度较慢的内容</li></ul><p><strong>缺点</strong>：</p><ul><li>iframe阻塞onload事件加载</li><li>网页内容无法被搜索引擎识别，对SEO不友好</li><li>会产生很多页面，不利于管理</li></ul><h4 id="canvas和svg的区别"><a class="markdownIt-Anchor" href="#canvas和svg的区别"></a> canvas和SVG的区别</h4><p><strong>canvas</strong>：通过javaScript来绘制2D图形，是逐像素进行渲染</p><ul><li>依赖分辨率</li><li>不支持事件处理</li><li>能够以.png或.jpg的格式进行保存</li><li>适合做游戏</li></ul><p><strong>SVG</strong>：基于XML描述的2D图形语言，是矢量图</p><ul><li>不依赖分辨率</li><li>支持事件处理</li><li>适合做大型区域渲染</li></ul><h4 id="回流重绘"><a class="markdownIt-Anchor" href="#回流重绘"></a> 回流重绘</h4><p><strong>回流</strong>当DOM变化影响了元素，比如元素的尺寸、布局、显示隐藏等改变了，需要重写构建。每个页面至少需要一次回流，就是在页面第一次加载的时候，这个时候一定会发生回流。</p><p><strong>重绘</strong>当一个元素的外观发生变化，但是没有改变布局，重新渲染元素的外观。比如<code>background-color</code>、<code>color</code></p><p><strong>回流必将引起重绘，而重绘不一定会引起回流</strong></p><p><strong>如何避免回流重绘：</strong></p><ul><li>避免使用<code>table</code>布局</li><li>尽可能在<code>DOM</code>树的最末端改变<code>class</code></li><li>避免设置多层内联样式</li><li>开启GPU加速</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或者<code>fixed</code>的元素上</li></ul><h4 id="src和href的区别"><a class="markdownIt-Anchor" href="#src和href的区别"></a> src和href的区别</h4><p><strong>src</strong>src指向外部资源的位置，将指向的内容嵌入到文档中当前标签所在的位置，如js脚本、<code>img</code>图片、<code>iframe</code>等</p><p><strong>href</strong>用于在当前文档和引用资源之间确立联系，一般是用在<code>link</code>、<code>a</code>等元素</p><h3 id="css3"><a class="markdownIt-Anchor" href="#css3"></a> CSS3</h3><h4 id="css3新增特性"><a class="markdownIt-Anchor" href="#css3新增特性"></a> CSS3新增特性</h4><ul><li>新增CSS选择器、伪类</li><li>特效：<code>text-shadow</code>、<code>box-shadow</code></li><li>渐变：<code>gradient</code></li><li>旋转过度：<code>transform</code>、<code>transtion</code></li><li>动画：<code>animation</code></li></ul><h4 id="盒模型"><a class="markdownIt-Anchor" href="#盒模型"></a> 盒模型</h4><p>盒模型都是有四部分组成：<code>content</code>、<code>padding</code>、<code>border</code>、<code>margin</code></p><p>标准盒模型和IE盒模型的区别在于设置<code>width</code>和<code>height</code>时，对应的范围不同</p><ul><li><p>标准盒模型的<code>width</code>、<code>height</code>只包含了<code>content</code></p></li><li><p>IE盒模型的<code>width</code>、<code>height</code>包含了<code>border</code>、<code>margin</code>、<code>padding</code></p></li></ul><p>通过修改元素的<code>box-sizing</code>属性来改变元素的盒模型</p><ul><li><code>box-sizeing: content-box</code>表示标准盒模型（默认值）</li><li><code>box-sizeing: border-box</code>表示IE盒模型（怪异盒模型)</li></ul><h4 id="trastion和aniamtion的区别"><a class="markdownIt-Anchor" href="#trastion和aniamtion的区别"></a> trastion和aniamtion的区别</h4><p><code>transtion</code>：属于过度属性，强调过度，需要一个事件进行触发（如鼠标进入、离开）类似<code>flash</code>的补间动画，设置一个开始帧和结束帧</p><p><code>aniamtion</code>：属于动画属性，它的实现不需要触发事件，设定好后可自动执行，且可以循环播放。也是类似补间动画，但是可以设置多个关键帧</p><h4 id="元素水平垂直居中"><a class="markdownIt-Anchor" href="#元素水平垂直居中"></a> 元素水平垂直居中</h4><ul><li><p>绝对定位：先将元素的左上角通过<code>top:50%</code>和<code>left:50%</code>定位到页面的中心，然后再通过<code>translate</code>来调整元素的中心点到页面的中心。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;    </span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.child</span> &#123;    </span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>绝对定位：设置四个方向的值都为0，并将<code>margin</code>设置为<code>auto</code>，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>flex</code>弹性盒子布局，通过<code>align-items:center</code>和<code>justify-content:center</code>设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="p-em-rem的区别"><a class="markdownIt-Anchor" href="#p-em-rem的区别"></a> p、em、rem的区别</h4><ul><li><code>px</code> 固定像素单位，不能随其它元素的变化而变化</li><li><code>em</code>是相对于父元素的单位，会随着父元素变化而变化</li><li><code>rem</code>是相对于根元素<code>html</code>，它会随着html元素变化而变化</li></ul><p><code>rem</code>常用在移动端项目，设置根元素的<code>fong-size</code>，其它元素会随着根元素的变化而变化，从而达到不同手机屏幕的自适应大小。通常会配合<code>postcss-pxtorem</code>插件进行使用</p><h4 id="如何解决1px问题"><a class="markdownIt-Anchor" href="#如何解决1px问题"></a> 如何解决1px问题</h4><ul><li>直接写<code>0.5px</code></li><li>利用伪元素，先放大再缩小</li><li>使用viewport缩放来解决</li></ul><h4 id="什么是bfc布局如何创建bfc布局"><a class="markdownIt-Anchor" href="#什么是bfc布局如何创建bfc布局"></a> 什么是BFC布局，如何创建BFC布局？</h4><p>BFC布局为<strong>块格式化上下文</strong>（Block Formatting Context，BFC）， 是CSS布局的一个概念，里面的元素不会影响到外面的元素。</p><p><strong>创建BFC</strong>：</p><ul><li>元素设置浮动：<code>float</code>有值并不为空</li><li>元素设置绝对定位：<code>position（absolute、fixed）</code></li><li><code>overfilow</code>值为：<code>hidden</code>、<code>auto</code>、<code>scroll</code></li><li><code>display</code>值为：<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>等</li></ul><p><strong>BFC作用</strong>：</p><ul><li>解决<code>margin</code>重叠问题：由于BFC是一个独立的区域，内部元素和外部元素互不影响，将两个元素变为BFC，就解决了margin重叠问题</li><li>创建自适应两栏布局：可以用来创建自适应两栏布局，左边宽高固定，右边宽度自适应。</li><li>解决高度塌陷问题：在子元素设置浮动后，父元素会发生高度的塌陷，也就是父元素的高度为0解决这个问题，只需要将父元素变成一个BFC。</li></ul><h4 id="link和import的区别"><a class="markdownIt-Anchor" href="#link和import的区别"></a> link和@import的区别</h4><ul><li><code>link</code>是HTML提供的标签，不仅可以加载<code>CSS</code>文件，还可以定义<code>RSS、rel</code>连接属性等</li><li><code>@import</code>是CSS提供等语法规则，只有导入样式表带作用。</li><li><code>link</code>标签引入的CSS被同时加载，而<code>@import</code>引入的CSS将在页面<strong>加载完毕</strong>后被加载</li><li><code>@import</code>是CSS2.1才有的语法，存在兼容性，而<code>link</code>作为HTML标签不存在兼容性问题</li></ul><h4 id="css选择器优先级"><a class="markdownIt-Anchor" href="#css选择器优先级"></a> CSS选择器优先级</h4><ul><li><code>@important</code></li><li>内联样式</li><li>ID选择器</li><li>类选择器/属性选择器/伪类选择器</li><li>元素选择器/伪元素选择器</li><li>关系选择器/通配符选择器</li></ul><h2 id="js基础"><a class="markdownIt-Anchor" href="#js基础"></a> JS基础</h2><h4 id="基础数据类型"><a class="markdownIt-Anchor" href="#基础数据类型"></a> 基础数据类型</h4><p><code>string</code>、<code>number</code>、<code>boolean</code>、<code>object</code>、<code>function</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code></p><p><code>null</code>和<code>undefined</code>的区别：<code>null</code>表示对是一个空的对象(object)、<code>undefined</code>是申明了但没赋值，在使用<code>typeo</code>f检测类型时，<code>nul</code>l为<code>object</code>，<code>undefined</code>为<code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>值类型（基本数据类型）：<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code></p><p>引用类型：<code>object</code>、<code>function</code>、<code>array</code></p><p>值类型和引用类型区别：</p><ul><li>值类型保存在<strong>栈</strong>中，<strong>占用空间固定</strong>，当一个方法执行时，每个方法都会创建自己的内存栈，方法中定义的变量会存放在这个内存栈中。当方法执行结束时，这个内存栈也会被销毁。所以，栈中存储的是基础变量。而引用变量存储在栈中是指向堆中的数组或对象的引用地址。这也就是为何修改引用类型总会影响到其它指向这个地址的引用变量。</li><li>值类型可以使用<code>typeof</code>进行数据类型检测</li><li>引用类型保存在<strong>堆</strong>中，<strong>占用空间不固定</strong>。创建对象会保存到堆内存中，这个内存不回随着方法结束而销毁，因为这个对象还可能被另外一个变量所引用，只有当一个对象没有被任何变量引用时，系统的垃圾回收机制会将它回收。</li><li>引用类型使用<code>instanceof</code>检测数据类型</li><li>使用new（）方法构造出来的对象是引用类型</li></ul><h4 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h4><p>闭包就是能够读取到其它函数内部变量的函数，创建一个最简单的闭包，就是在一个函数内部创建另外一个函数，创建的函数可以访问到当前函数的局部变量。在[[3-study/前端/手写基础函数#节流防抖|节流防抖]] 中广泛引用</p><p><strong>闭包优点：</strong></p><ul><li>创建全局私有变量，避免变量全局污染</li><li>可以实现封装、缓存等</li></ul><p><strong>闭包缺点：</strong></p><ul><li>创建的变量不能被回收，容易消耗内存，使用不当会导致内存溢出</li></ul><h4 id="变量提升-作用域-作用域链"><a class="markdownIt-Anchor" href="#变量提升-作用域-作用域链"></a> 变量提升、作用域、作用域链</h4><h5 id="变量提升"><a class="markdownIt-Anchor" href="#变量提升"></a> 变量提升</h5><p>js代码在解析的时候，会将所有的变量函数，提升到代码的最上面。变量提升，提升的只是变量申明，并不会吧变量赋值提升上来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h5><p>作用域是一个变量或函数的可访问范围，作用域控制着变量或函数的可见性和生命周期</p><ol><li><p>全局作用域：可以全局访问</p><ul><li>最外层函数和最外层定义的变量拥有全局作用域</li><li>window上的对象属性方法拥有全局作用域</li><li>为定义直接复制的变量自动申明拥有全局作用域</li><li>过多的全局作用域变量会导致变量全局污染，命名冲突</li></ul></li><li><p>函数作用域：只能在函数中访问使用哦</p><ul><li>在函数中定义的变量，都只能在内部使用，外部无法访问</li><li>内层作用域可以访问外层，外层不能访问内存作用域</li></ul></li><li><p>ES6中的块级作用域：只在代码块中访问使用</p><ul><li><p>使用ES6中新增的<code>let</code>、<code>const</code>什么的变量，具备块级作用域，块级作用域可以在函数中创建（由{}包裹的代码都是块级作用域）</p></li><li><p><code>let</code>、<code>const</code>申明的变量不会变量提升，<code>const</code>也不能重复申明</p></li><li><p>块级作用域主要用来解决由变量提升导致的变量覆盖问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">3</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fnc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fnc</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="作用域链"><a class="markdownIt-Anchor" href="#作用域链"></a> 作用域链</h5><p>变量在指定的作用域中没有找到，会依次向上一层作用域进行查找，直到全局作用域。这个查找的过程被称为作用域链。</p><h4 id="call-apply-bind区别"><a class="markdownIt-Anchor" href="#call-apply-bind区别"></a> call、apply、bind区别</h4><ul><li>都可以用作改变<code>this</code>指向</li><li><code>call</code>和<code>apply</code>的区别在于传参，<code>call</code>、<code>bind</code>都是传入对象。<code>apply</code>传入一个数组。</li><li><code>call</code>、<code>apply</code>改变this指向后会立即执行函数，<code>bind</code>在改变this后返回一个函数，不会立即执行函数，需要手动调用。</li></ul><h4 id="new操作符干了什么操作"><a class="markdownIt-Anchor" href="#new操作符干了什么操作"></a> new操作符干了什么操作</h4><ol><li><p>创建一个空对象</p></li><li><p>设置原型，将对象的原型设置到函数的<code>prototype</code>对象上</p></li><li><p>改变this指向，将this指向该对象，并执行构造函数。</p></li><li><p>判断函数的返回类型，如果是值类型，返回创建的对象。如果是引用类型，返回这个引用类型的对象。</p></li></ol><h4 id="1-blog设计模式js设计模式一面向对象封装原型和原型链-原型和原型链"><a class="markdownIt-Anchor" href="#1-blog设计模式js设计模式一面向对象封装原型和原型链-原型和原型链"></a> [[…/…/1-blog/设计模式/js设计模式(一)面向对象—封装#原型和原型链 |原型和原型链 ]]</h4><ul><li><p>原型: 每个对象在内部初始化的时候，都会初始化一个<code>prototype</code>原型属性 ，而对象的 <code>_proto_</code>属性，指向它的原型对象。</p></li><li><p>原型链: 当我们访问英国对象属性时，如果这个属性不存在，那么就会去它的原型对象上进行查找，而这个原型对象又会有自己的原型，会这样一直查找，知道找到顶级对象object为止。这个查找的过程被称为原型对象。</p></li></ul><h4 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h4><h5 id="原型链继承"><a class="markdownIt-Anchor" href="#原型链继承"></a> 原型链继承</h5><p>利用对象的原型链，将子类<code>Son.prototype</code>指向父类的构造函数创建出来的实例对象<code>new Person()</code></p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键代码</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>子类可以继承父类构造函数、原型上的属性方法</li></ul><p><strong>缺点：</strong></p><ul><li>父类引用类型的实例对象被共享，容易造成修改的混乱。</li><li>创建子类的时候不能向父类传参</li></ul><h5 id="构造函数继承"><a class="markdownIt-Anchor" href="#构造函数继承"></a> 构造函数继承</h5><p>利用<code>.call()</code>或者<code>.apply()</code>方法，在子类中借用父类的构造函数，初始化父类构造函数。</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">	<span class="comment">// 关键代码  </span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>子类在继承父类时，可以向父类构造函数中传参。</li><li>不会造成子类势力之间引用属性共享。</li></ul><p>缺点：</p><ul><li>只能继承父类构造函数中的属性方法，无法访问原型上的方法。</li><li>每个子类都会创建一个父类副本</li></ul><h5 id="组合继承"><a class="markdownIt-Anchor" href="#组合继承"></a> 组合继承</h5><p>组合继承，将原型链继承和构造函数继承融合在一起。</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 借用构造函数继承关键代码</span></span><br><span class="line">	<span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链式继承关键代码</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">// 将子类的构造函数指向自己</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructon</span> = <span class="title class_">Son</span>;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>结合前面两种继承方式的优点，子类的实例可以访问到父类原型上的属性方法</li><li>子类的实例之间不会被共享</li></ul><p><strong>缺点：</strong></p><ul><li>调用了两次父类构造函数</li></ul><h5 id="原型式继承"><a class="markdownIt-Anchor" href="#原型式继承"></a> 原型式继承</h5><p>用函数包装一个对象，返回这个函数的调用（也就是ES5的Object.create的模拟实现），将传入的对象作为创建对象的原型</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个空的的构造函数</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将空的构造函数原型指向传递进来的对象</span></span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回一个实例对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj1 = <span class="title function_">create</span>(obj);</span><br><span class="line"><span class="keyword">const</span> newObj2 = <span class="title function_">create</span>(obj);</span><br></pre></td></tr></table></figure><p>优缺点和原型链式继承一样，引用类型还是会被共享。</p><h5 id="寄生式继承"><a class="markdownIt-Anchor" href="#寄生式继承"></a> 寄生式继承</h5><p>在原型式继承基础上，在函数内部来做增强函数，返回对象。</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="comment">// 获取继承的子类对象，也就是上面的create方法实现</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 函数增强</span></span><br><span class="line">  newObj.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 返回对象</span></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似原型式继承，但在原有的基础上可以自定义属性方法，依旧没有解决引用值被共享问题。（跟借用构造函数模式一样，每次创建对象都会创建一遍方法。）</p><h5 id="寄生组合式继承"><a class="markdownIt-Anchor" href="#寄生组合式继承"></a> 寄生组合式继承</h5><p>结合寄生继承和组合式继承优缺点，组合式继承缺点为调用了两次父类构造函数，优点为解决了引用值被共享问题。而寄生式继承缺点为没有解决引用值被共享问题，只要将两者结合就得到完美的继承方式。</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">son, parent</span>) &#123;</span><br><span class="line">  <span class="comment">// 寄生式继承，利用父类构造函数的原型对象创建出一个新的对象，解决组合式继承创建两个父类问题</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Objcet</span>.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>)；</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将新对象的constructor构造函数执行子类</span></span><br><span class="line">	newObj.<span class="property">constructor</span> = son;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将子类构造函数的原型指向心的  原型式继承</span></span><br><span class="line">  son.<span class="property">protoytype</span> = newObj; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 构造函数继承</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 实现继承</span></span><br><span class="line"><span class="title function_">createObj</span>(<span class="title class_">Son</span>, <span class="title class_">Person</span>)</span><br><span class="line"><span class="comment">// 更简洁的方式  在组合式继承的基础上  直接将son的原型通过API指向person的原型</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;zx&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;lw&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="深拷贝-浅拷贝"><a class="markdownIt-Anchor" href="#深拷贝-浅拷贝"></a> 深拷贝、浅拷贝</h4><h5 id="浅拷贝"><a class="markdownIt-Anchor" href="#浅拷贝"></a> 浅拷贝</h5><p>浅拷贝只是复制对象的值类型，通过<code>Object.assign</code>或者扩展运算符即可实现</p><h5 id="深拷贝"><a class="markdownIt-Anchor" href="#深拷贝"></a> 深拷贝</h5><p>通过递归实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否为对象</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !==<span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据obj类型创建数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? &#123;&#125; : [];</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 循环遍历obj，处理子元素为对象，递归拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newOb[key] = <span class="title function_">deepClone</span>(obj[key])</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="事件循环机制eventloop浏览器"><a class="markdownIt-Anchor" href="#事件循环机制eventloop浏览器"></a> 事件循环机制EventLoop（浏览器）</h4><h5 id="栈-队列理解"><a class="markdownIt-Anchor" href="#栈-队列理解"></a> 栈、队列理解</h5><ul><li><code>栈（Stack）</code>中的任务<strong>后进先出</strong>，js中的执行栈是一个存储函数的栈结构，栈中的任务执行遵循先进后出的原则依次执行。</li><li><code>队列（Queue）</code>中的任务<strong>先进先出</strong>，js运行时创建一个任务[[…/…/1-blog/数据结构/JavaScript数据结构之——队列|队列]]，用来处理列表（事件）和待执行的回调函数</li></ul><h5 id="宏观任务-微观任务"><a class="markdownIt-Anchor" href="#宏观任务-微观任务"></a> 宏观任务、微观任务</h5><p>js中的任务分为两种：<strong>宏观任务</strong><code>(MacroTask|Task)</code>、<strong>微观任务</strong><code>(MicorTask)</code>。</p><ul><li>宏任务：<code>script全部代码</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>I/O</code>、<code>UI Rendering</code></li><li>微任务：<code>Promise.then</code>、<code>Process.nexTick(Node独有)</code>、<code>MutationObserver</code></li></ul><h5 id="同步任务-异步任务"><a class="markdownIt-Anchor" href="#同步任务-异步任务"></a> 同步任务、异步任务</h5><p>js有一个<strong>主线程</strong>和一个<strong>执行栈（调用栈）</strong>，所有的任务都会放到执行栈中等待被主线程执行。</p><p>js代码在执行时，所有函数都会压入<strong>执行栈</strong>中。同步任务会按照<strong>后进先出</strong>原则依次执行，直到执行栈清空。异步任务会在异步任务有了结果后，将注册的回掉函数放入异步任务队列中，<strong>等待主线程空闲后（执行栈中的同步任务执行完毕）</strong>。</p><p>异步队列中的任务又分为<strong>宏观任务</strong>和<strong>微观任务</strong>，当当前执行栈清空后，处理异步队列中的任务时，首先会判断是否有微观任务可执行，如果有就将微观任务压入执行栈中执行。当微观队列中的任务在执行栈被执行完毕，再来异步队列中将宏观任务放入执行栈。</p><p>简单的来说：</p><ol><li>执行同步代码，这属于宏观任务</li><li>所有代码执行完毕，执行栈清空，执行异步队列中任务</li><li>异步队列中，先执行微观任务</li><li>微观任务执行完毕，再执行宏观任务</li></ol><h4 id="3-study前端手写基础函数节流防抖节流防抖"><a class="markdownIt-Anchor" href="#3-study前端手写基础函数节流防抖节流防抖"></a> [[3-study/前端/手写基础函数#节流防抖|节流防抖]]</h4><p>节流（throttle）：在n秒内只允许执行一次，</p><p>[[…/…/1-blog/防抖debounce理解|防抖]]（debounce）：在n秒内多次触发但不执行，而是在n秒后执行，如果n秒内触发则重新计算。</p><h4 id="事件冒泡-事件委托"><a class="markdownIt-Anchor" href="#事件冒泡-事件委托"></a> 事件冒泡、事件委托</h4><p>事件发生的三个阶段：<strong>捕获阶段</strong>、<strong>目标阶段</strong>、<strong>冒泡阶段</strong></p><ul><li>事件冒泡：在一个对象上触发某类事件，如果此对象绑定了事件，就会触发事件，如果没有，就会向这个对象的父级对象传播，最终父级对象触发事件。<ul><li>如何阻止：<ul><li>普通浏览器：<code>event.stopPropagation()</code></li><li>IE浏览器：<code>event.cancelBubble = true</code>;</li></ul></li></ul></li><li>事件委托：利用浏览器事件冒泡机制。事件在冒泡的过程中会传到父节点，并且父节点可以通过事件对象获取到目标节点，可以吧子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件<ul><li>事件委托可以不必要为每一个子节点都绑定监听事件，减少内存上的消耗。</li><li>使用事件委托还可以实现事件的动态绑定，比如新增一个子节点，并不需要为此单独增加一个监听事件，可以由父元素中的监听函数来处理。</li></ul></li></ul><h4 id="对dom元素进行增删改查"><a class="markdownIt-Anchor" href="#对dom元素进行增删改查"></a> 对DOM元素进行增删改查</h4><h5 id="增"><a class="markdownIt-Anchor" href="#增"></a> 增</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>()</span><br></pre></td></tr></table></figure><h5 id="删"><a class="markdownIt-Anchor" href="#删"></a> 删</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">removeAttribute</span>()</span><br><span class="line">element.<span class="title function_">removeChild</span>()</span><br></pre></td></tr></table></figure><h5 id="改"><a class="markdownIt-Anchor" href="#改"></a> 改</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">innerHTML</span>()</span><br><span class="line">element.<span class="title function_">setAttribute</span>()</span><br></pre></td></tr></table></figure><h5 id="查"><a class="markdownIt-Anchor" href="#查"></a> 查</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getElementById()</span><br><span class="line">getElementsByClassName()</span><br><span class="line">getElementsByTagName()</span><br><span class="line">querySelector()</span><br><span class="line">querySelectorAll()</span><br></pre></td></tr></table></figure><h4 id="ajax-axios-fetch区别"><a class="markdownIt-Anchor" href="#ajax-axios-fetch区别"></a> ajax、axios、fetch区别</h4><p><strong>ajax</strong></p><ul><li>基于原生的XHR开发</li><li>本身针对MVC编程，不符合现在前端MVVM潮流</li></ul><p><strong>axios</strong></p><ul><li><p>从浏览器中创建<code>XMLHttpRequest</code></p></li><li><p>支持<code>promise</code></p></li><li><p>支持请求拦击和响应拦截</p></li><li><p>从node.js创建http请求</p></li><li><p>客服端支持防止<code>CSRF/XSRF</code></p></li></ul><p><strong>fetch</strong></p><ul><li>浏览器原生实现的请求方式，ajax的替代品</li><li>只对网络请求报错，对400、500都当做成功的请求，需要封装</li><li>fetch默认不会带cookie，需要添加配置项</li><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li><li>fetch没有办法原生监测请求的进度，而XHR可以</li></ul><h2 id="es6"><a class="markdownIt-Anchor" href="#es6"></a> ES6</h2><h3 id="var-let-const区别"><a class="markdownIt-Anchor" href="#var-let-const区别"></a> var、let、const区别</h3><ul><li><code>var</code>声明变量可以重复声明，而<code>let</code>不可以</li><li><code>var</code>是不受限于块级作用域，而<code>let</code>受限</li><li><code>var</code>存在变量提升，<code>let</code>和<code>const</code>不存在变量提升</li><li><code>cons</code>t声明的变量不可变</li><li><code>const</code>声明之后必须赋值，否则会报错</li></ul><h3 id="3-study前端手写基础函数promisepromise"><a class="markdownIt-Anchor" href="#3-study前端手写基础函数promisepromise"></a> [[3-study/前端/手写基础函数#promise|Promise]]</h3><p><code>Promise</code>是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p><p>它有三种状态</p><ul><li><code>pending</code>初始状态</li><li><code>fulfilled</code>操作成功</li><li><code>rejected</code>操作失败。</li></ul><p><code>Promise</code>状态改变只有两种可能</p><ul><li>从<code>pending</code>------&gt;<code>fulfilled</code></li><li>从<code>pending</code>------&gt;<code>rejected</code></li></ul><p><code>Promise</code>构造函数接收一个参数和一个带有<code>resolve</code>和<code>reject</code>参数的回调函数。</p><ul><li><code>resolve</code>的作用是将<code>Promise</code>状态从<code>pending</code>变为<code>fulfilled</code>，在异步操作成功时调用，并将异步结果返回，作为参数传递出去</li><li><code>reject</code>的作用是将<code>Promise</code>状态从<code>pending</code>变为<code>rejected</code>，在异步操作失败后，将异步操作错误的结果，作为参数传递出去</li></ul><p><code>Promise</code>实例方法</p><ul><li><code>promise.then()</code> 对应<code>resolve</code>成功的处理</li><li><code>promise.catch()</code>对应<code>reject</code>失败的处理</li><li><code>promise.call()</code>将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例，返回的实例就是普通的<code>Promise</code>。有一个失败，代表该<code>Primise</code>失败。当所有的子<code>Promise</code>完成，返回值时全部值的数组</li><li><code>promise.race()</code>类似<code>promise.all()</code>，区别在于有任意一个完成就算完成（例如：将异步和定时器放在一起，设置请求超时）</li></ul><h3 id="箭头函数和普通函数的区别"><a class="markdownIt-Anchor" href="#箭头函数和普通函数的区别"></a> 箭头函数和普通函数的区别</h3><ul><li>箭头函数时<strong>匿名函数</strong>，不能作为构造函数，不能使用<code>new</code></li><li>箭头函数不绑定<code>arguments</code></li><li>箭头函数没有自己的<code>this</code>，将所在的上下文的<code>this</code>作为自己的<code>this</code>值</li><li>没有<code>prototype</code></li><li><code>call()</code>、<code>applay()</code>、<code>bind()</code>方法不能改变箭头函数中的<code>this</code>指向</li></ul><h3 id="foreach和map的区别"><a class="markdownIt-Anchor" href="#foreach和map的区别"></a> forEach和map的区别</h3><ul><li><code>forEach</code>返回值是<code>undefined</code>，不可以链式调用</li><li><code>map()</code>返回一个新的数组，不改变原数组。<code>forEach</code>改变原数组。</li></ul><h3 id="set-map的区别"><a class="markdownIt-Anchor" href="#set-map的区别"></a> Set、Map的区别</h3><h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h4><ul><li>创建：<code>new Set([1, 1, 2, 3, 3, 4, 2])</code></li><li><code>add(value)</code>：添加某个值，返回Set结构本身。</li><li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li><li><code>clear()</code>：清除所有成员，没有返回值。</li></ul><h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h4><ul><li><code>set(key, val):</code> 向<code>Map</code>中添加新元素</li><li><code>get(key):</code> 通过键值查找特定的数值并返回</li><li><code>has(key):</code>判断<code>Map</code>对象中是否有<code>Key</code>所对应的值，有返回<code>true</code>,否则返回<code>false</code></li><li><code>delete(key):</code>通过键值从<code>Map</code>中移除对应的数据</li><li><code>clear():</code> 将这个<code>Map</code>中的所有元素删除</li></ul><h4 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h4><ul><li><code>Map</code>是一种键值对的集合，和对象不同的是，键可以是任意值</li><li><code>Map</code>可以遍历，可以和各种数据格式转换</li><li><code>Set</code>是类似数组的一种的数据结构，但在Set中没有重复的值</li></ul><h3 id="谈谈你对es6对理解"><a class="markdownIt-Anchor" href="#谈谈你对es6对理解"></a> 谈谈你对ES6对理解</h3><ul><li>解构赋值</li><li>扩展运算符</li><li>模版字符串</li><li>箭头函数</li><li><code>async/await</code></li><li><code>Class</code></li><li>引入<code>Moldule</code>语法</li><li><code>class</code>类</li></ul><h2 id="vue"><a class="markdownIt-Anchor" href="#vue"></a> Vue</h2><h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3><h4 id="mvvm"><a class="markdownIt-Anchor" href="#mvvm"></a> MVVM</h4><p><code>MVVM</code>是一种软件架构模式，在vue中 M 代表<code>model</code>层（数据模型），负责数据模型。V代表<code>View</code>层（视图层），VM代表<code>ViewModel</code>（视图模型），它是<code>Model</code>和<code>View</code>之间的桥梁，数据会绑定到<code>viewModel</code>层，并自动将数据渲染到页面层，视图变化时会通知<code>viewModel</code>更新数据</p><h4 id="vue生命周期"><a class="markdownIt-Anchor" href="#vue生命周期"></a> Vue生命周期</h4><p><strong>创建前后：</strong></p><ul><li><code>beforeCreated（创建前）：</code> 数据观测和初始化事件还未开始，不能访问<code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code>上的数据方法。</li><li><code>created(创建后)：</code>实例创建完成，可以访问<code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code>上的数据方法，但此时渲染节点还未挂在到DOM上，所以不能访问。</li></ul><p><strong>挂载前后：</strong></p><ul><li><code>beforeMounted（挂载前）:</code> Vue实例还未挂在到页面html上，此时可以发起服务器请求</li><li><code>mounted（挂载后）:</code>Vue实例已经挂在完毕，可以操作DOM</li></ul><p><strong>更新前后：</strong></p><ul><li><code>beforeUpdate（更新前）:</code> 数据更新之前调用，还未渲染页面</li><li><code>updated（更新后）:</code>DOM重新渲染，此时数据和界面都是新的。</li></ul><p><strong>销毁前后：</strong></p><ul><li><code>beforeDestoryed（销毁前）:</code>实例销毁前调用，这时候能够获取到<code>this</code></li><li><code>destoryed（销毁后）:</code>实例销毁后调用，实例完全被销毁。</li></ul><h4 id="watch和computed的区别"><a class="markdownIt-Anchor" href="#watch和computed的区别"></a> watch和computed的区别</h4><p>watch：监听属性，用来监听数据的变化，没有缓存，当监听到的数据发生变化时都会执行毁掉函数</p><p>computed：计算属性，被监听的值有缓存，只有它依赖的属性值发生变化后，下一次获取computed的值时才会重新计算computed的值。（只有依赖发生变化后才会重新计算）</p><h4 id="v-for中key的作用"><a class="markdownIt-Anchor" href="#v-for中key的作用"></a> v-for中key的作用</h4><p>key是为了更高效的对比虚拟DOM中的每个节点是否相同，避免页面更新时重复更新节点</p><h4 id="v-if和v-show的区别"><a class="markdownIt-Anchor" href="#v-if和v-show的区别"></a> v-if和v-show的区别</h4><p><code>v-if</code>元素不可见 删除dom元素</p><p><code>v-show</code>元素可见 通过设置元素的<code>display：none</code>样式属性</p><h4 id="组件中的data为什么是一个函数"><a class="markdownIt-Anchor" href="#组件中的data为什么是一个函数"></a> 组件中的data为什么是一个函数</h4><p>因为对象是一个引用类型，如果data时一个对象的情况下会造成多个组件共用一个data，data为一个函数，每个组件都会有自己的私有数据空间，不会干扰其他组件的运行。</p><h4 id="vue组件通信"><a class="markdownIt-Anchor" href="#vue组件通信"></a> Vue组件通信</h4><h5 id="父子组件"><a class="markdownIt-Anchor" href="#父子组件"></a> 父子组件</h5><p>父传子</p><ul><li>props</li><li>$children</li><li>$refs</li></ul><p>子传父</p><ul><li>$emit</li><li>$parent</li></ul><h5 id="兄弟组件"><a class="markdownIt-Anchor" href="#兄弟组件"></a> 兄弟组件</h5><ul><li>provied</li><li>inject</li><li>eventBus</li><li>Vuex</li></ul><h4 id="vuex的基本使用"><a class="markdownIt-Anchor" href="#vuex的基本使用"></a> Vuex的基本使用</h4><p>Vuex用于vue中的数据状态管理，有五种属性：</p><ol><li><code>state</code>：<code>Vuex</code>的基本数据，用于存储变量</li><li><code>getter</code>：从<code>state</code>派生出来的数据，当相遇<code>state</code>的计算属性，在这里可以对<code>state</code>数据进行过滤、筛选等操作</li><li><code>mutation</code>：提交更新<code>state</code>数据的方法</li><li><code>action</code>：和<code>mutation</code>功能相似，都是用来提交更新，但<code>action</code>提交的是<code>mutation</code>，而不是直接变更数据，并且<code>action</code>可以包含异步操作</li><li><code>module</code>：模块化Vuex，每个模块都有自己的<code>state</code>、<code>mutation</code>、<code>actoion</code>、<code>getter</code></li></ol><h5 id="mutation和action的区别"><a class="markdownIt-Anchor" href="#mutation和action的区别"></a> mutation和action的区别</h5><ul><li><code>mutation</code>更专注于修改<code>state</code>，必须是同步执行。</li><li><code>action</code>提交的是<code>mutation</code>，而不是直接更新数据，可以是异步的。</li><li><code>action</code>可以整合多个<code>mutation</code></li></ul><h4 id="vuex和localstory的区别"><a class="markdownIt-Anchor" href="#vuex和localstory的区别"></a> Vuex和localstory的区别</h4><ul><li><code>Vuex</code>存储在内存中，页面关闭刷新就会消失。而<code>localstorage</code>存储在本地，读取内存比读取硬盘速度要快</li><li><code>Vuex</code>应用于组件之间的传值，<code>localstorage</code>主要用于不同页面之间的传递</li><li><code>Vuex</code>是响应式的，<code>localstorage</code>需要刷新</li></ul><h4 id="路由守卫"><a class="markdownIt-Anchor" href="#路由守卫"></a> 路由守卫</h4><ul><li>全局前置钩子：<code>beforeEach</code>、<code>beforeResolve</code>、<code>afterEach</code></li><li>路由独享守卫：<code>beforeEnter</code></li><li>组件内钩子：<code>beforeRouterEnter</code>、<code>beforeRouterUpdate</code>、<code>beforeRouterLeave</code></li></ul><h4 id="hash和history的区别"><a class="markdownIt-Anchor" href="#hash和history的区别"></a> hash和history的区别</h4><h5 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> hash</h5><p>hash模式是vue开发中的默认模式，地址栏URL携带<code>#</code>，<code>#</code>后为路由。</p><p>原理是通过<code>onhashchange()</code>事件监听路由<code>hash</code>的变化，这个好处就是当<code>hash</code>值发生变化，不需要向后端发起请求，<code>window</code>就可以监听事件的改变，并按照规则加载项对应的代码。除此之外，<code>hash</code>值的变化对应的<code>URL</code>都会被浏览器记录下来，这样就能实现浏览器历史页面的前进后退。</p><h5 id="history"><a class="markdownIt-Anchor" href="#history"></a> history</h5><p>vue还提供<code>history</code>模式，在<code>history</code>模式下URL中没有<code>#</code>，相比hash模式更加好看。但是需要后台配置支持。</p><p><code>history</code>的原理是利用<code>HTML5中hostory</code>提供的<code>pushState</code>、<code>replaceState</code>这两个API，这两个API记录了浏览器历史栈，并且当在修改<code>URL</code>时不会触发页面刷新和后台请求。</p><h4 id="动态路由"><a class="markdownIt-Anchor" href="#动态路由"></a> 动态路由</h4><h5 id="定义方式"><a class="markdownIt-Anchor" href="#定义方式"></a> 定义方式</h5><ul><li>params传参<ul><li>路由配置： <code>/index/:id</code></li><li>路由跳转：<code>this.$router.push(&#123;name: 'index', params: &#123;id: &quot;zs&quot;&#125;&#125;);</code></li><li>路由参数获取：<code>this.params.id</code></li><li>最后形成的路由：<code>/index/zs</code></li></ul></li><li>query传参<ul><li>路由配置：<code>/index</code>正常的路由配置</li><li>路由跳转：<code>this.$rouetr.push(&#123;path: 'index', query:&#123;id: &quot;zs&quot;&#125;&#125;);</code></li><li>路由参数获取：<code>this.query.id</code></li><li>最后形成的路由：<code>/index?id=zs</code></li></ul></li></ul><h5 id="router-和route"><a class="markdownIt-Anchor" href="#router-和route"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext>和</mtext></mrow><annotation encoding="application/x-tex">router 和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord cjk_fallback">和</span></span></span></span>route</h5><ul><li><code>$router</code>是指整个路由对象，可以使用<code>this.$router.push(&#123;name: ;index'&#125;)</code>进行页面跳转</li><li><code>$route</code>时指当前页面的路由对象，可以使用<code>this.$route.parmas.id</code>来获取当前路由对象传递进来的参数</li></ul><h4 id="vue性能优化"><a class="markdownIt-Anchor" href="#vue性能优化"></a> Vue性能优化</h4><h3 id="原理知识"><a class="markdownIt-Anchor" href="#原理知识"></a> 原理知识</h3><h4 id="双向绑定原理"><a class="markdownIt-Anchor" href="#双向绑定原理"></a> 双向绑定原理</h4><p>data在初始化的时候，会实例化一个<code>Observe</code>类，在它会将data数据进行递归遍历，并且通过<code>definereactive</code>方法，这个方法通过<code>Object.defineProperty</code>方法，给每个值添加上一个<code>getter</code>和一个<code>setter</code>。在数据读取的时候会触发getter进行依赖（Watcher）收集，当数据改变时，会触发<code>setter</code>，对刚刚收集的依赖进行触发，并且更新<code>watcher</code>通知视图进行渲染。</p><h4 id="依赖收集"><a class="markdownIt-Anchor" href="#依赖收集"></a> 依赖收集</h4><p>依赖收集发生在<code>defineReactive()</code>方法中，在方法内<code>new Dep()</code>实例化一个<code>Dep()</code>实例，然后在<code>getter</code>中通过<code>dep.depend()</code>方法对数据依赖进行收集，然后在<code>settter</code>中通过<code>dep.notify()</code>通知更新。整个<code>Dep</code>其实就是一个观察者，吧收集的依赖存储起来，在需要的时候进行调用。在收集数据依赖的时候，会为数据创建一个<code>Watcher</code>，当数据发生改变通知每个<code>Watcher</code>，由<code>Wathcer</code>进行更新渲染。</p><h4 id="objectdefineproperty数据劫持缺陷"><a class="markdownIt-Anchor" href="#objectdefineproperty数据劫持缺陷"></a> Object.defineProperty()数据劫持缺陷</h4><p>该方法只能监听到数据的修改，监听不到数据的新增和删除。vue2中会对数组的新增删除方法<code>push、pop、shift、unshift、splice、sort、reserve</code>通过重写的形式，在拦截里面进行手动收集触发依赖更新。</p><p>在vue2中，需要数据里添加或删除时，使用<code>vue.$set/vue.$delete</code>进行操作。</p><p>在Vue3中，改用<code>proxy</code>对对象进行代理，返回一个代理对象，只需要操作新对象就可以。</p><h4 id="双向绑定原理-2"><a class="markdownIt-Anchor" href="#双向绑定原理-2"></a> 双向绑定原理</h4><p>Vue双向绑定是一个指令<code>v-model</code>，可以将数据动态绑定到视图上，同时视图中变化也可以改变改值。他的本质是 <code>v-bind</code> 和 <code>v-on</code> 的语法糖。在 ⼀个组件上使⽤ <code>v-model</code>，默认会为组件绑定名为 <code>value</code>的 prop 和名为 <code>input</code>的事件。</p><h4 id="nexttick的实现"><a class="markdownIt-Anchor" href="#nexttick的实现"></a> nextTick的实现</h4><p>vue中的<code>nextTick</code>是浏览器<code>eventLoop</code>是应用。<code>nextTick</code>是将回调函数放到一个异步队列中，保证在异步更新DOM的<code>watcher</code>后面，从而获取到更新后的DOM。</p><p>Vue在更新DOM时是异步执行的。只要侦听到数据变化，<code>Vue</code>将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</p><h4 id="怎么理解-vue-中的虚拟-dom"><a class="markdownIt-Anchor" href="#怎么理解-vue-中的虚拟-dom"></a> 怎么理解 vue 中的虚拟 DOM</h4><p>虚拟DOM，就是用一个<code>JS</code>对象来描述一个<code>DOM</code>节点。<code>Vue</code>是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作<code>DOM</code>,而操作真实<code>DOM</code>又是非常耗费性能的，这是因为浏览器的标准就把 <code>DOM</code> 设计的非常复杂，所以一个真正的 <code>DOM</code> 元素是非常庞大的。<code>VNode</code>类中包含了描述一个真实<code>DOM</code>节点所需要的一系列属性，<code>tag</code>表示节点的标签名，<code>text</code>表示节点中包含的文本，<code>children</code>表示该节点包含的子节点等。</p><h4 id="模版编译原理"><a class="markdownIt-Anchor" href="#模版编译原理"></a> 模版编译原理</h4><p>模版编译主要过程：<code>template ---&gt; ast ---&gt; render</code>，分别对象三个方法</p><ul><li><code>parse</code> 函数解析 <code>template</code></li><li><code>optimize</code> 函数优化静态内容</li><li><code>generate</code> 函数创建 <code>render</code> 函数字符串</li></ul><p>调用<code>parse</code>方法，将<code>template</code>转化为<code>AST</code>（抽象语法树），<code>AST</code>定义了三种类型，一种<code>html</code>标签，一种文本，一种插值表达式，并且通过 <code>children</code> 这个字段层层嵌套形成了树状的结构。</p><p><code>optimize</code>方法对<code>AST</code>树进行静态内容优化，分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化。</p><p><code>generate</code>将<code>AST</code>抽象语法树编译成 <code>render</code>字符串，最后通过<code>new Function(render)</code>生成可执行的<code>render</code>函数</p><h4 id="diff算法逻辑"><a class="markdownIt-Anchor" href="#diff算法逻辑"></a> diff算法逻辑</h4><p><code>diff</code>算法发生在视图更新阶段，也就是当数据发生变化的时候，<code>diff</code>会对新就虚拟DOM进行对比，只渲染有变化的部分。</p><p>当数据发生变化的时候，依赖对应的<code>watcher</code>会通知更新，生成一个新的<code>vnode</code>，新的<code>vnode</code>会去和旧的<code>vnode</code>进行对比更新。</p><p>整个更新的过程就是调用path函数，主要做了三件事：</p><ul><li>创建节点：新的<code>vnode</code>中有而旧的<code>vnode</code>中的节点，在旧<code>vnode</code>中进行创建</li><li>删除节点：新的<code>vnode</code>中没有二旧的<code>vnode</code>中有，在旧的<code>vnode</code>中删除</li><li>更新节点：新的<code>vnode</code>和旧的<code>vnode</code>中都有，以新的<code>vnode</code>位主，更新旧的<code>vnode</code></li></ul><h4 id="new-vue的流程"><a class="markdownIt-Anchor" href="#new-vue的流程"></a> new Vue的流程</h4><p>合并配置，调用一些初始化函数，触发生命周期钩子函数，调用<code>$mount</code>开启下一个阶段。</p><h4 id="keep-live原理"><a class="markdownIt-Anchor" href="#keep-live原理"></a> keep-live原理</h4><p><code>keep-alive</code>是Vue.js的一个内置组件。它能够将不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。</p><p>通过<code>include、exclude</code>来匹配和排除缓存，<code>max</code>定义缓存的上限。</p><p><code>keep-alive</code>内部其实是一个函数式组件，没有<code>template</code>标签。在<code>render</code>中通过获取组件的<code>name</code>和<code>include、exclude</code>进行匹配。匹配不成功，则不需要进行缓存，直接返回该组件的Vnode。</p><p>匹配成功就进行缓存，获取组件的<code>key</code>在<code>this.cache</code>中进行查找，如果存在就直接将缓存的组件实例覆盖到当前的Vnode上，然后将当前组件的<code>key</code>从<code>keys</code>中进行删除，然后在<code>push(key)</code>添加到尾部，这样做是为了改变<code>key</code>当前的位置，也就实现了<code>max</code>功能。</p><p>不存在的话，就需要对组件进行缓存。将当前组件<code>push(key)</code>添加到尾部，然后再判断当前缓存的max是否超出指定个数，如果超出直接将第一个组件销毁（缓存淘汰策略LRU）。</p><blockquote><p>LRU（<strong>Least recently used</strong>，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p></blockquote><h2 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化"></a> 性能优化</h2><h3 id="网站优化"><a class="markdownIt-Anchor" href="#网站优化"></a> 网站优化</h3><ul><li>使用浏览器缓存机制</li><li>资源懒加载、预加载</li><li>骨架屏</li><li>合理使用雪碧图、字体图标、</li></ul><h3 id="代码优化"><a class="markdownIt-Anchor" href="#代码优化"></a> 代码优化</h3><ul><li>减少回流重绘</li><li>减少DOM的操作</li><li>节流防抖</li><li>使用事件委托</li><li>将CSS文件放在头部、js文件放在底部</li></ul><h3 id="请求优化"><a class="markdownIt-Anchor" href="#请求优化"></a> 请求优化</h3><ul><li>使用CDN加速</li><li>开启nginx，Gzip压缩</li><li>使用强缓存、协商缓存</li><li>减少、合并请求</li></ul><h3 id="webpack优化"><a class="markdownIt-Anchor" href="#webpack优化"></a> webpack优化</h3><ul><li>按需加载</li><li>代码打包体积压缩</li><li>移除console</li><li>压缩图片、字体等本地资源</li><li>分离css文件，单独进行打包</li></ul><h2 id="浏览器相关"><a class="markdownIt-Anchor" href="#浏览器相关"></a> 浏览器相关</h2><h3 id="跨域"><a class="markdownIt-Anchor" href="#跨域"></a> 跨域</h3><p>浏览器的同源策略会导致跨域问题</p><h4 id="同源策略"><a class="markdownIt-Anchor" href="#同源策略"></a> 同源策略</h4><p>同源指的是：<strong>协议</strong>、<strong>端口号</strong>、<strong>域名</strong>必须一致。</p><p>同源策略的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作</p><h4 id="解决跨域问题"><a class="markdownIt-Anchor" href="#解决跨域问题"></a> 解决跨域问题</h4><ul><li>CORS：服务器开启跨域资源共享</li><li>JSONP：利用JavaScript标签不存在跨域限制，只支持GET请求</li><li>Nginx：反向代理</li></ul><h3 id="本地存储"><a class="markdownIt-Anchor" href="#本地存储"></a> 本地存储</h3><h4 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> Cookie</h4><ul><li>存储小，只有4k</li><li>不同域之间不能共享</li><li>不安全，容易被拦截</li></ul><h4 id="sessionstorage"><a class="markdownIt-Anchor" href="#sessionstorage"></a> SessionStorage</h4><ul><li>存储在内存中，体积相对较大</li><li>页面关闭，数据会删除</li><li>相对Cookie安全</li></ul><h4 id="localstorage"><a class="markdownIt-Anchor" href="#localstorage"></a> LocalStorage</h4><ul><li>体积大，可以存储更多内容</li><li>生命周期长，需要手动删除</li><li>存储在硬盘，不会像cookie一样被请求携带</li></ul><h3 id="从输入一个-url-地址到浏览器完成渲染的整个过程"><a class="markdownIt-Anchor" href="#从输入一个-url-地址到浏览器完成渲染的整个过程"></a> 从输入一个 URL 地址到浏览器完成渲染的整个过程</h3><ol><li>浏览器输入<code>URL</code>并回车</li><li>浏览器查找当前是否有缓存</li><li><code>DNS</code>解析<code>URL</code>得到<code>IP</code><ol><li>浏览器<code>DNS</code>缓存</li><li><code>host</code>文件缓存</li></ol></li><li>建立<code>TCP</code>连接（三次握手）</li><li>发送<code>HTTP</code>请求</li><li>服务器处理请求，浏览器得到响应数据</li><li>浏览器解析渲染页面<ol><li>解析<code>DOM</code>生成<code>DOM</code>树</li><li>解析<code>CSS</code>生成<code>CSS</code>树</li><li>合并<code>DOM</code>树和<code>CSS</code>树，生成渲染树</li><li>浏览器开始渲染页面（回流重绘发生在这个阶段）</li></ol></li><li><code>TCP</code>连接关闭（四次挥手）</li></ol><h2 id="网络协议-安全相关"><a class="markdownIt-Anchor" href="#网络协议-安全相关"></a> 网络协议、安全相关</h2><h3 id="tcp-udp协议"><a class="markdownIt-Anchor" href="#tcp-udp协议"></a> TCP、UDP协议</h3><p><code>TCP</code>和<code>UDP</code>都是在传输层定义的两种传输协议。基于<code>UDP</code>协议传输不能保证数据准确无误的送达，但<code>UDP</code>不仅可以支持一对一的传输方式，还可以支持一对一、一对多等形式。也不需要像<code>TCP</code>一样建立连接，所以传输速度快。</p><p><code>TCP</code>的目的是提供可靠的数据，并且需要在传输前建立连接（三次握手）。只支持一对一进行传输。</p><p><strong>区别：</strong></p><ul><li><code>TCP</code>协议可靠，<code>UDP</code>协议不可靠</li><li><code>TCP</code>面向连接，<code>UDP</code>采用无连接</li><li><code>TCP</code>可以保证数据顺序，<code>UDP</code>不能</li><li><code>TCP</code>一对一传输，<code>UDP</code>可以一对多、多对一等形式</li></ul><h3 id="http和https区别"><a class="markdownIt-Anchor" href="#http和https区别"></a> HTTP和HTTPS区别</h3><ul><li><code>HTTP</code>是明文传输，不安全。<code>HTTPS</code>基于<code>SSL</code>进行加密传输，比较安全。</li><li><code>HTTPS</code>需要<code>CA</code>证书，<code>HTTP</code>不需要。</li><li><code>HTTP</code>端口为<code>80</code>，<code>HTTPS</code>端口为<code>443</code></li></ul><h3 id="http状态码"><a class="markdownIt-Anchor" href="#http状态码"></a> HTTP状态码</h3><ul><li>1XX: 请求正在处理</li><li>2XX：正常状态码<ul><li>200 ：请求处理成功</li><li>201 ： 请求成功并且服务器创建了新资源</li><li>202 ：服务器已经接收请求，但尚未处理</li></ul></li><li>3XXX：重定向状态<ul><li>301 ：请求重定向</li><li>302: 临时重定向</li><li>303: 临时重定向，使用get请求新的url</li><li>304：浏览器缓存相关</li></ul></li><li>4XX：错误状态码<ul><li>400: 服务器无法理解请求格式，需要修改请求内容后再次发起请求</li><li>401: 请求未授权</li><li>403: 禁止访问</li><li>404: 服务器上无法找到请求资源</li></ul></li><li>5XX：服务器错误<ul><li>500: 服务端错误</li><li>503: 服务器暂时无法处理请求</li></ul></li></ul><h3 id="http三次握手-四次挥手"><a class="markdownIt-Anchor" href="#http三次握手-四次挥手"></a> HTTP三次握手、四次挥手</h3><h4 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h4><p>三次握手是在建立<code>TCP</code>连接时，客户端和服务端总共发送三个包。进行三次握手的主要目的就是为了确认双方的接受能力和发送能力都是正常的，为后面传输可靠数据做准备。</p><p><strong>报文：</strong></p><ul><li>序号：表示发送的数据字节流，确保TCP传输有序，对每个字节编号</li><li>确认序号：发送方期待接收的下一序列号，接收成功后的数据字节序列号加 1。只有<code>ACK=1</code>时才有效。</li><li><code>ACK</code>：确认序号的标志，<code>ACK=1</code>表示确认号有效，<code>ACK=0</code>表示报文不含确认序号信息</li><li><code>SYN</code>：连接请求序号标志，用于建立连接，<code>SYN=1</code>表示请求连接</li><li><code>FIN</code>：结束标志，用于释放连接，<code>FIN=1</code>表示关闭本方数据流</li></ul><p><strong>三次握手：</strong></p><ol><li>第一次握手：客户端给服务端发一个 <code>SYN</code>报文，并指明客户端的初始化序列号<code>ISN</code>，此时客户端处于 <code>SYN_SEND</code> 状态。</li><li>务器收到客户端的<code>SYN</code> 报文之后，会以自己的<code>SYN</code>报文作为应答，并且也是指定了自己的初始化序列号<code>ISN</code>。同时会把客户端的 <code>ISN + 1</code>作为<code>ACK</code>的值，表示自己已经收到了客户端的<code>SYN</code>，此时服务器处于 <code>SYN_REVD</code>的状态。</li><li>客户端收到<code>SYN</code>报文之后，会发送一个 <code>ACK</code>报文，当然，也是一样把服务器的 <code>ISN + 1</code>作为 <code>ACK</code>的值，表示已经收到了服务端的 <code>SYN</code>报文，此时客户端处于<code>ESTABLISHED</code> 状态。服务器收到 <code>ACK</code>报文之后，也处于 <code>ESTABLISHED 状</code>态，此时，双方已建立起了连接。</li></ol><h4 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h4><ol><li>客户端会发送一个<code>FIN</code>报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code>状态。</li><li>服务端收到 <code>FIN</code> 之后，会发送 <code>ACK</code> 报文，且把客户端的序列号值 +1 作为 <code>ACK</code>报文的序列号值，表明已经收到客户端的报文了，此时服务端处于<code>CLOSE_WAIT</code> 状态。</li><li>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 <code>FIN</code>报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code>的状态。</li><li>客户端收到<code>FIN</code> 之后，一样发送一个<code>ACK</code>报文作为应答，且把服务端的序列号值 +1 作为自己 <code>ACK</code>报文的序列号值，此时客户端处于 <code>TIME_WAIT</code>状态。需要过一阵子以确保服务端收到自己的 <code>ACK</code> 报文之后才会进入 <code>CLOSED</code>状态，服务端收到 <code>ACK</code>报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。</li></ol><h4 id="为什么需要四次挥手"><a class="markdownIt-Anchor" href="#为什么需要四次挥手"></a> 为什么需要四次挥手</h4><p>因为当服务端收到客户端的<code>SYN</code>连接请求报文后，可以直接发送<code>SYN+ACK</code>报文。其中<code>ACK</code>报文是用来应答的，<code>SYN</code>报文是用来同步的。但是关闭连接时，当服务端收到<code>FIN</code>报文时，很可能并不会立即关闭<code>SOCKET</code>，所以只能先回复一个<code>ACK</code>报文，告诉客户端，“你发的<code>FIN</code>报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送<code>FIN</code>报文，因此不能一起发送。故需要四次挥手。</p><h3 id="http缓存"><a class="markdownIt-Anchor" href="#http缓存"></a> HTTP缓存</h3><h4 id="强缓存"><a class="markdownIt-Anchor" href="#强缓存"></a> 强缓存</h4><p>使用强制缓存策略，如果缓存资源有效，就直接使用缓存资源，不需要向服务器发送请求。强制缓存通过两种方式来设置，在<code>request headers</code>中的<code>Expires</code>属性和<code>Cache-Contorl</code>属性。</p><p><code>Expires</code>属性，指定资源的过期时间。在过期时间以内，改资源可以被缓存使用，不需要向浏览器发送请求。这个时间依赖于服务器时间，会存在服务器时间和客户端时间不一致。</p><p><code>Cache-Control</code>属性：</p><ul><li><code>private</code>： 仅浏览器可以缓存</li><li><code>public</code>：浏览器和代理服务器都可以缓存</li><li><code>max-age=xxx</code> 过期时间，单位为秒</li><li><code>no-cache</code> 不进行强缓存，但会有协商缓存</li><li><code>no-store</code>不强缓存，也不协商缓存</li></ul><p>如果<code>request header</code>中，<code>Cache- Control</code>的值中有<code>max-age=xxx</code>，这个时候走强缓存。如果值为<code>no-cache</code>，表明没有命中，走协商缓存。如值为<code>no-store</code>，不使用缓存。</p><h4 id="协商缓存"><a class="markdownIt-Anchor" href="#协商缓存"></a> 协商缓存</h4><p>如果没有命中强制缓存，在设置协商缓存情况下，先向服务器发送一个请求，如果资源没有发生修改，则返回一个<code>304</code>的状态，让浏览器使用本地的缓存副本。如果资源发生修改，则返回修改后的资源。在<code>request headers</code>中的<code>Etag</code>属性和<code>Last-Modified</code>属性，来进行设置。其中，<code>ETage</code>优先于<code>Last-Modified</code>。</p><p>命中协商缓存条件：</p><ul><li><code>Cache-Control: no-cache</code></li><li><code>max-age</code>时间过期</li></ul><p><strong>Last-Modified（文件的修改时间）：</strong></p><p>服务器在响应头中添加<code>Last-Modified</code>属性，来指出资源最后一次修改时间。当浏览器发起请求时，会在<code>request headers</code>中添加一个<code>If-None-Since</code>属性，值为上一次请求的资源返回的<code>Last-Modified</code>值。服务端会通过这个属性和资源最后一次修改时间进行对比，以此来判断资源是否修改。如果资源没有修改，请求返回304状态，客户端使用本地缓存。如果资源有修改，则返回修改的资源。</p><p>这种方式有一个缺点，<code>Last-Modified</code>标记的时间只能精确到秒。</p><p><strong>ETag（文件改动）：</strong></p><p>同样在服务器返回资源的时候，在头信息中添加<code>ETag</code>属性，这个属性是资源的唯一标识符。当资源改变时，这个值也会改变。在一下次请求资源时，会在<code>request headers</code>中添加一个<code>If-None-Match</code>属性，值为上一次请求的资源返回的<code>ETag</code>值。服务端会通过这个属性和资源最后一次修改时间进行对比，以此来判断资源是否修改。这种方式比<code>Last-Modified</code>更加准确。</p><h4 id="区别-2"><a class="markdownIt-Anchor" href="#区别-2"></a> 区别</h4><ul><li>强缓存优先级高于协商缓存</li><li>强缓存不需要发请求，协商缓存需要。</li><li>强缓存返回的状态码为<code>200</code>，协商缓存返回<code>304</code></li><li>ctrl+F5强制刷新会跳过所有缓存，而F5刷新跳过强缓存，但是会检查协商缓存。</li></ul><h3 id="post和get的区别"><a class="markdownIt-Anchor" href="#post和get的区别"></a> POST和GET的区别</h3><ul><li>传递的参数不同，<code>POST</code>传递的参数在<code>request body</code>中，<code>GET</code>传递的参数在<code>url</code>后拼接</li><li><code>POST</code>相对<code>GET</code>请求安全</li><li><code>GET</code>请求长度有限制，<code>POST</code>没有</li><li><code>GET</code>请求会被浏览器主动缓存，<code>POST</code>不会，要手动设置</li><li><code>GET</code>请求一般用于查询，<code>POST</code>一般用于提交某种信息进行某些修改操作</li></ul><h3 id="xss-csrf攻击"><a class="markdownIt-Anchor" href="#xss-csrf攻击"></a> XSS、csrf攻击</h3><h4 id="xss跨站脚本攻击"><a class="markdownIt-Anchor" href="#xss跨站脚本攻击"></a> XSS（跨站脚本攻击）</h4><p><code>Xss(cross-site scripting)</code> 是一种代码注入攻击，攻击者往<code>Web</code>页面里插入恶意 <code>html</code> 标签或者 <code>javascript</code>代码。在骗取用户点击后获取用户，获取用户信息。</p><p><strong>避免方式：</strong></p><ul><li><code>url</code>参数通过<code>encodeURIComponent</code>方法进行转义</li><li>尽量不使用<code>InnerHtml</code>插入<code>HTML</code>内容</li><li>对用户输入的地方和变量都需要仔细检查长度和对 ”&lt;”,”&gt;”,”;”,”’” 等字符做过滤</li></ul><h4 id="csrf跨站请求伪造"><a class="markdownIt-Anchor" href="#csrf跨站请求伪造"></a> CSRF（跨站请求伪造）</h4><p><code>CSRF</code>（<code>Cross-site request forgery</code>）攻击者盗用你的身份信息，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p><strong>避免方式：</strong></p><ul><li>添加验证码验证</li><li>使用<code>token</code><ul><li>服务端给用户生成一个<code>token</code>，加密后传递给用户</li><li>用户在提交请求时，需要携带这个<code>token</code></li><li>服务端验证<code>token</code>是否正确</li></ul></li></ul><h3 id="前端工程化"><a class="markdownIt-Anchor" href="#前端工程化"></a> 前端工程化</h3><h3 id="webpack的loader和plugin的区别"><a class="markdownIt-Anchor" href="#webpack的loader和plugin的区别"></a> webpack的loader和plugin的区别</h3><h4 id="loader"><a class="markdownIt-Anchor" href="#loader"></a> loader</h4><p>loader是导出一个函数的javascript模块，webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到<code>loader</code>。如babel-loader、Css-loader、image-loader、url-loader、Saas-loader…</p><h4 id="plugin"><a class="markdownIt-Anchor" href="#plugin"></a> plugin</h4><p>Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。如html-webpack-plugin、mini-css-extract-plugin、uglifyjs-webpack-plugin</p><h2 id="手写系列"><a class="markdownIt-Anchor" href="#手写系列"></a> 手写系列🤮</h2><h3 id="节流防抖"><a class="markdownIt-Anchor" href="#节流防抖"></a> 节流防抖</h3><h3 id="new操作符"><a class="markdownIt-Anchor" href="#new操作符"></a> new操作符</h3><h3 id="call-bind-apply实现"><a class="markdownIt-Anchor" href="#call-bind-apply实现"></a> call、bind、apply实现</h3><h3 id="发布订阅模式"><a class="markdownIt-Anchor" href="#发布订阅模式"></a> 发布订阅模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 事件列表</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventList</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">name, callBack</span>) &#123;</span><br><span class="line">    <span class="comment">// 以 name 为 key  创建容器   如果有容器就不用创建</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventList</span>[name]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">eventList</span>[name] = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把事件放入容器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventList</span>[name].<span class="title function_">push</span>([callBack])</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发</span></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">name, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventList</span>[name]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;没有找到事件！&#x27;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器中取出事件进行调用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventList</span>[name].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">item</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只触发一次</span></span><br><span class="line">  <span class="title function_">once</span>(<span class="params">name, callBack</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventList</span>[name]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 利用off  在callBack执行后  关闭订阅</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onceFn</span>(<span class="params">callBack</span>) &#123;</span><br><span class="line">      <span class="title function_">callBack</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(name, callBack);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(name, onceFn)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭监听  若第二个参数没有  移除 name 下所有的事件</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">name, callBack</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventList</span>[name]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callBack) &#123;</span><br><span class="line">      <span class="comment">// 只移除对应的callBack</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">eventList</span>[name] = <span class="variable language_">this</span>.<span class="property">eventList</span>[name].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;<span class="keyword">return</span> item !== callBack&#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// name容器长度为0 直接删除整个 name 事件订阅发布</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">eventList</span>[name].<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">eventList</span>[name];</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有 callBack  直接删除整个 name 事件订阅发布</span></span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">eventList</span>[name];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数柯里化实现"><a class="markdownIt-Anchor" href="#函数柯里化实现"></a> 函数柯里化实现</h3><h4 id="promise"><a class="markdownIt-Anchor" href="#promise"></a> promise</h4><h3 id="实现一个队列"><a class="markdownIt-Anchor" href="#实现一个队列"></a> 实现一个队列</h3><h3 id="数组去重"><a class="markdownIt-Anchor" href="#数组去重"></a> 数组去重</h3><h3 id="深浅拷贝"><a class="markdownIt-Anchor" href="#深浅拷贝"></a> 深浅拷贝</h3><h3 id="交换两个变量的值"><a class="markdownIt-Anchor" href="#交换两个变量的值"></a> 交换两个变量的值</h3><h3 id="数组扁平化"><a class="markdownIt-Anchor" href="#数组扁平化"></a> 数组扁平化</h3><h2 id="输出结果"><a class="markdownIt-Anchor" href="#输出结果"></a> 输出结果</h2><h3 id="闭包-2"><a class="markdownIt-Anchor" href="#闭包-2"></a> 闭包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;   </span><br><span class="line">　　<span class="keyword">var</span> object = &#123;   </span><br><span class="line">　　　　name : <span class="string">&quot;My Object&quot;</span>,   </span><br><span class="line">　　　　getNameFunc : <span class="keyword">function</span>(<span class="params"></span>)&#123;   </span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;   </span><br><span class="line">　　　　　　　　<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;   </span><br><span class="line">　　　　　&#125;;   </span><br><span class="line">　　　　&#125;   </span><br><span class="line">&#125;;   </span><br><span class="line"><span class="title function_">alert</span>(object.<span class="title function_">getNameFunc</span>()());  <span class="comment">//&quot;The Window&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aaa</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> a=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">bbb</span>(<span class="params"></span>) &#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="title function_">alert</span>(a);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> bbb</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ccc=<span class="title function_">aaa</span>();</span><br><span class="line"><span class="title function_">ccc</span>();  <span class="comment">//结果为1</span></span><br><span class="line"><span class="title function_">ccc</span>();  <span class="comment">//结果为2</span></span><br><span class="line"><span class="keyword">var</span> ddd=<span class="title function_">aaa</span>();</span><br><span class="line"><span class="title function_">ddd</span>();  <span class="comment">//结果为1</span></span><br><span class="line"><span class="title function_">ddd</span>();  <span class="comment">//结果为2</span></span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://github.com/gebilaofan/2021-FE-Review">github 同步</a></p><blockquote><p>参考：</p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6941194115392634888#heading-2">2021」高频前端面试题</a></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6989422484722286600#heading-43">2021年我的前端[[…/…/4-前端要努力/前端面试/1、面试准备|面试准备]]</a></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6914831351271292936#heading-60">震惊！前端300基础面试题+答案、分类学习整理（良心制作）持续更新</a></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6917816624040902670#heading-21">高级知识点</a></p></blockquote></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://wakaka378.github.io/fd8759a87419.html" title="2021前端面试复习" target="_blank" rel="external">https://wakaka378.github.io/fd8759a87419.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/wakaka378" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/wakaka378" target="_blank"><span class="text-dark">wakaka378</span><small class="ml-1x">a Vuer</small></a></h3><div>我很懒，啥也没有</div></div></figure></div></div></div></article><section id="comments"></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/f0d2269aa2b7.html" title="2021当程序员碰到本命年..."><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/458c45be1d2c.html" title="js面向对象—封装"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button><div class="bar-right"></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>感谢您的支持，我会继续努力的!</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/wakaka378" target="_blank" title="Github"><i class="icon icon-github"></i></a></li><li><a href="https://juejin.cn/user/2348212570298807" target="_blank" title="Juejin"><i class="icon icon-juejin"></i></a></li></ul><div class="copyright">&copy; 2023 John Doe<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://utteranc.es/client.js" repo="wakaka378/utterances" issue-term="title" label="✨💬" theme="github-light" crossorigin="anonymous" async></script></body></html>