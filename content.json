{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://wakaka378.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-04-09T10:55:30.353Z","updated":"2023-04-09T10:55:30.352Z","comments":false,"path":"/404.html","permalink":"https://wakaka378.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-04-09T10:55:30.400Z","updated":"2023-04-09T10:55:30.400Z","comments":false,"path":"about/index.html","permalink":"https://wakaka378.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2023-04-09T10:55:30.548Z","updated":"2023-04-09T10:55:30.548Z","comments":false,"path":"tags/index.html","permalink":"https://wakaka378.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-04-09T10:54:23.884Z","updated":"2023-04-09T10:54:23.884Z","comments":false,"path":"repository/index.html","permalink":"https://wakaka378.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-04-09T10:55:30.456Z","updated":"2023-04-09T10:55:30.456Z","comments":false,"path":"categories/index.html","permalink":"https://wakaka378.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-04-09T10:55:30.431Z","updated":"2023-04-09T10:55:30.431Z","comments":false,"path":"books/index.html","permalink":"https://wakaka378.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-04-09T10:55:30.487Z","updated":"2023-04-09T10:55:30.487Z","comments":true,"path":"links/index.html","permalink":"https://wakaka378.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"防抖debounce理解","slug":"防抖debounce理解","date":"2023-04-09T13:54:09.000Z","updated":"2023-04-18T12:13:20.878Z","comments":true,"path":"2023-04-09-防抖debounce理解.html","link":"","permalink":"https://wakaka378.github.io/2023-04-09-%E9%98%B2%E6%8A%96debounce%E7%90%86%E8%A7%A3.html","excerpt":"","text":"「我正在参与掘金会员专属活动-源码共读第一期，点击参与」 前言 防抖相信大家都不陌生，面试中会经常会被问题或提起。比如会问一些前端优化、手写防抖节流函数等等，这里就跟着underscore 源码来学习一下。 定义 在规定时间后才执行，如果触发则重新计时 也就是说，防抖函数在n秒内，无论触发了多少次函数回调，我都只只在n秒后执行一次。比如我们设置一个等待时间为5秒的防抖函数，如果5秒内有触发，就需要重新计时，直到5秒内没有触发就调用执行。 使用场景 最近项目中有一个表单搜索场景，在输入文字的过程中会持续触发oninput事件，而搜索接口只是在用户输入搜索文字后进行调用。如果是用户输入一个文字就搜索一次，不仅会频繁调用后台接口，前端显示效果也不好。 使用防抖的话，可以将接口调用设定在500ms内没有触发oninput事件后再调用接口，这样就可以解决问题。 还会在其他场景使用 一些频繁点击操作的按钮，比如登录、短信验证，避免用户短时间多次发送 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖 鼠标移动mousedown计算等场景 实现原理 实现原理其实很简单，就是利用定时器，函数在最开始执行的时候就设定一个定时器，如果在n秒内有执行就吧定时器清空，重新设定一个新的定时器，当n秒内没有再调用后，定时器计时结束后就会触发回调。 第一版 123456789101112131415161718192021/*** debounce防抖* @param &#123; function &#125; fn 回调* @param &#123; number &#125; wait 等待时间*/function debounce(fn, wait = 300) &#123; // 利用闭包生成唯一的一个定时器 let timer = null; // 返回一个函数，当作触发事件执行 return function (...args) &#123; if (timer) &#123; // 上一次存在定时器，需要清空 clearTimeout(timer); &#125; // 设定定时器，定时器结束后执行回调函数 fn 如果多次触发就重新设定 timer = setTimeout(() =&gt; &#123; fn.apply(this, args); &#125;, wait); &#125;;&#125; 我们再写一个输入框事件来测试一下 123456789101112131415161718&lt;input type=&quot;text&quot; oninput=&quot;oninputHandler(event)&quot; /&gt;&lt;script&gt; const testFn = debounce((event) =&gt; &#123; console.log(&#x27;执行防抖&#x27;, event.target.value); &#125;, 1000); // 执行防抖 停止 scroll 事件后 1 秒执行回调 function oninputHandler(event) &#123; testFn(event); &#125; // 不执行防抖 function oninputHandler(event) &#123; console.log(&#x27;input change value: &#x27; + event.target.value); &#125;&lt;/script&gt; 这是没有执行防抖 开启防抖后 效果还是很明显的，从原来的输入一个值就触发，到现在1秒内没有输入才触发，至此，简单版防抖就已经实现了。 第二版 接下来再来对防抖做一下改造，在首次调用的时候立即执行函数，等到n秒内没有触发，才可以重新触发执行。 听起来有点绕，也就是说在oninput事件第一次触发的时候就执行，后续的触发都不执行。等到1秒内没有执行后，再触发oninput时又会执行第一次。 1234567891011121314151617181920212223242526272829303132333435363738/*** debounce防抖* @param &#123; function &#125; fn 回调* @param &#123; number &#125; wait 等待时间* @param &#123; boolean &#125; immediate 是否立即执行*/function debounce(fn, wait = 300, immediate = false) &#123; // 利用闭包生成唯一的一个定时器 let timer = null; // 返回一个函数，当作触发事件执行 return function (...args) &#123; if (timer) &#123; // 上一次存在定时器，需要清空 clearTimeout(timer); &#125; // immediate: true 时，首次触发后立即执行 if (immediate) &#123; // 是否首次执行过 const isExecute = !timer; // 赋值定时器 避免重复执行 timer = setTimeout(() =&gt; &#123; timer = null; &#125;, wait); // 首次执行 isExecute &amp;&amp; fn.apply(this, args); &#125; else &#123; // 设定定时器，定时器结束后执行回调函数 fn 如果多次触发就重新设定 timer = setTimeout(() =&gt; &#123; fn.apply(this, args); &#125;, wait); &#125; &#125;;&#125; underscore 源码 来看一下underscore里是如何实现的，先将核心代码复制出来，用上面的oninput事件来调试，看一下它的一个具体步骤。 在debounced方法内部打上一个断点，然后在输入框输入数据触发防抖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function debounce(func, wait, immediate) &#123; var timeout, previous, args, result, context; var later = function () &#123; // now获取的是当前时间 previous 会在第一次进入的时候记录 对比两个时间差是否小于 wait 等待时间 var passed = now() - previous; if (wait &gt; passed) &#123; // 小于等待时间 说明在 wait时间内有触发 重新设定定时器 timeout = setTimeout(later, wait - passed); &#125; else &#123; // 超过等待时间 执行回调 // 清空 timeout 避免影响到下次使用 timeout = null; // 判断是否立即执行 if (!immediate) result = func.apply(context, args); // This check is needed because `func` can recursively invoke `debounced`. // 清空上下文、arguments 参数 在回调里面嵌套使用 if (!timeout) args = context = null; &#125; &#125;; // 先执行这里 通过 restArguments 将处理结果当作函数进行返回 回调时传递 arguments 参数 var debounced = restArguments(function (_args) &#123; context = this; args = _args; // 触发一次记录时间 用来和等待时间对比 previous = now(); if (!timeout) &#123; // 第一次进入时执行 // 执行 later 函数 timeout = setTimeout(later, wait); // 立即执行 if (immediate) result = func.apply(context, args); &#125; return result; &#125;); // 取消执行 清空定时器等参数 debounced.cancel = function () &#123; clearTimeout(timeout); timeout = args = context = null; &#125;; return debounced;&#125; 源码还是有很多亮点的 增加了cancel方法，可以随时取消。 在执行回调的时候，吧函数结果当作返回值return出去，是为了避免回调中有返回数据。 通过记录每次执行时间差，来判断是否需要执行回调。","categories":[{"name":"js","slug":"js","permalink":"https://wakaka378.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wakaka378.github.io/tags/js/"},{"name":"性能优化","slug":"性能优化","permalink":"https://wakaka378.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"节流防抖","slug":"节流防抖","permalink":"https://wakaka378.github.io/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"}]},{"title":"vue中使用vue-socket.io的一些心得、踩坑记录","slug":"vue中使用vue-socket-io的一些心得、踩坑记录","date":"2023-04-09T11:56:28.000Z","updated":"2023-04-09T12:35:17.795Z","comments":true,"path":"2023-04-09-vue中使用vue-socket-io的一些心得、踩坑记录.html","link":"","permalink":"https://wakaka378.github.io/2023-04-09-vue%E4%B8%AD%E4%BD%BF%E7%94%A8vue-socket-io%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E3%80%81%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html","excerpt":"","text":"前言 vue项目中有使用到socket长连接，之前一直都是都是使用vue-socke.io[github地址]，但最近在使用时，出了一些莫名奇妙的bug，也是为此掉了不少头发，最后还是解决了。关于socket相关内容介绍以及使用场景，这里不会做太多介绍（主要是懒），可以翻看其他文章。本文主要介绍如何使用，以及再使用时需要注意一些什么。关于文章中使用的代码，我放上github地址。前端小鸟一枚，立誓要成为前端菜鸟，不足地方留言指出，小子谢过。 安装 这里我们安装vue.socket.io模块和socket.io-client模块，也可以不用socket.io-client模块，请往下看。 12345cnpm i vue-socket.io -Scnpm i socket.io-client -Syarn vue-socket.ioyarn i socket.io-client vue 客户端使用 使用socket.io-client连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import VueSocketIO from &#x27;vue-socket.io&#x27;import SocketIO from &quot;socket.io-client&quot;Vue.config.productionTip = false// socket 连接参数const socketOptions = &#123; autoConnect: false, // 自动连接 这里为我项目需求 需要在指定情况下才连接socket&#125;// 注册Vue.use( new VueSocketIO(&#123; debug: true , // debug调试，生产建议关闭 connection: SocketIO(&quot;127.0.0.1:1024&quot;, socketOptions), store, // 如果没有使用到store可以不用写 &#125;))new Vue(&#123; // 这里为全局监听socket事件消息，监听函数这里只写了一点，其实很有很多事件。 sockets: &#123; connecting() &#123; console.log(&#x27;正在连接&#x27;) &#125;, disconnect() &#123; console.log(&quot;Socket 断开&quot;); &#125;, connect_failed() &#123; cosnole.log(&#x27;连接失败&#x27;) &#125;, connect() &#123; console.log(&#x27;socket connected&#x27;) &#125; &#125;, router, store, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 字符串连接 如果是正常使用，项目启动就连接socket，可以不需要加载socket.io-client模块，直接使用。 12345678// 注册Vue.use( new VueSocketIO(&#123; debug: true , // debug调试，生产建议关闭 connection: 127.0.0.1:1024, store, // 如果没有使用到store可以不用写 &#125;)) 组件中使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;nav&quot;&gt; &lt;button @click=&quot;connect&quot;&gt;连接socket&lt;/button&gt; &lt;button @click=&quot;sendMessage&quot;&gt;发送数据&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; &#125; &#125;, methods:&#123; // 连接socket connect() &#123; this.$socket.open() // 开始连接socket // 订阅事件 this.sockets.subscribe(&#x27;welcome&#x27;, data =&gt; &#123; console.log(&#x27;welcome data &#x27;, data) &#125;) &#125;, // 发送消息 sendMessage() &#123; this.$socket.emit(&#x27;hello&#x27;, &#x27;这里是客户端&#x27;) &#125; &#125;, sockets:&#123; // welcome: data =&gt; &#123; console.log(&#x27;welcome data &#x27;, data) &#125; &#125;&#125;&lt;/script&gt; 客户端使用总结 客户端自带监听事件 connect：连接成功 connecting：正在连接 disconnect：断开连接 connect_failed：连接失败 error：错误发生，并且无法被其他事件类型所处理 reconnect_failed：重连失败 reconnect：成功重连 reconnecting：正在重连 监听自定义事件 全局监听 12345sockets:&#123; welcome: data =&gt; &#123; console.log(&#x27;welcome data&#x27;, data) &#125;&#125; 组件内监听 123this.sockets.subscribe(&#x27;welcome&#x27;, data =&gt; &#123; console.log(&#x27;welcome&#x27;, data)&#125;) 发送消息 注意：监听用的是this.sockets，发送消息是this.$socket，不要弄混。 1this.$socket.emit(&#x27;hello&#x27;, &#x27;这里是客户端&#x27;) 关于跨域问题 socket会存在跨域问题，之前看文章又说到在vue.config.js中配置代理，差不多和后台接口代理配置一样，但我试过好像没啥鸟用，如果有知道的同学麻烦留言告诉一声，实际项目中的解决方式还是后端配置跨域问题。 服务端使用 这里为啥要讲服务端使用，主要是为了让同学更好的体验socket，其次是为了引出后面的bug，也是一个扩展知识把，是不是觉得自己赚了😄。本地开启socket服务可以更好的进行调试。服务端主要还是使用node，毕竟咱也不会java、python…，这里以及配置了socket跨域。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* * @Descripttion: * @version: * @Author: fanliu * @Date: 2020-06-19 18:22 * @LastEditors: fanliu * @LastEditTime: 2020-06-19 18:30 */var http = require(&#x27;http&#x27;);var io = require(&#x27;socket.io&#x27;);// 创建server服务var server = http.createServer(function (req, res) &#123; var headers = &#123;&#125;; headers[&quot;Access-Control-Allow-Origin&quot;] = &quot;*&quot;; headers[&quot;Access-Control-Allow-Methods&quot;] = &quot;POST, GET, PUT, DELETE, OPTIONS&quot;; headers[&quot;Access-Control-Allow-Credentials&quot;] = true; headers[&quot;Access-Control-Max-Age&quot;] = &#x27;86400&#x27;; // 24 hours headers[&quot;Access-Control-Allow-Headers&quot;] = &quot;X-Requested-With, Access-Control-Allow-Origin, X-HTTP-Method-Override, Content-Type, Authorization, Accept&quot;; res.writeHead(200, headers); res.end();&#125;);// 启动服务器 监听 1024 端口server.listen(1024,function() &#123; console.log(&#x27;server runing at 127.0.0.1:1024&#x27;)&#125;)// 启动socket服务var socket = io.listen(server, &#123;origins: &#x27;*:*&#x27;&#125;);// 监听客户端连接socket.on(&#x27;connection&#x27;,function(socket) &#123; console.log(&#x27;客户端有连接&#x27;) // 监听客户端断开 socket.on(&#x27;disconnect&#x27;, () =&gt; &#123; console.log(&#x27;客户端断开&#x27;) &#125;) // 给客户端发送消息 socket.emit(&#x27;welcome&#x27;,&#x27;欢迎连接socket&#x27;) // 监听客户端消息 socket.on(&#x27;hello&#x27;, data =&gt; &#123; console.log(&#x27;接收客户端发送数据&#x27;, data) &#125;)&#125;); 服务端总结 服务端接收和发送消息和客户端对调的，客户端emit发送消息，那么服务端这里就要on监听客户端发送的消息，服务的发送同理。 踩坑 订阅事件记得要取消 socket主要还是用来写聊天室，加入socket房间后要订阅房间内所有的聊天内容，这时如果没有取消之前的订阅事件，下次进入会多次订阅消息。也就是别人只发一条消息，你这边接收到的却是两条甚至多条。哪如何取消订阅呢，我的处理方式是在离开当前聊天页面后，自动取消之前所有的订阅事件。 123beforeDestroy() &#123; this.sockets.unsubscribe(eventName)&#125; 同理，如果是有指定页面才加入socket房间，退出页面时也要记得关闭socket连接。比如你在created中开始连接socket，在beforeDestroy要记得关闭socket，不然下次进入也会连接socket。 12345678created() &#123; this.$socket.open() // 查看socket是否连接成功 this.$socket.connected&#125;beforeDestroy() &#123; this.$socket.close()&#125; Type Error: this.sockets.subscribe is not a function 这是我最近遇到的问题，原本以为是自己的this指向有问题，然后从到尾查遍了整个逻辑this，发现并不是这个问题。 在打印this.sockets之后我发现问题 subscribe订阅事件并没有直接存在，而是某个对象的属性，于是尝试了一下this.sockets.listenner.subscribe发现能用了。 你以为这就结束了？？？接着我又发现问题 1234567sockets:&#123; welcome: data =&gt; &#123; console.log(&#x27;welcome data &#x27;, data) &#125;&#125; 并且订阅的事件中，socket日志显示component: undefined没有看到数据 全局的订阅事件没有生效，并且socket自带的连接事件也没有启动打印。我直接傻了😢，之前使用的时候还没有这些问题，百度一大堆无果后，开始像官方求助。于是找到了问题。 Vue-Socket.io: #connect subscribe, component: undefined 大概的意思是说，出现问题的都是3.0.9的版本，将版本后可以解决这个问题。这也是我为啥要把socket服务端写进了的原因。自己本地写了一个小demo后，还真的是版本的问题，随后就有了这篇文章。 总结 同学们在使用vue-socket.io时要注意一下版本，现在的3.0.9多多少少会出现问题，可以选择3.0.7版本。这个可以使用文章开头我的测试demo进行查看，socket服务代码也在项目中。 第一次在掘金中发表文章，表达有错误的地方还请多多谅解，之后也会发布更多前端技术文章，还请多多关注。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/tags/Vue/"},{"name":"socket.io","slug":"socket-io","permalink":"https://wakaka378.github.io/tags/socket-io/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-04-09T09:58:03.574Z","updated":"2023-04-09T12:01:37.950Z","comments":true,"path":"2023-04-09-hello-world.html","link":"","permalink":"https://wakaka378.github.io/2023-04-09-hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"js","slug":"js","permalink":"https://wakaka378.github.io/categories/js/"},{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/categories/Vue/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wakaka378.github.io/tags/js/"},{"name":"性能优化","slug":"性能优化","permalink":"https://wakaka378.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"节流防抖","slug":"节流防抖","permalink":"https://wakaka378.github.io/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"},{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/tags/Vue/"},{"name":"socket.io","slug":"socket-io","permalink":"https://wakaka378.github.io/tags/socket-io/"}]}