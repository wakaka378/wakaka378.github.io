{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://wakaka378.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-04-09T10:55:30.400Z","updated":"2023-04-09T10:55:30.400Z","comments":false,"path":"about/index.html","permalink":"https://wakaka378.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"404 Not Found：该页无法显示","date":"2023-04-09T10:55:30.353Z","updated":"2023-04-09T10:55:30.352Z","comments":false,"path":"/404.html","permalink":"https://wakaka378.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2023-04-09T10:55:30.456Z","updated":"2023-04-09T10:55:30.456Z","comments":false,"path":"categories/index.html","permalink":"https://wakaka378.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-04-09T10:55:30.548Z","updated":"2023-04-09T10:55:30.548Z","comments":false,"path":"tags/index.html","permalink":"https://wakaka378.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-04-09T10:55:30.487Z","updated":"2023-04-09T10:55:30.487Z","comments":true,"path":"links/index.html","permalink":"https://wakaka378.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-04-09T10:55:30.431Z","updated":"2023-04-09T10:55:30.431Z","comments":false,"path":"books/index.html","permalink":"https://wakaka378.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-04-09T10:54:23.884Z","updated":"2023-04-09T10:54:23.884Z","comments":false,"path":"repository/index.html","permalink":"https://wakaka378.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"还在手动发包? 试试release-it 自动发包吧📦","slug":"还在手动发包? 试试release-it 自动发包吧📦","date":"2023-06-11T10:56:36.000Z","updated":"2023-06-14T13:10:23.523Z","comments":true,"path":"post/20230611185636.html","link":"","permalink":"https://wakaka378.github.io/post/20230611185636.html","excerpt":"","text":"前言 作为一名合格的前(摸鱼)工程师，日常工作开发中或多或少都要和npm包打交道。之前工作中就有过发布npm包的经历，但那时年少无知，只知道无脑通过npm publish发包，也没有打 tag、版本、没生成 changelog的概念。直到看到源码共读中有自动发包章节，还可以自动打tag等功能，赶紧收藏学习起来。 前置准备 要在npm上发包，当然需要在npm上注册账号，这个就不再赘述。我们在注册完账号之后，先设置一下镜像源，再登录自己的npm账号。如果有同学和我一样，使用的是公司内部私有的npm服务器，使用的账号和镜像源都是公司提供的，不要弄混淆，下面我们开始具体步骤。 准备项目文件 首先创建一个文件夹，然后执行npm init -y 初始化我们的项目 设置镜像源 如果是在已有项目中接入，最好要查看一下当前项目镜像源，初始化项目可以跳过。 那为什么要设置镜像源呢？装过npm包的同学都知道，npm官方public仓库是部署在国外，使用官方镜像源装包速度很慢，所以我们有时候会将镜像源设置为https://registry.npm.taobao.org，也就是淘宝镜像。这个时候如果我们使用npm的账号是无法登录的，或者是说你把镜像设置为公司内部私有的镜像源，这个时候通过官方npm账号也是无法登录的，曾经我就在这里踩过坑。在哪注册的账号，需要将镜像源设置为注册地的仓库。这里我们使用npm官方镜像源，将镜像源设置为https://registry.npmjs.org 12345# 查看当前镜像源npm config get registry # 设置镜像源npm set registry https://registry.npmjs.org 另外一种设置镜像源方式，可以在项目根目录中新建.npmrc文件 1registry = https://registry.npmjs.org/ 登录npm 使用npm注册的账号密码登录 1234567891011# 登录npm login➜ npm loginUsername: 用户名Password: 密码Email: 注册邮箱Enter one-time password: 一次性密码 邮箱会收到邮件➜ npm whoami # 查看当前登录账号名称 自动发包 release-it 官网仓库 release-it它做了什么？ 同步提交git远端内容 更新版本号 产出changelog 提交变动 增加git tag 推送tag更新至远端 我们可以通过--dry-run可以看到具体进行了哪些操作 自动发包 安装 12345➜ npm init release-itnpx: 30 安装成功，用时 5.813 秒? Where to add the release-it config? ›❯ .release-it.json package.json or 1➜ npm install -D release-it 添加命令 123&quot;scripts&quot;: &#123; &quot;release&quot;: &quot;release-it&quot; &#125;, 配置 在项目根目录创建文件 .release-it.json .release-it.js .release-it.yaml .release-it.toml 或者是在pakcage.json文件中添加release-it属性，这里我就直接创建.release-it.json文件，添加以下配置或者可以查看 更多配置 123456789101112131415&#123; &quot;github&quot;: &#123; &quot;release&quot;: true &#125;, &quot;git&quot;: &#123; &quot;commitMessage&quot;: &quot;release: v$&#123;version&#125;&quot; &#125;, &quot;npm&quot;: &#123; &quot;publish&quot;: true &#125;, &quot;hooks&quot;: &#123; &quot;after:bump&quot;: &quot;echo 更新版本成功&quot; &#125;,&#125; 生成CHANGELOG 安装插件 1➜ npm i @release-it/conventional-changelog -D 然后将以下内容添加到.release-it.json文件中 12345678&#123; &quot;plugins&quot;: &#123; &quot;@release-it/conventional-changelog&quot;: &#123; &quot;preset&quot;: &quot;angular&quot;, &quot;infile&quot;: &quot;CHANGELOG.md&quot; &#125; &#125; 自动发布 运行命令，就可以进行发布 123➜ npm run release# or➜ npx release-it 将release-it参数放在--后面 1npm run release --minor --ci 发布其他版本 npm版本号 这里先初步补充一下npm版本号相关知识，npm的版本号遵循SemVer 规范，版本号格式必须采用X.Y.Z的格式，其中 X、Y 和 Z 为非负的整数。X 是主版本号、Y 是次版本号、而 Z 为修订号，英文对应表示为 major、minor、patch，每个号必须采用递增。 12X.Y.Z ===&gt; &#123;major&#125;.&#123;minor&#125;.&#123;patch&#125;2.4.1 这种格式都是正式版，而在正式版发布之前还会经历各种先行版本，先行版本号会在原有的基础上增加一个版本号标签，先行版本格式是在修订版本patch号后面加上一个-连接，再通过.进行分割 12# 格式major.minor.patch-&#123;identifier&#125;.&#123;identifier&#125;.&#123;identifier&#125; 通常第一个 identifier 为版本号标签，后面则是自增版本号。 常用的版本号标签有 alpha内部测试版 beta公开测试版 rc候选版本 发布先行版本 理解完npm版本号相关知识后，那如何发布alpha、beta、rc版本呢？ 我们可以看一下pre-releases ，就是通过不同的命令去创建发布不同的版本，比如我现在需要发布beta版本，就可以执行一下命令。 12345678➜ npx release-it major --preRelease=beta# 实际执行了三步# 1.版本号从 0.2.0 更新至 1.0.0-beta.0# 2.npm发布版本会打上beta标签，可以通过 npm i xxxx@beta 安装# 3.github release会打上pre-release标识# 综合起来就是release-it premajor --preReleaseId=beta --npm.tag=beta --github.preRelease beta可以换成&quot;alpha&quot;, &quot;beta&quot;, &quot;rc&quot; major可以替换成major、minor、patch 预发布版本在更改的过程中，原有的先行版本号会清零。比如我从1.2.1-alpha.4升级到beta版本，就会变成1.2.1-beta.0 升级版本时，会将预发布版本清空，此时版本号不会变动。比如我上一个版本是3.0.0-rc.2，当我直接升级patch号就会变成3.0.0 升级当前预发布版本 1➜ npx release-it --preRelease 将alpha版本修改为beta版本 1➜ npx release-it --preRelease=beta 升级major、minor、patch版本号 1➜ npx release-it major/minor/patch 当我们发布完后，需要使用到预发布版本依赖事，安装包的时候包名后面要带上@beta或者是其他版本 1npm install release-it-test-wakaka@beta -D 我们也可以将命令拆分开来使用 12345678# 只响应package.json中的版本号$ npx release-it major --preReleaseId=beta# 设置npm发版时的标识为beta$ npx release-it major --npm.tag=beta# 设置github release为预发布$ npx release-it major --github.preRelease 查看包 我们发布完之后，如何查看自己是否发布成功呢？有以下几种方式 npm官网查看 可以在npm官网上直接搜索包的名字，或者是登录账号后在packages中查看自己发布的包 在versions中可以看到历史的版本 使用npm view命令 123456789101112131415# 查看某个 package 的注册信息npm view &lt;package-name&gt;# 查看某个 package 的最新版本npm view &lt;package-name&gt; version# 查看某个 package 在 npm 服务器上所发布过的版本npm view &lt;package-name&gt; versions# 查看仓库依赖树上所有包的版本信息npm ls 直接安装 简单粗暴，直接通过npm install &lt;package-name&gt;安装一下包，如果发布成功，安装时最好另起项目，不要在当前包项目中安装。 踩坑 包名重复 发包前，最好确认一下包名有没有重复，如果包名重复是无法发布的。校验包名最简单的办法就是去npm官网上搜你需要发布的名字，如果有就需要换一个名字，没有就可以发布。 错误的包名，无法发布 修改后，发布成功 没有git仓库提交代码 在安装完@release-it/conventional-changelog后，如果没有在git远程仓库提交代码，也是会发布失败 添加远程仓库后 当我们改完代码后，需要进行提交。 123git add .git commit -m &#x27;xxxxx&#x27;git push changelog文件没有commit信息 为什么我提交了commit，但是生成的changelog中没有commit信息？ 这是因为提交的commit信息不符合angular规范，在.release-it.json文件中我们可以看到 12345678... &quot;plugins&quot;: &#123; &quot;@release-it/conventional-changelog&quot;: &#123; &quot;preset&quot;: &quot;angular&quot;, &quot;infile&quot;: &quot;CHANGELOG.md&quot; &#125; &#125;... 只要提交的规范符合angular规范，就可以了。 约定式提交 Angular提交信息规范 @release-it/conventional-changelog 总结 release-it使用下来，发现它帮我们节省了很多时间，整体发包流程都很规范。之前工作中进行发包的时候，直接一个npm publish就完事，也没有考虑到打tag、生成changelog这些事情。还有更多扩展性功能等待发现，比如配合上commitizen等工具，自定义commit信息，让changelog内容更丰富。配合git hooks，执行其他的一些操作。 同类型的产品还有standard-version，也是提供自动化发包流程，但整体来说还是release-it更灵活一些。 参考文章 package.json 配置完全解读 图文结合简单易学的npm 包的发布流程 聊聊 npm 的语义化版本（Semver） 自动产出changelog-第二节：自动产出","categories":[{"name":"Git","slug":"Git","permalink":"https://wakaka378.github.io/categories/Git/"},{"name":"工程化","slug":"Git/工程化","permalink":"https://wakaka378.github.io/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"npm","slug":"Git/工程化/npm","permalink":"https://wakaka378.github.io/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/npm/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://wakaka378.github.io/tags/npm/"},{"name":"工程化","slug":"工程化","permalink":"https://wakaka378.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"记一次vue@cli创建项目prettier失效","slug":"记一次vue-cli创建项目prettier失效","date":"2023-05-31T13:41:00.000Z","updated":"2023-06-14T13:32:57.252Z","comments":true,"path":"post/20230531214100.html","link":"","permalink":"https://wakaka378.github.io/post/20230531214100.html","excerpt":"","text":"最近在学vue3，使用vue@cli创建项目的时候突然发现prettier失效。各种上网查资料，修改vscode配置操作都不行。后来开两个项目，一个使用vue@cli一个手动创建，发现使用vue@cli创建的项目就是存在失效的问题，排查了很久才发现是官方配置问题，可以查看我提的issues vue@cli创建项目 Vue3支持用vue@cli创建项目，但前提是vue@cli版本要在5.x以上，4.x的版本升级一下就可以。 创建项目 1npm init vue@last 这一指令将会安装并执行 create-vue，它是 Vue 官方的项目脚手架工具。你将会看到一些诸如 TypeScript 和测试支持之类的可选功能提示： 123456789✔ Project name: … &lt;your-project-name&gt; // 项目名称✔ Add TypeScript? … No / Yes // 添加ts✔ Add JSX Support? … No / Yes // 添加jsx支持✔ Add Vue Router for Single Page Application development? … No / Yes // 添加 router✔ Add Pinia for state management? … No / Yes // 添加 Pinia✔ Add Vitest for Unit testing? … No / Yes // 添加 vitest✔ Add an End-to-End Testing Solution? … No / Cypress / Playwright // 添加端到端测试✔ Add ESLint for code quality? … No / Yes // 添加Eslit✔ Add Prettier for code formatting? … No / Yes // 添加Prettier 按照自己的需求选择完之后 123cd vue-project2npm installnpm run dev 我当时是选择了eslint和prettier配置，最后会生成对应的配置文件，这里就只关心一下.eslintrc.cjs文件 123456789101112131415/* eslint-env node */require(&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;)module.exports = &#123; root: true, extends: [ &#x27;plugin:vue/vue3-essential&#x27;, &#x27;eslint:recommended&#x27;, &#x27;@vue/eslint-config-typescript&#x27;, &#x27;@vue/eslint-config-prettier/skip-formatting&#x27; ], parserOptions: &#123; ecmaVersion: &#x27;latest&#x27; &#125;&#125; 问题 由于是vue3项目，我直接把vetur插件禁用掉，使用volar插件 对应的eslint、prettier插件都有安装，VsCode自动保存修复也打开。 1234&quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll&quot;: true, &quot;source.fixAll.eslint&quot;: true&#125; 然后修改一下代码，测试一下prettier功能。 12345678910111213141516171819202122232425262728293031&lt;script setup lang=&quot;ts&quot;&gt;import &#123; RouterLink, RouterView &#125; from &#x27;vue-router&#x27;import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;;&lt;/script&gt;&lt;template&gt; &lt;header&gt; &lt;img alt=&quot;Vue logo&quot; class=&quot;logo&quot; src=&quot;@/assets/logo.svg&quot; width=&quot;125&quot; height=&quot;125&quot; /&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;HelloWorld msg=&quot;You did it!&quot; /&gt; &lt;nav&gt; &lt;RouterLink to=&quot;/&quot;&gt;Home&lt;/RouterLink&gt; &lt;RouterLink to=&quot;/about&quot;&gt;About&lt;/RouterLink&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/header&gt; &lt;RouterView /&gt;&lt;/template&gt; 很容易发现代码会有几个错误在里面，相同的代码我放在一个prettier功能完好的项目里面就发现错误。 排查 为什么会这样，我修改了vue@cli创建项目的好多配置，主要排查对象放在eslint、vscode编辑器上，甚至重新安装相关依赖，不使用脚手架提供的，还是没有发现问题。 吃完饭后无意中发现eslint的一个配置后面加了skip-formatting，为啥要跳过配置？然后把这个选项移除，惊奇的发现可以用了。 123456789101112131415161718/* eslint-env node */require(&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;)module.exports = &#123; root: true, &#x27;extends&#x27;: [ &#x27;plugin:vue/vue3-essential&#x27;, &#x27;eslint:recommended&#x27;, &#x27;@vue/eslint-config-typescript&#x27;,- &#x27;@vue/eslint-config-prettier/skip-formatting&#x27;+ &#x27;@vue/eslint-config-prettier&#x27; ], parserOptions: &#123; ecmaVersion: &#x27;latest&#x27; &#125;,&#125; 然后查看这个包文件，skip-formatting到底是什么意思？它在node_modules/@vue/eslint-config-prettier/skip-formatting.js 1234567module.exports = &#123; extends: [require.resolve(&quot;./index.js&quot;)], rules: &#123; &quot;prettier/prettier&quot;: &quot;off&quot;, &#125;,&#125;; 有一个很关键的代码&quot;prettier/prettier&quot;: &quot;off&quot;,它把prettier关闭了，为什么要关闭这个配置呢，百思不得其解，然后去查阅Vue仓库下的create-vue相关代码，发现官方用的是另外一个eslint配置仓库create-eslint-config 1234567891011121314151617181920import * as fs from &#x27;node:fs&#x27;import * as path from &#x27;node:path&#x27;import type &#123; Linter &#125; from &#x27;eslint&#x27;import createESLintConfig from &#x27;@vue/create-eslint-config&#x27; // create-eslint-config项目... const &#123; pkg, files &#125; = createESLintConfig(&#123; vueVersion: &#x27;3.x&#x27;, // we currently don&#x27;t support other style guides styleGuide: &#x27;default&#x27;, hasTypeScript: needsTypeScript, needsPrettier, // needsPrettier参数从脚手架配置命令行参数里面获取 additionalConfig, additionalDependencies &#125;) ... 查看一下create-eslint-config项目里面的相关代码 1234567891011121314151617181920212223242526272829303132// This is also used in `create-vue`export default function createConfig (&#123; vueVersion = &#x27;3.x&#x27;, // &#x27;2.x&#x27; | &#x27;3.x&#x27; (TODO: 2.7 / vue-demi) styleGuide = &#x27;default&#x27;, // default | airbnb | typescript hasTypeScript = false, // js | ts needsPrettier = false, // true | false additionalConfig = &#123;&#125;, // e.g. Cypress, createAliasSetting for Airbnb, etc. additionalDependencies = &#123;&#125; // e.g. eslint-plugin-cypress&#125;) &#123; // This is the pkg object to extend const pkg = &#123; devDependencies: &#123;&#125; &#125; const addDependency = (name) =&gt; &#123; pkg.devDependencies[name] = versionMap[name] &#125; deepMerge(pkg.devDependencies, additionalDependencies) deepMerge(eslintConfig, additionalConfig) if (needsPrettier) &#123; addDependency(&#x27;prettier&#x27;) addDependency(&#x27;@vue/eslint-config-prettier&#x27;) eslintConfig.extends.push(&#x27;@vue/eslint-config-prettier/skip-formatting&#x27;) // 这里往eslint的extend属性里面添加了配置 &#125; const files = &#123; &#x27;.eslintrc.cjs&#x27;: &#x27;&#x27; &#125;... 就是这行eslintConfig.extends.push('@vue/eslint-config-prettier/skip-formatting') 它添加的是配置里面对应的skip-formatting配置，也就是关掉prettier那个。 在这个commit里面，作者重构了这个配置，目的是为了使用prettier时，不使用eslint格式化。 但我们日常开发中，通常都是prettier和eslint都是一起使用的，如果要想单独使用某一个的话，skip-formatting参数应该是根据用户是否在prettier和eslint二选一的时候决定，也不知道这样做是为了什么。 解决 最后的解决办法就很简单 不使用skip-formatting这个配置文件 123456789101112131415161718/* eslint-env node */require(&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;)module.exports = &#123; root: true, &#x27;extends&#x27;: [ &#x27;plugin:vue/vue3-essential&#x27;, &#x27;eslint:recommended&#x27;, &#x27;@vue/eslint-config-typescript&#x27;,- &#x27;@vue/eslint-config-prettier/skip-formatting&#x27;+ &#x27;@vue/eslint-config-prettier&#x27; ], parserOptions: &#123; ecmaVersion: &#x27;latest&#x27; &#125;,&#125; 这个文件不是吧prettier给关掉了吗，我们打开就行。 12345678910111213141516171819/* eslint-env node */require(&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;)module.exports = &#123; root: true, extends: [ &#x27;plugin:vue/vue3-essential&#x27;, &#x27;eslint:recommended&#x27;, &#x27;@vue/eslint-config-typescript&#x27;, &#x27;@vue/eslint-config-prettier/skip-formatting&#x27; ], parserOptions: &#123; ecmaVersion: &#x27;latest&#x27; &#125;,+ rules: &#123;+ &#x27;prettier/prettier&#x27;: &#x27;error&#x27;+ &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/categories/Vue/"},{"name":"工程化，prettier","slug":"Vue/工程化，prettier","permalink":"https://wakaka378.github.io/categories/Vue/%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%8Cprettier/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://wakaka378.github.io/tags/Vue3/"},{"name":"vue@cli","slug":"vue-cli","permalink":"https://wakaka378.github.io/tags/vue-cli/"},{"name":"prettier","slug":"prettier","permalink":"https://wakaka378.github.io/tags/prettier/"}]},{"title":"防抖debounce理解","slug":"防抖debounce理解","date":"2023-04-09T13:54:09.000Z","updated":"2023-06-14T13:26:12.536Z","comments":true,"path":"post/20230409215409.html","link":"","permalink":"https://wakaka378.github.io/post/20230409215409.html","excerpt":"","text":"「我正在参与掘金会员专属活动-源码共读第一期，点击参与」 前言 防抖相信大家都不陌生，面试中会经常会被问题或提起。比如会问一些前端优化、手写防抖节流函数等等，这里就跟着underscore 源码来学习一下。 定义 在规定时间后才执行，如果触发则重新计时 也就是说，防抖函数在n秒内，无论触发了多少次函数回调，我都只只在n秒后执行一次。比如我们设置一个等待时间为5秒的防抖函数，如果5秒内有触发，就需要重新计时，直到5秒内没有触发就调用执行。 使用场景 最近项目中有一个表单搜索场景，在输入文字的过程中会持续触发oninput事件，而搜索接口只是在用户输入搜索文字后进行调用。如果是用户输入一个文字就搜索一次，不仅会频繁调用后台接口，前端显示效果也不好。 使用防抖的话，可以将接口调用设定在500ms内没有触发oninput事件后再调用接口，这样就可以解决问题。 还会在其他场景使用 一些频繁点击操作的按钮，比如登录、短信验证，避免用户短时间多次发送 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖 鼠标移动mousedown计算等场景 实现原理 实现原理其实很简单，就是利用定时器，函数在最开始执行的时候就设定一个定时器，如果在n秒内有执行就吧定时器清空，重新设定一个新的定时器，当n秒内没有再调用后，定时器计时结束后就会触发回调。 第一版 123456789101112131415161718192021/*** debounce防抖* @param &#123; function &#125; fn 回调* @param &#123; number &#125; wait 等待时间*/function debounce(fn, wait = 300) &#123; // 利用闭包生成唯一的一个定时器 let timer = null; // 返回一个函数，当作触发事件执行 return function (...args) &#123; if (timer) &#123; // 上一次存在定时器，需要清空 clearTimeout(timer); &#125; // 设定定时器，定时器结束后执行回调函数 fn 如果多次触发就重新设定 timer = setTimeout(() =&gt; &#123; fn.apply(this, args); &#125;, wait); &#125;;&#125; 我们再写一个输入框事件来测试一下 123456789101112131415161718&lt;input type=&quot;text&quot; oninput=&quot;oninputHandler(event)&quot; /&gt;&lt;script&gt; const testFn = debounce((event) =&gt; &#123; console.log(&#x27;执行防抖&#x27;, event.target.value); &#125;, 1000); // 执行防抖 停止 scroll 事件后 1 秒执行回调 function oninputHandler(event) &#123; testFn(event); &#125; // 不执行防抖 function oninputHandler(event) &#123; console.log(&#x27;input change value: &#x27; + event.target.value); &#125;&lt;/script&gt; 这是没有执行防抖 开启防抖后 效果还是很明显的，从原来的输入一个值就触发，到现在1秒内没有输入才触发，至此，简单版防抖就已经实现了。 第二版 接下来再来对防抖做一下改造，在首次调用的时候立即执行函数，等到n秒内没有触发，才可以重新触发执行。 听起来有点绕，也就是说在oninput事件第一次触发的时候就执行，后续的触发都不执行。等到1秒内没有执行后，再触发oninput时又会执行第一次。 1234567891011121314151617181920212223242526272829303132333435363738/*** debounce防抖* @param &#123; function &#125; fn 回调* @param &#123; number &#125; wait 等待时间* @param &#123; boolean &#125; immediate 是否立即执行*/function debounce(fn, wait = 300, immediate = false) &#123; // 利用闭包生成唯一的一个定时器 let timer = null; // 返回一个函数，当作触发事件执行 return function (...args) &#123; if (timer) &#123; // 上一次存在定时器，需要清空 clearTimeout(timer); &#125; // immediate: true 时，首次触发后立即执行 if (immediate) &#123; // 是否首次执行过 const isExecute = !timer; // 赋值定时器 避免重复执行 timer = setTimeout(() =&gt; &#123; timer = null; &#125;, wait); // 首次执行 isExecute &amp;&amp; fn.apply(this, args); &#125; else &#123; // 设定定时器，定时器结束后执行回调函数 fn 如果多次触发就重新设定 timer = setTimeout(() =&gt; &#123; fn.apply(this, args); &#125;, wait); &#125; &#125;;&#125; underscore 源码 来看一下underscore里是如何实现的，先将核心代码复制出来，用上面的oninput事件来调试，看一下它的一个具体步骤。 在debounced方法内部打上一个断点，然后在输入框输入数据触发防抖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function debounce(func, wait, immediate) &#123; var timeout, previous, args, result, context; var later = function () &#123; // now获取的是当前时间 previous 会在第一次进入的时候记录 对比两个时间差是否小于 wait 等待时间 var passed = now() - previous; if (wait &gt; passed) &#123; // 小于等待时间 说明在 wait时间内有触发 重新设定定时器 timeout = setTimeout(later, wait - passed); &#125; else &#123; // 超过等待时间 执行回调 // 清空 timeout 避免影响到下次使用 timeout = null; // 判断是否立即执行 if (!immediate) result = func.apply(context, args); // This check is needed because `func` can recursively invoke `debounced`. // 清空上下文、arguments 参数 在回调里面嵌套使用 if (!timeout) args = context = null; &#125; &#125;; // 先执行这里 通过 restArguments 将处理结果当作函数进行返回 回调时传递 arguments 参数 var debounced = restArguments(function (_args) &#123; context = this; args = _args; // 触发一次记录时间 用来和等待时间对比 previous = now(); if (!timeout) &#123; // 第一次进入时执行 // 执行 later 函数 timeout = setTimeout(later, wait); // 立即执行 if (immediate) result = func.apply(context, args); &#125; return result; &#125;); // 取消执行 清空定时器等参数 debounced.cancel = function () &#123; clearTimeout(timeout); timeout = args = context = null; &#125;; return debounced;&#125; 源码还是有很多亮点的 增加了cancel方法，可以随时取消。 在执行回调的时候，吧函数结果当作返回值return出去，是为了避免回调中有返回数据。 通过记录每次执行时间差，来判断是否需要执行回调。","categories":[{"name":"Js","slug":"Js","permalink":"https://wakaka378.github.io/categories/Js/"}],"tags":[{"name":"Js","slug":"Js","permalink":"https://wakaka378.github.io/tags/Js/"},{"name":"性能优化","slug":"性能优化","permalink":"https://wakaka378.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"节流防抖","slug":"节流防抖","permalink":"https://wakaka378.github.io/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"}]},{"title":"维护代码的尊严：GPG签名让你的Git commit不再害羞","slug":"维护代码的尊严：GPG签名让你的Git-commit不再害羞","date":"2023-04-08T13:41:19.000Z","updated":"2023-06-21T13:42:08.423Z","comments":true,"path":"post/20230408214119.html","link":"","permalink":"https://wakaka378.github.io/post/20230408214119.html","excerpt":"","text":"= this.file.tags 引言 GPG（GNU Privacy Guard）是一个强大的开源加密软件，它采用公钥加密和数字签名技术来保护数据的机密性和完整性。通过在Git提交中添加GPG签名，开发者可以确保提交的真实性，验证提交的作者身份，并提高代码的可信度。 作为一种公钥加密系统，GPG使用非对称密钥加密算法。每个用户拥有一对密钥：公钥和私钥。公钥用于加密数据和验证签名，而私钥用于解密数据和生成签名。 什么是签名？ 签名是指使用私钥对数据进行加密，以证明数据的真实性和完整性的过程。在加密中，签名用于验证数据的来源和防止数据被篡改。 签名的过程如下： 数据生成：首先，使用哈希函数对要签名的数据进行处理，生成一个固定长度的哈希值。哈希函数是一种将任意长度的数据转换为固定长度输出的算法。 私钥加密：使用发送者的私钥对哈希值进行加密。这个加密操作产生一个数字签名，只有拥有相应私钥的发送者才能生成这个签名。 签名附加：数字签名与原始数据一起附加在一起，形成签名文件或签名数据包。 验证签名：接收者使用发送者的公钥来解密签名，从而得到原始的哈希值。 哈希比对：接收者使用相同的哈希函数对原始数据进行处理，生成一个哈希值。 比对校验：接收者将接收到的哈希值与使用公钥解密得到的哈希值进行比对。如果两个哈希值匹配，则验证成功，表明数据未被篡改并且确实来自于拥有对应私钥的发送者。 通过数字签名，接收者可以验证数据的完整性和真实性，确保数据在传输过程中没有被篡改或冒充。数字签名在保护数据的完整性、防止篡改和验证身份方面发挥着重要作用。 为什么要给Commit 签名？ 给Commit签名的主要目的是确保提交的代码在传输和存储过程中没有被篡改，并验证提交者的身份。通过为每个Commit添加数字签名，可以验证提交者的身份并确保代码的可追溯性。 是用GPG通过给Commit提交签名验证，可以在本地对标记和提交进行签名。 这些标记或提交在 GitHub 上标示为已验证，便于其他人信任更改来自可信的来源。如果提交或标记具有可加密验证的 GPG、SSH、 或 S/MIME 签名，GitHub 会将提交或标记标示为“已验证”或“部分验证”。 签名流程 非对称加密 GPG使用非对称密钥加密算法，非对称加密是一种加密技术，使用不同的密钥对（公钥和私钥）来进行加密和解密操作。它也被称为公钥加密。 在非对称加密中，公钥是公开的，可以与他人分享，而私钥则保密保存在加密者的控制下。公钥用于加密数据，而私钥用于解密数据。因为公钥和私钥是一对密钥，它们彼此之间是相关的，但是无法通过公钥推导出私钥。 加密： 发送方使用接收方的公钥对要传输的数据进行加密。只有拥有与公钥对应的私钥的接收方才能解密该数据。 解密： 接收方使用自己的私钥对加密的数据进行解密，以获得原始数据。私钥是私有的，只有接收方能够访问它。 步骤 基于非对称加密，使用公钥加密和数字签名技术对Commit进行签名，签名Commit的过程涉及使用GPG的密钥对进行数字签名和验证。 生成密钥对：首先，使用GPG生成密钥对，包括公钥和私钥。私钥将被用于对Commit进行签名，而公钥将被用于验证签名。 配置Git：将生成的GPG公钥添加到Git的配置中，使其能够与GPG集成并使用对应的私钥进行签名。 签名Commit：在进行Commit操作时，使用Git命令行或相关的Git客户端，可以使用GPG的私钥对Commit进行签名。这将生成一个数字签名，将其与Commit一起提交到代码库。 验证签名：其他人在获取Commit时，可以使用对应的GPG公钥来验证签名的真实性。通过验证签名，可以确定Commit是由私钥的持有者生成的，确保数据的完整性和来源可信。 在签名Commit时，GPG使用了非对称密钥加密算法。私钥用于对Commit进行数字签名，而公钥用于验证签名。这种非对称加密的方法确保了签名的安全性和可靠性。 安装GPG 使用 [[我的mac折腾之路#Homwbrew|Homebrew]] 安装 12345# 安装brew install gnupg# 解压brew cleanup gnupg 生成 GPG 密钥 生成一个新的密钥，命令如下： 1gpg --full-generate-key 它会弹出一系列问题让你输入，如实写入就好啦。 ![[pic/Pasted image 20230408193528.png]] 这是我选择的配置 具体情况看个人情况 然后输入密码就行 这个邮箱最好和Git邮箱一样 github 支持的密钥算法 RSA ElGamal DSA ECDH ECDSA EdDSA 查看私钥信息 123456789101112➜ gpg --list-secret-keys --keyid-format LONGgpg: 正在检查信任度数据库gpg: marginals needed: 3 completes needed: 1 trust model: pgpgpg: 深度：0 有效性： 1 已签名： 0 信任度：0-，0q，0n，0m，0f，1ugpg: 下次信任度数据库检查将于 2024-04-07 进行/Users/xxx/.gnupg/pubring.kbx --------------------------------sec rsa4096/D5BB89D6E7B84C0B 2023-04-08 [SC] [有效至：2024-04-07] # 公钥特征 rsa算法生成的 4096位 / 公钥id 生成时间 716E599E76566F7C329BF7E7D5BB89D6E7B84C0Buid [ 绝对 ] wakaka378 &lt;gebilaofl@163.com&gt;ssb rsa4096/EEC764C6A850B8F3 2023-04-08 [E] [有效至：2024-04-07] 主要信息如下 sec：表示这是一个私钥。 rsa4096：表示使用RSA算法，密钥长度为 4096 位。 D5BB89D6E7B84C0B：表示密钥的 ID，也就是公钥 ID 的后 8 位。 2023-04-08：表示密钥的创建日期。 [SC]：表示这个密钥既可以用来签名（S），也可以用来加密通信（C）。 716E599E76566F7C329BF7E7D5BB89D6E7B84C0B：是密钥的完整 ID，与前面的 ID 相同，只不过多了前缀。 uid：表示这是一个用户 ID。后面包含该密钥的用户名 邮箱 ssb：表示这是一个子密钥，用于加密通信。 EEC764C6A850B8F3：表示子密钥的 ID，与主密钥 ID 相同。 2023-04-08：表示子密钥的创建日期。 [E]：表示这个子密钥只能用于加密通信。 github部署公钥 到这一步， 如果我们直接将提交推送到GitHub上，提交上将会出现一个Unverified的标签， 这是因为， 虽然我们给提交签名了， 但是， GitHub还是不知道这个签名到底来自于谁。接下来，我们就要告诉GitHub： 我们这个用户所对于的公钥是哪个。 查看公钥id 1gpg --list-keys 导出我们的公钥 将最后面的换成自己的公钥 1gpg --armor --export 716E599E76566F7C329BF7E7D5BB89D6E7B84C0B 复制以-----BEGIN PGP PUBLIC KEY BLOCK-----开头并以 -----END PGP PUBLIC KEY BLOCK----- 结尾的 GPG 密钥。然后打开github ---&gt;settings ---&gt; SSH and GPG kleys 在 GPG keys栏中添加一个新的GPG key 将内容复制进去，然后输入密码。 ![[pic/Pasted image 20230408200426.png]] 配置git 在git中启用签名功能，如果不配置 需要每次Commit后面加-S 1git config --global commit.gpgsign true 用gpg --list-secret-keys --keyid-format=long 查看一下私钥ID，执行下面命令，将D5BB89D6E7B84C0B换成自己的 1git config --global user.signingkey D5BB89D6E7B84C0B 我这里是全局生效 如果只想在某个项目里 就去掉--global 将 GPG 密钥添加到 .zshrc 文件 12if [ -r ~/.zshrc ]; then echo &#x27;export GPG_TTY=$(tty)&#x27; &gt;&gt; ~/.zshrc; \\ else echo &#x27;export GPG_TTY=$(tty)&#x27; &gt;&gt; ~/.zprofile; fi 测试一下 在Commit后 会让你输入密码 ![[pic/Pasted image 20230408201708.png]] 提交成功后push，使用git log --show-signature查看一下本地签名信息 ![[pic/Pasted image 20230408201831.png]] 在github上看一下这个commit ![[pic/Pasted image 20230408202019.png]] 对Tag签名 若要对标记进行签名，请将 -s 添加到 git tag 命令。 12$ git tag -s MYTAG# Creates a signed tag 通过运行` git tag -v [tag-name]`` 验证已签名的标记。 12$ git tag -v MYTAG# Verifies the signed tag 缓存密码 当我们配置完上面的一切以后。 提交的时候， gpg 总会弹出一个密码询问框， 让你输入你创建密钥对时使用的密码， 去解开加密保存的私钥， 从而使用私钥去签名。 修改密码缓存的时间，默认设置的缓存有效时间为600秒，最大支持604800秒。 8小时：28800‬ ， 12小时：43200‬ ， 24小时 ：86400 7天：604800 123456789101112➜ vim ~/.gnupg/gpg-agent.conf# copy and savedefault-cache-ttl 604800max-cache-ttl 604800default-cache-ttl-ssh 604800max-cache-ttl-ssh 604800allow-loopback-pinentry# reset➜ gpgconf kill gpg-agent &amp;&amp; gpgconf --launch gpg-agent 注意 较长的密码缓存时间提供了更多的方便性，因为你不需要在每次 GPG 操作时都输入密码。但这也增加了安全风险，因为其他人在该时间段内可以执行 GPG 操作而无需输入密码。因此，在设置密码缓存时间时，需要综合考虑安全性和方便性，并根据自己的需求进行选择。 常用命令 gpg --full-generate-key： 生成密钥对 gpg --list-secret-keys --keyid-format LONG： 查看私钥信息 gpg --list-keys：查看公钥 gpg --delete-secret-key &lt;key ID&gt;： 删除私钥 gpg --delete-key &lt;key ID&gt;： 删除公钥 gpg --armor --export &lt;email or key-id&gt; &gt; public_key.asc ：导出公钥 gpg --armor --export-secret-keys &lt;email or key-id&gt; &gt; private_key.asc ： 导出私钥 gpg -e -r &lt;recipient email or key-id&gt; &lt;file name&gt;： 加密文件 gpg -d &lt;file name&gt;.gpg ：解密文件","categories":[{"name":"Git","slug":"Git","permalink":"https://wakaka378.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://wakaka378.github.io/tags/Git/"}]},{"title":"JavaScript数据结构之——队列","slug":"JavaScript数据结构之——队列","date":"2022-12-05T13:02:58.000Z","updated":"2023-06-14T13:07:37.856Z","comments":true,"path":"post/20221205210258.html","link":"","permalink":"https://wakaka378.github.io/post/20221205210258.html","excerpt":"","text":"前言 队列相信大家都不陌生，它是属于数据结构等一种，不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计出来的。而对于我们前端技术人员来说，理解数据结构都非常重要。在我们解决一些问题的时候，使用不同的数据结构会带来不同性能，因此数据结构是这些问题的解决方案中不可或缺的一部分。 使用场景 之前在做IM相关产品的时候，会经常用到队列，比如说之前有遇到一个场景，进入到多人聊天室时会将未读消息批量加载，然后通过消息获取到对应信息后，为了保证消息顺序的正确，需要一条一条按序存入IndexDB中。这里就会使用到队列，最先存进来的获取数据的消息会被最先放入到IndexDb当中。 还有一个场景大家肯定不陌生，那就是事件循环Event Loop。先将执行栈中的宏任务和微任务分别放入队列中，再从队列中取出来依次执行。 定义 队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。跟它相反的是栈，遵循先入后出(LIFO，last-in-first-out) 的原则。 举个简单例子，我们做核酸排队，其实就是一个简单的队列。最先来的人最先捅嗓子眼，后面来的人需要在我后面排队，等我捅完之后再捅。我简单的画了张图，理解一下相关的定义。 简单版 利用数组的shift、push方法，实现一个简单版的队列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Queue &#123; constructor() &#123; this.queueList = [] &#125; /** * 入队 * @param &#123;*&#125; el */ dequeue(el) &#123; this.queueList.push(el) &#125; /** * 出队 * @returns */ enqueue() &#123; return this.queueList.shift() &#125; /** * 获取队列长度 * @returns 队列长队 */ size() &#123; return this.queueList.length &#125; /** * 清空队列 */ clear() &#123; this.queueList = [] &#125; /** * 判断队列是否为空 * @returns 是否为空 */ isEmpty() &#123; return this.queueList.length === 0 &#125;&#125;const queue = new Queue()queue.dequeue(1)queue.dequeue(2)queue.dequeue(false)console.log(queue.enqueue(), queue.isEmpty()) // 1 false 链式队列 理解 链式队列相对于上一版就要复杂些，它的结构就像一个链条一样，一环扣一环。在队列中，每一个元素通过next指向下一个元素，下一个元素又会有next指向它后面的，这样各元素就通过next连接起来，形成一条链子。 同时还会有两个指针，一个指针指向队头元素，另外一个指针指向队尾元素。当元素位置发生变动时，这两个指针也会随之改变。这里我们用head表示队头，tail表示队尾，next为当前元素的下一个元素，看一下整个流程。 执行enqueue入队操作，此时A4的next指向空，tail指向A[3]。当A5执行enqueue入队操作时，A4的next就会指向A5, 同时tail也会指向，A5的next就会为null 执行dequeue出队操作，首先A0的next不会指向A1，因为A0已经出去了，不在当前队列中。然后head会指向A1，成为新的队头。 Node节点 理解完上面一张图，我们来先来实现一下enqueue入队操作。在入队前，我们需要先定义一个Node节点，用来表示每一个元素。 123456class Node &#123; constructor(element) &#123; this.element = element this.next = null &#125;&#125; 这个代码很简单，就是实现一个Node节点的时候，将元素放入element，同时给它添加一个next属性，用来指向下一个节点。 创建队列 接下来创建队列，先声明一下类，定义属性。 12345678910class MyQueue &#123; constructor() &#123; // 当前队列长度 this.size = 0 // 头部指针 this.head = null // 尾部指针 this.tail = null &#125;&#125; enqueue 然后按照上面的思路，实现一下enqueue操作，需要进行以下几个操作。 创建节点Node 添加元素 如果当前队列为空，添加到head 如果当前队列不为空，添加到tail 修改tail指向 修改长度 12345678910111213141516171819202122232425262728/** * 入队 * @param &#123;*&#125; value 入队属性 * @returns */enqueue(value) &#123; if (!value) return false // 创建节点 const node = new Node(value) // 判断队列是否为空 if (this.isEmpty()) &#123; // 这里先不看 isEmpty 方法 // 队列为空 将节点元素添加到头部 this.head = node &#125; else &#123; // 队列不为空 将队尾的 next 指向新元素 const currentNode = this.tail // 做一下缓存 避免影响到后面 currentNode.next = node &#125; // 设置新的队尾 this.tail = node // 修改长度 this.size++ console.log(&#x27;enqueue element&#x27;, value)&#125; 测试代码 1234const testQueue = new MyQueue();testQueue.enqueue(&#x27;vue&#x27;) // enqueue element vuetestQueue.enqueue(&#x27;react&#x27;) // enqueue element reacttestQueue.enqueue(&#x27;angular&#x27;) // enqueue element angular dequeue 接下来是出队，主要是以下几个步骤。 判断是否为空 队列为不为空，获取头部head元素返回。 队列为空，不执行。 修改队列长度 将头部指针指向next中的元素 清空队尾tail 返回队头head元素 1234567891011121314151617181920212223/** * 出队 最先进入的最先出去 * @returns */dequeue()&#123; // 判断是否为空 if (this.isEmpty()) &#123; return &#125; const currentHead = this.head // 缓存head // 将头部指针指向下一个元素 this.head = currentHead.next // 修改长度 this.size-- // 清空尾部 this.tail = null return currentHead.element&#125; 测试代码 12345678const testQueue = new MyQueue();testQueue.enqueue(&#x27;vue&#x27;) // enqueue element vuetestQueue.enqueue(&#x27;react&#x27;) // enqueue element reactconsole.log(testQueue.dequeue(), &#x27;---dequeue1&#x27;) // vue ---dequeue1console.log(testQueue.dequeue(), &#x27;---dequeue2&#x27;) // react ---dequeue2console.log(testQueue.dequeue(), &#x27;---dequeue3&#x27;) // undefined ---dequeue3testQueue.enqueue(&#x27;angular&#x27;) // enqueue element angularconsole.log(testQueue.dequeue(), &#x27;---dequeue4&#x27;) // angular ---dequeue4 其他方法 主要的功能已经实现了，剩下的几个简单方法，对应注释我都写上了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 清空队列 */clear() &#123; this.size = 0 this.head = null this.tail = null&#125;/** * 获取队列长度 * @returns queue size */getSize()&#123; return this.size&#125;/** * 队列是否为空 * @returns 队列是否为空 */isEmpty() &#123; return this.size === 0 &amp;&amp; this.head === null&#125;/** * 打印队列 * @returns 队列字符串 */print() &#123; let queueStr = &#x27;&#x27; if (!this.isEmpty()) &#123; // 不为空 let tempNode = this.head // 缓存 head 避免修改影响到队列 // 循环头部 while(tempNode) &#123; // 获取 element queueStr += tempNode.element +( tempNode.next ? &#x27;---&gt;&#x27; :&#x27;&#x27;) // 修改 tempNode 进入下一次循环 tempNode = tempNode.next &#125; &#125; return queueStr&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133class Node &#123; constructor(element) &#123; this.element = element this.next = null &#125;&#125;class MyQueue &#123; constructor() &#123; // 当前队列长度 this.size = 0 // 头部指针 this.head = null // 尾部指针 this.tail = null &#125; /** * 入队 * @param &#123;*&#125; value 入队属性 * @returns */ enqueue(value) &#123; if (!value) return false // 创建节点 const node = new Node(value) // 判断队列是否为空 if (this.isEmpty()) &#123; // 队列为空 将节点元素添加到头部 this.head = node &#125; else &#123; // 队列不为空 将队尾的 next 指向新元素 const currentNode = this.tail // 做一下缓存 避免影响到后面 currentNode.next = node &#125; // 设置新的队尾 this.tail = node // 修改长度 this.size++ console.log(&#x27;enqueue element&#x27;, value) &#125; /** * 出队 最先进入的最先出去 * @returns */ dequeue()&#123; // 判断是否为空 if (this.isEmpty()) &#123; return &#125; const currentHead = this.head // 缓存head // 将头部指针指向下一个元素 this.head = currentHead.next // 修改长度 this.size-- // 清空尾部 this.tail = null return currentHead.element &#125; /** * 清空队列 */ clear() &#123; this.size = 0 this.head = null this.tail = null &#125; /** * 获取队列长度 * @returns queue size */ getSize()&#123; return this.size &#125; /** * 队列是否为空 * @returns 队列是否为空 */ isEmpty() &#123; return this.size === 0 &amp;&amp; this.head === null &#125; /** * 打印队列 * @returns 队列字符串 */ print() &#123; let queueStr = &#x27;&#x27; if (!this.isEmpty()) &#123; // 不为空 let tempNode = this.head // 缓存 head 避免修改影响到队列 // 循环头部 while(tempNode) &#123; // 获取 element queueStr += tempNode.element +( tempNode.next ? &#x27;---&gt;&#x27; :&#x27;&#x27;) // 修改 tempNode 进入下一次循环 tempNode = tempNode.next &#125; &#125; return queueStr &#125;&#125;const testQueue = new MyQueue();testQueue.enqueue(&#x27;vue&#x27;)testQueue.enqueue(&#x27;react&#x27;)// testQueue.enqueue(&#x27;angular&#x27;)console.log(testQueue.dequeue(), &#x27;---dequeue1&#x27;)console.log(testQueue.dequeue(), &#x27;---dequeue2&#x27;)// console.log(testQueue.clear(), &#x27;---clear&#x27;);console.log(testQueue.dequeue(), &#x27;---dequeue3&#x27;)testQueue.enqueue(&#x27;angular&#x27;)console.log(testQueue.dequeue(), &#x27;---dequeue4&#x27;)// console.log(testQueue.getSize(), &#x27;---getSize&#x27;)// console.log(testQueue.isEmpty(), &#x27;---isEmpty&#x27;)// console.log(testQueue.print(), &#x27;---print&#x27;) yocto-queue源码 看一下yocto-queue的实现逻辑，大体逻辑上是差不多，但多了几个知识点。 自定义迭代器 在print打印队列函数，这里是用了是用了Symbol.iterator自定义了一个迭代器，可以遍历整个队列，提供外界使用。 Class getter setter 在size函数前面有一个 get关键字，可以直接获取到return返回的值，。同理，如果前面是set，就可以直接修改数据。 私有属性# 我们都知道，class类的属性默认都是公有的，在实现类的后，可以访问到类里面的属性。但可以使用增加哈希前缀 # 的方法来定义私有类字段 123456789class Add &#123; [[count]] = 0; value() &#123; return this.#count; &#125; increment() &#123; this.#count++; &#125;&#125; 上面代码中，#count就是私有属性，只能在类的内部使用（this.#count）。如果在类的外部使用，就会报错，这个就很好理解。 123const counter = new Add();counter.#count // 报错counter.#count = 42 // 报错 总结 看完yocto-queue的实现后不由感慨，原来队列实现还可以这么优雅简洁，迭代器的使用也是很巧妙，这个思路可以收藏✅。写完后发现，数组版本和链式版本有啥区别？明明链式版本更简单易懂，为什么还要实现链式版本？后来刷题的时候才想通。数组的特点是查询数据快，插入数据慢，查询的时间复杂度是O(1)，插入的时间复杂度是O(n)。它插入元素时，移动的是整个数组。而链式结构刚好和它相反，在查询时的复杂度是O(n)，插入的是O(1)。插入元素只需要修改next指向就可以，比数组快上不少，这就是数据结构的魅力。","categories":[{"name":"Js","slug":"Js","permalink":"https://wakaka378.github.io/categories/Js/"},{"name":"数据结构","slug":"Js/数据结构","permalink":"https://wakaka378.github.io/categories/Js/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Js","slug":"Js","permalink":"https://wakaka378.github.io/tags/Js/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wakaka378.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"队列","permalink":"https://wakaka378.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"如何学习github上的项目","slug":"如何学习github上的项目","date":"2022-12-04T13:29:08.000Z","updated":"2023-06-14T13:30:25.905Z","comments":true,"path":"post/20221204212908.html","link":"","permalink":"https://wakaka378.github.io/post/20221204212908.html","excerpt":"","text":"前言 「我正在参与掘金会员专属活动-源码共读第一期，点击参与」 作为一个合格的前端（摸鱼）工程师，经常在github上看到很多优秀的项目，但都是只知道如何去使用。本文将以omit.js为例，一起看看怎样学习阅读查看github上项目代码，使用VsCode来调试项目，一步步的查看代码是这么运行的。 准备 在官网下载安装最新版本 VSCode。 准备源码 12345678910# clone 项目git clone git@github.com:benjycui/omit.js.git# 进入项目cd omit.js# 安装依赖npm installorcnpm install 用VsCode打开项目 omit.js介绍 我们要学习一个项目，就需要带着问题去学习，在学习的时候要知道这个项目提供了什么？怎样去使用？一般在项目的README.md文件中都会有项目的一些介绍。以omit为例，它主要是提供了一个对象剔除的功能，可以将对象中指定的属性删除，返回剔除后的对象。 1234# 安装npm install -S omit.jsorcnpm install -S omit.js 在项目中使用 123456789101112131415161718192021222324# ESMimport omit from &#x27;omit.js&#x27; or# CommonJSconst omit = require(&#x27;omit.js&#x27;)const user = &#123; name: &#x27;zhangsan&#x27;, age: &#x27;18&#x27;, gender: &#x27;1&#x27;&#125;const result = omit(user, [&#x27;name&#x27;])console.log(result)result ===&gt; &#123; age: &#x27;18&#x27;, gender: &#x27;1&#x27;&#125;user ====&gt; &#123; name: &#x27;zhangsan&#x27;, age: &#x27;18&#x27;, gender: &#x27;1&#x27;&#125; 知道的了omit.js主要功能后，来看一下它是如何实现的。 源码阅读 我们用VsCode打开项目，我们要学习一个项目，最先查看的文件就是package.json，这里会有项目的一些描述信息比如版本、作者、入口文件、命令、依赖等信息。 我们可以看到它有这么几个命令 1234567891011121314&#123;... &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;father doc dev --storybook&quot;, // 项目生成html doc文档 &quot;build&quot;: &quot;father doc build --storybook&quot;, // 打包 doc文档 &quot;compile&quot;: &quot;father build&quot;, // 项目编译打包 &quot;gh-pages&quot;: &quot;father doc deploy&quot;, // 部署 doc文档 &quot;prepublishOnly&quot;: &quot;npm run compile &amp;&amp; np --yolo --no-publish&quot;, // 打包 发布 &quot;lint&quot;: &quot;eslint .&quot;, // eslint 校验 &quot;test&quot;: &quot;father test&quot;, // 单元测试 &quot;coverage&quot;: &quot;father test --coverage&quot; // 生成测试报告 &#125;,...&#125; 这几个命令都和、np`有关，而我们也看到项目有安装这几个依赖包，有兴趣的可以去了解一下，这里做一下简单的介绍。 father：一款 NPM 包研发工具，能够帮助开发者更高效、高质量地研发 NPM 包、生成构建产物、再完成发布。 np：一款交互式命令发布工具，可以快捷的将包发布到npm上。 我们着重关注一下compile命令，它通过.fatherrc.js配置来编译项目，在这里我们可以看到项目的入口路径在src/index.js。 12345678910export default &#123; entry: [&#x27;src/index.js&#x27;], cjs: &#x27;babel&#x27;, esm: &#123; type: &#x27;babel&#x27;, importLibToEs: true &#125;, doc: &#123; base: &#x27;/switch&#x27; &#125;, preCommit: &#123; eslint: true, prettier: true, &#125;,&#125;; 我们来看一下源码 1234567891011function omit(obj, fields) &#123; // eslint-disable-next-line prefer-object-spread const shallowCopy = Object.assign(&#123;&#125;, obj); for (let i = 0; i &lt; fields.length; i += 1) &#123; const key = fields[i]; delete shallowCopy[key]; &#125; return shallowCopy;&#125;export default omit; 代码很好理解，先是通过Object.assign拷贝一下目标对象，为了是不影响到原对象。然后便利fields数组，通过上面的例子我们知道，这里传入的是需要剔除的对象属性，是一个数组，每一项为string。现获取到需要删除的key，在通过delete关键字删除拷贝对象里的属性，最后将拷贝的对象返回出去。 这里有一个问题是，只用了一层的循环。如果我对象嵌套很深的话，是无法进行处理的。 代码如何运行 看完源码后，来看一下它是如何在我们项目中运行的？ 在package.json文件中，我们可以看到这么几个字段 12345678910111213&#123;... &quot;main&quot;: &quot;lib/index.js&quot;, // 包的主要入口文件 &quot;module&quot;: &quot;es/index.js&quot;, // 包的 ESM 规范的入口文件 &quot;types&quot;: &quot;index.d.ts&quot;, // ts声明文件 &quot;files&quot;: [ // 推送到npm上的文件列表 &quot;lib&quot;, &quot;es&quot;, &quot;dist&quot;, &quot;index.d.ts&quot; ],...&#125; 执行一下compile命令后发现会多es、lib文件，再看一下安装包后node_modules文件下的omit.js目录结构。 然来是项目在compile后会生成es、lib两个文件，其中es为源码，lib为经过bale处理后的代码。我们在安装完包后，在项目require()引入项目的时候，其实就是将package.json中的main路径下的代码引入进来，也就是node_modules/moit.js/lib/index.js里的代码。 如何调试代码 我之前都不会调试代码，直接一行console.log()走遍天下，遇到一些负责的代码根本都弄不清逻辑循序，而且还不优雅。后来慢慢学会了通过VsCode调试代码，这里就先简单介绍一些如何通过VsCode debuger来调试Node代码，还是以omit.js为例。 我们打开VsCode左侧插件栏中的运行和调试，也就是debug功能，然后为项目创建一个launch.js文件来配置debug，然后选择Node.js 将配置文件中program参数修改为omit函数的位置 1&quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/src/index.js&quot;, $&#123;workspaceFolder&#125;只的是项目的根目录 我们在src/index.js下直接调用一下omit方法 123456789101112function omit(obj, fields) &#123; // eslint-disable-next-line prefer-object-spread const shallowCopy = Object.assign(&#123;&#125;, obj); for (let i = 0; i &lt; fields.length; i += 1) &#123; const key = fields[i]; delete shallowCopy[key]; &#125; return shallowCopy;&#125;omit(&#123;name: &#x27;1&#x27;, age: 18&#125;, [&#x27;name&#x27;])// export default omit; 然后在function omit(obj, fields)这行打上断点，看一下函数的具体执行步骤。然后在debug栏点击运行，就可以看到进入了断点当中。 这里就可以看到每一行执行的结果，更方便的去调试理解代码。 总结 这里只是用omit.js项目作为示例，该如何去学习一个github项目代码，如何去看懂一些项目结构，知道它怎么运行。也可以更好的帮助我们自己去成长，学习优秀项目，在以后的工作日常中得以运用。比如我就看到该项目中使用了fabric包，将一些[[1-blog/工程化/Eslint | eslint]]，[[…/…/5-project/project-builder/eslint &amp; prettire &amp; typescript#Prettier | prettier]]等配置通过require方式引入进来，可以统一封装使用。np`可以进行自动发包。文中提到的如何调试代码也是我最近入手前端调试通关秘籍 这本小册才学会的，而且调试的方法也还不止一种。希望能借用【源码共读】活动，能让我培养起学习其他项目的习惯。","categories":[{"name":"Git","slug":"Git","permalink":"https://wakaka378.github.io/categories/Git/"},{"name":"DeBug","slug":"Git/DeBug","permalink":"https://wakaka378.github.io/categories/Git/DeBug/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://wakaka378.github.io/tags/Git/"},{"name":"DeBug","slug":"DeBug","permalink":"https://wakaka378.github.io/tags/DeBug/"}]},{"title":"一个躺平的年中","slug":"一个躺平的年中","date":"2022-07-23T13:06:41.000Z","updated":"2023-06-14T13:07:33.123Z","comments":true,"path":"post/20220723210641.html","link":"","permalink":"https://wakaka378.github.io/post/20220723210641.html","excerpt":"","text":"一个躺平的年中 「时光不负，创作不停，本文正在参加2022年中总结征文大赛」 这篇年中总结来的有点晚，活动快结束的时候才觉得写。不知道为什么，记忆力比之前下降了好多，很多事情都容易忘记。以至于现在回想一下上半年经历的一切，都需要从手机照片、社交账号里去寻找，花了一上午时间翻阅，简单的来做一个年中总结吧。 关于上半年，总结起来就几个关键词：躺平 居家 一无所事 躺平 由于去年经历了教育行业大裁员休息三个月后，随便找了一份并不满意的工作。团队氛围、身边的同事、工作的内容都远远不及上一家，时常怀念火花的团队氛围。在年前的转正会上没有通过，给了延期转正。 想起原因来，也是觉得可笑。 在转正评审会上，我复盘了一下迭代中我负责的某个功能出现的推迟交付，交付质量差的问题。主要责任还是我承担下来，但并不都是我的问题，将部分原因指向团队层面的问题和产品人员。然而没有想到领导给出的结论是我态度上的问题，从而做出延期转正的决定。当时觉得不可理喻，本来就不怎么看好这份工作，更是对它彻底失望。但由于经济原因，我需要这份工作，需要继续在北京立足下去。只能被迫接受，但那时已经做出了三月份跳槽的决定。开始制定学习计划、买课程、写项目，希望能在金三银四中成功跳槽。 到了金(铜)三银(铁)四，互联网开始出现大规模裁员，只准备了两周的复习后，就开始骑驴找马四处投简历。但没想到行情会差成这样，投了大半个月简历后，能面试的不超过两家。身边朋友都在吐槽今年找工作难，加上自身经济问题，只能先苟着。在面试前，给自己定制了许多学习计划，要完成多少多少。出去看了一圈之后，回来彻底躺平。什么学习计划都抛在脑后，买的课也不怎么看，周末也不打开电脑，彻底和现状妥协。 居家 由于跳槽失败只能被迫接受这份工作，在四月份的时候通过了转正评审，本以为可以一直这样每天苟下去，月底就接到领导通知，部门产品和银行合作的二期项目启动了，我被外派到银行上班，也只好默默接受。五月份北京突如其来的疫情，打乱了我五一出门的计划，这波疫情持续很久，加上银行管控严格，每天都是在家办公。每天都是睡到晨会前十分钟起床，省去了交通通行时间，可以自己在家做饭，家里的办公比公司自在，没有太多约束。甚至可以一整天都不在工作岗位上，只要你能应付过领导的检查。 一无所事 上半年工作处处不顺，情感上也到处碰壁，学习上一塌糊涂，彻底摆乱躺平。回顾上半年，没干成一件事，去年立下的flag也没几项完成了。整个人处在一个迷茫阶段，不知道自己要干啥，也没有目标，浑浑噩噩的度过每一天。躺平了，不写了，就这样吧。。。","categories":[{"name":"总结","slug":"总结","permalink":"https://wakaka378.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://wakaka378.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"掘金自动签到➕定时执行➕邮箱推送 你还想要啥❓","slug":"掘金自动签到➕定时执行➕邮箱推送-你还想要啥❓","date":"2022-01-16T13:15:12.000Z","updated":"2023-06-14T13:15:58.139Z","comments":true,"path":"post/20220116211512.html","link":"","permalink":"https://wakaka378.github.io/post/20220116211512.html","excerpt":"","text":"掘金自动签到 ➕ 定时执行 ➕邮箱推送 你还想要啥❓ 前言 冒着被关进小黑屋的风险 写了个掘金自动签到抽奖程序 包含了自动执行、签到、免费抽奖、沾喜气、邮件通知的脚本，以后再也不用每天忘记签到了😄 事情是这样的 元旦那天由于玩的太嗨 忘记了掘金签到这么一回事 作为一名专业的摸鱼🐟选手 怎么能断签呢（好吧 我是为了第二天5120矿石）果断买了补签卡 后来在想 为啥不写一个每天自动执行的签到脚本呢？？ 重要❗ 掘金团队已经对签到脚本采取措施，禁止🙅‍♂️使用自动签到脚本，违者将清空所有矿石或者封号，具体规则可参见禁止脚本签到行为沸点 ，大家还是遵循社区规范，每天登陆掘金进行签到。之前有使用过该项目的，建议将fork下来的仓库workflow手动禁止，或者直接删除项目，文章中的github项目链接我已删除。 具备能力 [x] action 每天9点定时执行 [x] 邮件通知 [ ] cookie过期邮件通知 [x] 签到 [x] 沾喜气 [x] 抽奖 [ ] 设定想要兑换的周边 自动计算还需要签到多少天 目前就具备这么多能力 项目会持续维护 添加的新的功能（前提是不会被优弧关起来）如果有更好的项目可以在评论区提出 Start quickly 用编辑器打开项目后 需要将带有手动填写的几项数据修改为自己的 其他不要动 123456789101112131415161718192021// 配置文件module.exports = &#123; // 需要手动填写 cookie: &#x27;&#x27;, // 请求地址 baseUrl: &#x27;https://api.juejin.cn&#x27;, // api地址 api: &#123; ... &#125;, // 邮箱配置 emailConfig: &#123; // 邮箱服务 163|qq service: &#x27;163&#x27;, // 邮箱 手动填写 email: &#x27;&#x27;, // 邮箱授权码 手动填写 pass: &#x27;&#x27;, &#125;&#125; cookie获取方式 cookie 有过期时间 大概是一个月 或者是退出登陆也会过期 登陆进入到掘金，F12打开控制台，选择network后随便点击一个接口，找到请求头中的cookie，选中数据后右键复制值 邮箱设置 这里以163邮箱为例 qq邮箱同理 如果是163邮箱 直接将service字段设置为163（qq邮箱就写qq） 然后填入你自己的邮箱 邮件发送成功 登陆邮箱会看到你给自己发了一条邮件 就像这样 授权码获取⚠️： 登陆进入163邮箱 打开设置 将以下几个设置打开 打开IMAP/SMTP服务时会弹窗发送短信 微信扫码后就可以发送短信（qq邮箱这一步开启需要手动进行验证发送短信） 我这里已经添加过了 就直接点击新增授权 也是一样会弹出二维码扫码发送短信 短信发送完毕后点击我已发送 然后就会得到你的授权码（注意授权码只展示一次） 将授权吗粘贴到配置文件中的 pass字段 将所有的参数填入无误后 可以用命令node index.js本地运行 可以收到邮件并且邮件里有日志消息 恭喜你🎉 以后再也不用每天签到了（会不会被官方打死） 确认无误后将修改后的项目push 项目已经设置了自动执行 每天9点会自动执行签到 并且发送邮件进行通知 自从用了自动签到后 妈妈再也不用担心我忘记签到了 兑换Switch不是梦 具体实现 如果只关注脚本功能 看到这里就可以左拐🚪了 如果对实现感兴趣 这里也和你分享一下具体的实现思路 有了想法之后就开始去扒掘金签到相关的接口 挨个接口点开看 都是给了些啥数据 每个数据都是用来干啥的 经过漫长的调试后 脚本签到能力就完成了 功能主要由一下几个接口组成 12345678910111213141516// 签到checkIn: &#x27;/growth_api/v1/check_in&#x27;,// 查询签到getCheckStatus: &#x27;/growth_api/v1/get_today_status&#x27;,// 查询签到天数getCheckInDays: &#x27;/growth_api/v1/get_counts&#x27;,// 查询当前矿石getCurrentPoint: &#x27;/growth_api/v1/get_cur_point&#x27;,// 查询抽奖getlotteryStatus: &#x27;/growth_api/v1/lottery_config/get&#x27;,// 抽奖draw: &#x27;/growth_api/v1/lottery/draw&#x27;,// 沾喜气dipLucky: &#x27;/growth_api/v1/lottery_lucky/dip_lucky&#x27;// 获取沾喜气列表用户getLuckyUserList: &#x27;/growth_api/v1/lottery_history/global_big&#x27; 接下来就很简单了 接接口嘛 谁还不会了 找个请求库直接干 这里我选用的是axios 先配置一下请求 在index.js写入 将config文件中的cookie丢进请求头中 1234567891011121314151617// 配置请求地址axios.defaults.baseURL = config.baseUrl// 设置cookieaxios.defaults.headers[&#x27;cookie&#x27;] = config.cookie// 相应拦截处理axios.interceptors.response.use((response) =&gt; &#123; const &#123; data &#125; = response if (data.err_msg === &#x27;success&#x27; &amp;&amp; data.err_no === 0) &#123; return data &#125; else &#123; return Promise.reject(data.err_msg) &#125;&#125;, (error) =&gt; &#123; return Promise.reject(error)&#125;) 接下来就直接请求接口，请求循序依次为 以下主要代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * 查看今天是否已经签到 * * @return &#123;Boolean&#125; 是否签到过 */const getCheckStatus = async () =&gt; &#123; try &#123; const getCheckStatusRes = await axios(&#123; url: config.api.getCheckStatus, method: &#x27;get&#x27; &#125;) return getCheckStatusRes.data &#125; catch (error) &#123; throw `查询签到失败!【$&#123;error&#125;】` &#125;&#125;/** * 查询当前矿石 * */const getCurrentPoint = async () =&gt; &#123; try &#123; const getCurrentPointRes = await axios(&#123; url: config.api.getCurrentPoint, method: &#x27;get&#x27; &#125;) console.log(`当前总矿石: $&#123;getCurrentPointRes.data&#125;数`) &#125; catch (error) &#123; throw `查询矿石失败!$&#123;error.err_msg&#125;` &#125;&#125;/** * 查询免费抽奖次数 * * @return &#123;Boolean&#125; 是否有免费抽奖次数 */const getlotteryStatus = async () =&gt; &#123; try &#123; const getlotteryStatusRes = await axios(&#123; url: config.api.getlotteryStatus, method: &#x27;get&#x27; &#125;) return getlotteryStatusRes.data.free_count === 0 &#125; catch (error) &#123; throw `查询免费抽奖失败！【$&#123;error&#125;】` &#125;&#125;/** * 获取沾喜气列表用户historyId * * @return &#123;string&#125; 被沾的幸运儿的history_id */const getLuckyUserHistoryId = async () =&gt; &#123; try &#123; // 接口为分页查询 默认查询条10条数据 &#123;page_no: 0, page_size: 5&#125; const luckyList = await axios(&#123; url: config.api.getLuckyUserList, method: &#x27;post&#x27; &#125;) // 随机抽取一位幸运儿 沾他 return luckyList.data.lotteries[Math.floor(Math.random() * luckyList.data.lotteries.length)]?.history_id &#125; catch (error) &#123; throw `获取沾喜气列表用户historyId失败` &#125;&#125;/** * 沾喜气 * */const dipLucky = async () =&gt; &#123; try &#123; // 获取historyId const historyId = await getLuckyUserHistoryId() // 沾喜气接口 传递lottery_history_id const dipLuckyRes = await axios(&#123; url: config.api.dipLucky, method: &#x27;post&#x27;, data: &#123; lottery_history_id: historyId &#125; &#125;) console.log(`占喜气成功! 🎉 【当前幸运值：$&#123;dipLuckyRes.data.total_value&#125;/6000】`) &#125; catch (error) &#123; throw `占喜气失败！ $&#123;error&#125;` &#125;&#125;/** * 抽奖 * */const draw = async () =&gt; &#123; try &#123; const freeCount = await getlotteryStatus() if (freeCount) &#123; // 没有免费抽奖次数 throw &#x27;今日免费抽奖以用完&#x27; &#125; // 开始抽奖 const drawRes = await axios(&#123; url: config.api.draw, method: &#x27;post&#x27; &#125;) console.log(`恭喜你抽到【$&#123;drawRes.data.lottery_name&#125;】🎉`) // 先沾一下喜气 await dipLucky() if (drawRes.data.lottery_type === 1) &#123; // 抽到矿石 查询总矿石 await getCurrentPoint() &#125; &#125; catch (error) &#123; console.error(`抽奖失败!=======&gt; 【$&#123;error&#125;】`) &#125;&#125;/** *查询签到天数 * * @return &#123;Object&#125; continuousDay 连续签到天数 sumCount 总签到天数 */const getCheckInDays = async () =&gt; &#123; try &#123; const getCheckInDays = await axios(&#123; url: config.api.getCheckInDays, method: &#x27;get&#x27; &#125;) return &#123; continuousDay: getCheckInDays.data.cont_count, sumCount: getCheckInDays.data.sum_count &#125; &#125; catch (error) &#123; throw `查询签到天数失败!🙁【$&#123;getCheckInDays.err_msg&#125;】` &#125;&#125;/** * 签到 * */const checkIn = async () =&gt; &#123; try &#123; // 查询今天是否签到没 const checkStatusRes = await getCheckStatus() if (!checkStatusRes) &#123; // 签到 const checkInRes = await axios(&#123; url: config.api.checkIn, method: &#x27;post&#x27; &#125;) console.log(`签到成功，当前总矿石$&#123;checkInRes.data.sum_point&#125;`) // 查询签到天数 const getCheckInDaysRes = await getCheckInDays() console.log(`连续抽奖$&#123;getCheckInDaysRes.continuousDay&#125;天 总签到天数$&#123;getCheckInDaysRes.sumCount&#125;`) // 签到成功 去抽奖 await draw() &#125; else &#123; console.log(&#x27;今日已经签到 ✅&#x27;) &#125; &#125; catch (error) &#123; console.error(`签到失败!=======&gt; $&#123;error&#125;`) &#125;&#125; 自动执行 关于自动执行 我最开始想的方案是通过服务器部署 开启一个定时任务去执行 这种方式需要有服务器 比较麻烦 也有人用云函数 我又懒得去注册 后了找到一种方案就是 白嫖Github Action 通过CI设置定时任务 每天自动执行 Github人人都有 要求也较低 由于我不是很懂CI这方面的东西 这次为了脚本也只是学了个皮毛 具体代码如下 1234567891011121314151617181920212223242526272829name: jjCheckInScripton: schedule: # 每天9点执行 时间格式 minute hour day month week 设置的时间是UTC 不是北京时间 需要+8 - cron: &quot;0 1 * * *&quot;# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs: start: # 运行环境为最新版的Ubuntu runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 [[安装node]].js - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: &#x27;14&#x27; # 安装依赖并且执行脚本 - name: npm install run: npm install - name: Start task run: node index.js 这里关键的代码是schedule 将触发任务的方式改为定时执行 到了设定好的时间后会自动执行任务 任务会以最新版本的ubuntu系统进行运行 安装node 安装项目中的依赖后 执行index.js中的代码 如果想要修改执行时间 按照 minute hour day month week 的格式修改schedule字段即可（设置的时间是UTC 北京时间 需要**+8**） 邮件发送📧 邮件发送这里选用的是Nodemail库 它的功能十分强大 支持多种邮箱服务 支持HTML内容、纯文本内容、附件、图片等等 发送邮件方式也很简单 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const nodemailer = require(&#x27;nodemailer&#x27;)​// 日志处理 将脚本日志通过ejs渲染成htmlconst logs = []console.oldLog = console.logconsole.oldErr = console.error​console.log = (str) =&gt; &#123; logs.push(&#123; type: &#x27;success&#x27;, text: str &#125;) console.oldLog(str)&#125;​console.error = (str) =&gt; &#123; logs.push(&#123; type: &#x27;error&#x27;, text: str &#125;) console.oldErr(str)&#125;​/** * 发送邮件 * */const sendEmail = async () =&gt; &#123; try &#123; const template = ejs.compile(fs.readFileSync(path.resolve(__dirname, &#x27;email.ejs&#x27;), &#x27;utf8&#x27;)); const transporter = nodemailer.createTransport(&#123; service: process.env.SERVICE, // 邮箱服务 port: 465, // 端口 secure: true, // 使用TLS，SSL加密端口465 secureConnection: true, auth: &#123; user: process.env.EMAIL, // 发送者邮箱 pass: process.env.PASS, // 邮箱授权码 &#125; &#125;)​ // 发送邮件 await transporter.sendMail(&#123; from: process.env.EMAIL, to: process.env.EMAIL, subject: &#x27;掘金签到通知🔔&#x27;, html: template(&#123; logs: logs &#125;) &#125;)​ &#125; catch (error) &#123; console.error(`邮件发送失败！$&#123;error&#125;`) &#125;​&#125; 邮件内容 我这里用ejs写了一个简单的日志模版 用来承载脚本的log 在前面我对console.log console.error进行重写 将str存储到logs数组中 吧logs数据传入模版引擎生成html 邮件发送其实很简单 具体配置可以查看官方文档 这里就解释一下用到的配置 service: 邮箱服务 Node mai l内部已经支持了很多邮箱服务 如果填写这个字段就不需要写host host: 邮箱的主机IP地址 这一项一版在开启IMAP/SMTP后会展示邮箱的IP地址 prot: 端口号 默认的为465 secure： 配置安全链接 secureConnection: 使用SSL（默认为false） auth.user: 发送者邮箱 auth.pass: 邮箱授权码 from: 发送者邮箱 to: 接受者邮箱 subject: 邮件主题 html: 邮件内容html字符串 Actions secrets 密码安全 关于cookie 邮箱授权码 刚开始是写在一个配置文件夹里面 后来啦哥提出了更好的方式 就是用Actions secrets 这种方式可以避免关键数据暴露 （万一那个无聊的家伙拿你cookie去梭哈了呢😏） 还是小心为上 其实使用也很简单 我之前对这块完全不熟悉 看了会官方文档 三下五除二就弄好了 在添加好secrets数据后 我们需要在blank.yml文件中对数据进行获取 获取方式也很简单 直接通过$&#123;&#123;secrets.youKey&#125;&#125;就可以获取到 以该项目为例 123456# 环境变量env: COOKIE: $&#123;&#123; secrets.COOKIE &#125;&#125; PASS: $&#123;&#123; secrets.PASS &#125;&#125; EMAIL: $&#123;&#123; secrets.EMAIL &#125;&#125; SERVICE: $&#123;&#123; secrets.SERVICE &#125;&#125; 在设置完之后 我们就可以在环境变量中使用这些数据 就像这样 12process.env.COOKIEprocess.env.EMAIL 但是获取到的数据在Actions中是无法进行展示的 在输出日志中 你定义的所有密码都会被清除 并在输出日志之前用星号替换 也是为了防止泄漏 如果觉得这样还不够安全 在代码中可以随意使用到数据 可以尝试一下对密码进行加密 Q&amp;A 自动执行延迟 在开发测试的时 发现jobs没有按时执行 九点五分到公司打开actions时发现并没有执行jobs 刚开始还以为是cron 时间填写错误 修改时间后发现github actions定时任务会有延迟 延迟时间几分钟到十几分钟甚至一小时都有 但这个并不影响我们签到功能 只要是在今天签到都可以 以我测试为例 将 corn时间设置为每天的12:30 但实际执行时间为 12:51 差不多延迟了20分钟 1234on: # 定时执行 schedule: - cron: &quot;30 4 * * *&quot; 查看相关文档后发现 在GitHub中关于Schedule的定义： Note: The schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. To decrease the chance of delay, schedule your workflow to run at a different time of the hour. 注意: 在高负载的 GitHub action 工作流运行期间，调度事件可能会被延迟。高负载时间包括每个小时的开始。为了减少延迟的机会，请安排您的工作流在一小时的不同时间运行。 也就是说 Schedule中的cron时间并不是真正执行的时候 而是工作流进入到GitHub进行计划排队时间 说简单点就是工作流进入到GitHub执行的队列时间 具体什么时候执行工作流 则需要看GitHub工作流的负载 这个问题在签到需求中并不是致命的问题 如果想要解决可以参考Github Action的 Schedule 运行不准时的解决办法这篇文章 为啥不用document.cookie? 控制台输入命令获取到的cookie并不完整 这是控制台获取到的cookie，对比一下接口的cookie，相差很大 声明📢 本项目仅适用于学习交流 并不具备其他用途 也没有经过掘金官方团队 若是被封号 与我无关（手动狗头保命） 有其他想法或功能 欢迎👏进行讨论 如果对你有帮助 给个Star行不行","categories":[{"name":"Github","slug":"Github","permalink":"https://wakaka378.github.io/categories/Github/"},{"name":"工具","slug":"Github/工具","permalink":"https://wakaka378.github.io/categories/Github/%E5%B7%A5%E5%85%B7/"},{"name":"Node","slug":"Github/工具/Node","permalink":"https://wakaka378.github.io/categories/Github/%E5%B7%A5%E5%85%B7/Node/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://wakaka378.github.io/tags/Github/"},{"name":"工具","slug":"工具","permalink":"https://wakaka378.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Node","slug":"Node","permalink":"https://wakaka378.github.io/tags/Node/"}]},{"title":"2021当程序员碰到本命年...","slug":"2021当程序员碰到本命年","date":"2021-12-07T13:09:02.000Z","updated":"2023-06-14T13:09:51.144Z","comments":true,"path":"post/20211207210902.html","link":"","permalink":"https://wakaka378.github.io/post/20211207210902.html","excerpt":"","text":"2021当程序员碰到本命年… 「时光不负，创作不停，本文正在参加2021年终总结征文大赛」 工作 ❌拒绝pua 第一次离职发生在今年3月份，离开了在厦门公司，在公司工作两年，见证了公司有入职时的十几人团队到离职时的两百多号人的发展历程。两年来，公司教会了我很多。一个人的前端，技术栈怎么舒服怎么来，也没有绩效考核、提心吊胆code Review、没完没了的会议。要说坏处，那就是太累了，所有事情都得你一个人去承担。不光是技术，公司也教会我，「工作的事情不能太感性」，大家都是出来打工都是为了钱，只要是和利益相关的都要坚守自己的底线，不要被老板的一些大饼所诱惑。我当初就是太天真，20年疫情期间遵循公司降薪后，还没日没夜的在家干活，回公司后处于降薪的同时，还要自己承担房租（我从武汉跟随公司来厦门，那会是包住的）。本来不高的工资加上降薪，自己承担房租，那会手上还有车贷，几乎是每个月到手的钱立马就没了。那会坚信公司有困难，大家都走了，我不能在关键时刻离开公司（哼～天真的我），要和公司一起度过难关，等公司挺过去了不会亏待我们这些员工。可等公司挺过去了（我们那会做的是线上教育），还反过来在你身上猛嘬一口。 最后实在忍受不了，今年3月份和公司提了离职。离职处理完家中事情后，开始着手复习。在家一边复习一边投简历，瞄准的城市是 「北京」，在线上面试了几家之后，收到了那会觉得还不错的offer，总体薪资水平在14k左右。对于当时的我来说，已经是之前的两倍多了。时机成熟之后，只身一人坐上了北上的飞机，开始北漂生活。 来北京后，并没有着急入职，而是继续投简历面试。最后选择入职某花思维教育公司，开启了第二份工作。 😔教育行业裁员 由于在第一家公司做教育，来北京后找工作也是针对教育行业。那会觉得做教育行业的公司应该都还不错，比较老东家就是靠着做教育渡过疫情发展壮大的。四月份入职新公司后，被分到通信研发中心负责公司通信产品研发。那是我第一次在一个有完整的制度规范、开发流程的公司里上班。以前都不知道什么是codeReview、什么是showcase、版本发布还能这样弄等等。就好像一个山沟沟里的孩子，看到见了满地的高楼大厦一般。团队氛围非常喜欢，组里的小哥哥小姐姐超棒，leader人也不错（这里真的很感谢他们对我的包容，尤其是leader为团队承受了很多外界压力）。 其实在某花的工作还是很辛苦的，早10晚9，中间俩小时休息和下午一小时吃饭。平时下班就八点多，到家基本都在十点左右，要是碰到开发紧急或者需要发版，通常都是在十点下班（因为十点后打车报销）。工作很累，但是自己很喜欢，对工作充满了干劲。 「时代的一粒灰，落在个人头上就是一座山」 双减政策落地，教育行业备受打击 7月份公司开始裁员。其实那会心里已经有底了，我肯定是要被裁掉的。被叫到一个办公室后，直接签好赔偿协议离职协议，那会还没有转正赔偿只有0.5，不过有总比没有强。上午还在写代码，下午交完工牌还了设备就离职了。直到我们办完离职手续，leader开会回来才知道我们组里今年入职的同学全部都被裁了，我从他眼里看到了无助以及愧疚，大家走之前吃了一顿散伙饭，和leader、留下来的同事一一道别后，开始第三份工作寻找之路。 🏃跑路要快 离职后我并没有着急找工作，而是给自己放了一个月的假。那会时间节点还不是很好，自己也没有复习，再加上外面全是教育行业裁员的，整体行情并不是很好。于是休息够了之后，就开始了系统的复习。来北京前复习过一次，但都是粗略的过一遍知识点，并没有完整的复习。这次复习我列好需要复习的一些知识点、面试常问的面试题、开始看一些源码，复习的同时并记录下笔记，留下了这篇2021前端面试复习，这也是今年发布的第一篇文章。一个月复习后，9月份开始陆陆续续投简历约面试。几乎保持一天两家的评率，大概持续了两周，面了十家左右。小公司几乎一面一个准，稍微大一点的公司一面二面都会通过，但是经常会卡在三面或者是算法题。我是完全没有算法基础的，面试一问算法题我就慌，记得有一家问斐波那契数列第n求和的问题，想半天都没有回答上来。后来面了一些中厂后，被面试官全程碾压。备受打击之后选择逃避，开始浑浑噩噩的过日子，每天沉迷游戏电影。 直到手上积蓄花光之后，开始着急找工作了有危机感了，那会已经来到十月。那会的现状是小公司不想去，大一点的公司要么位置太远要么不想去。进过一顿筛选后，选择入职一家C轮融资2亿的医疗公司。这家公司主要给医院写后台管理系统，没有前端，后台大部分都是全栈。十月中旬入职后，上午签署了一大堆各种协议，下午开始接触公司业务代码。闲的无聊看了一下公司大群聊天消息，突然发现这家公司现在有经济危机，两个月前的工资还没发。我意识到不对劲，直接找到hr说自己不合适，hr很是不解，入职流程走的好好的，怎么就不合适呢。于是让我领导和我谈谈，领导他也是个爽快人，就直接说公司目前资金流转不开，确实发生了拖欠工资，但近期会有好转，已经找到新的投资人（鬼知道哦）。我二话没说，流程都不用走了，直接跑路。所以大家以后在找工作时，发现公司不对劲赶紧跑。 🐟现状 从医疗公司离职后，又投了一段时间简历，十月底的时候入职了现在公司。没有之前的资金问题，出手也很大方，也没有太多的套路。公司主要做可视化方面，智慧园区、智慧城市、3D可视化等，这些都和我没关。我所在的是2D可视化，用GoJs话流程图的。其实公司还好，让我很不爽的一点就是需要驻场开发。近期就被派到某信银行现场开发（不就是外包嘛）。在客户现场开发就没有公司本部那么舒服，没有外网（最不爽的一点），只能用银行的垃圾电脑等。但总体好，没啥开发任务，有很多学（摸）习（鱼）时间，也不需要怎么加班，五点半左右我就跑了。 对于现状我并不满意，不喜欢公司团队氛围、技术氛围也不好，没有什么进步空间，每天都是为了工作而工作。但不得不向生活低头屈服，为了💰还是要接着干。不过可以通过这份工作多余的时间，静下心来刷题、写技术文档、学习新的技术、做开源项目等等事情。既能赚钱，又有时间做自己的事情，何乐不为。 个人技术 技术方面，除了在某花时候用过一段时间react，其他的技术栈还是和之前工作一样，但是这一年的更多是收获了出技术栈以外的东西。以前在小公司一个人开发管理项目的时候，觉得自己已经很厉害了，不管是技术还是项目管理方面。直到来到北京后，发现自己才是小丑。这里很感谢能够有在某花的工作经历，那段经历让我打开了视野，让我觉得自己还很渺小，自己还是很弱，需要保持学习不断进步。 /minad 生活感情 生活上也是处处碰壁，过年的时候父亲住院动手术，我只好提前回家（回家第一天就报废一条车胎和轮毂🥲）。3月份离职的时候，还没有到原定的离职日期我便连夜飞回家，父亲意外受伤，从县医院转到武汉人民医院，直到八九月份才慢慢恢复。女朋友也在夏天的时候大病一场，本以为年底会平静一些，谁想最近姐姐也因病住院，前天刚做完手术。家庭关系也很紧张，父母不停的吵架甚至到了分居的地步。 但还好，这一切一切都没有压垮我，因为我遇到了我生命中的她，最初来北京的目的也是为了能够和她在一起。来北京后也是她一直在照顾我，找工作帮我出谋划策、陪我找房子、在我有困难的时候出现在我身边。而我也在为满足她做一条咸鱼的理想在不断的努力。 我俩的备注，懂的同学可以评论区留言😏 我吧今年这一切的不顺，都归罪于我今年本命年（虽然我不信这个），我相信一切都会过去的，现在所有的问题都会有结果，我对我未来的生活充满了希望。 总结一下 flag 今年在技术方面收获甚少，也没有做知识输出，近期已经做好了规划，迎接明年的金三银四 [ ] 多输出技术文章 [ ] LeetCode不能停 [ ] Vue3全家桶学习 [ ] 源码的学习还是需要继续 [ ] node学习（近期在规划已经在规划用node koa express做一套东西） [ ] todoList项目要完成 [ ] 保持健康 要有一个好身体 [ ] 要多下厨，毕竟外卖不健康 [ ] 换一家喜欢的公司 [ ] 多看书，不管是技术书还是其他的 [ ] 带家人出去旅游一次散散心 [ ] 答应她明年带她去看南京的梧桐 [ ] 要有存款 有钱才有底气 [ ] 多和家人联系","categories":[{"name":"总结","slug":"总结","permalink":"https://wakaka378.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://wakaka378.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"2021前端面试复习","slug":"2021前端面试复习","date":"2021-08-26T13:10:52.000Z","updated":"2023-06-14T13:13:09.231Z","comments":true,"path":"post/20210826211052.html","link":"","permalink":"https://wakaka378.github.io/post/20210826211052.html","excerpt":"","text":"一个在教育行业苦干两年的前端菜鸟，离职后就在准备复习面试，记录一下这次前端复习过程。前端知识是在是太多，持续更新中… 希望对真正找工作的你有所帮助，文末我整理了一下面试文章，感兴趣的可以看看，尤其是2021高频前端面试题汇总系列，帮助很大。文章有所不足的地方还指明。 HTML5、CSS3 HTML5 HTML5新增特性 语义化标签：header、nav、footer、section... 媒体标签：audio音频、video视频 表单类型属性：email、number、时间控件、color颜色拾取器、placeholder、autofocus自动获取焦点... cavas绘图 web存储：localStorage、sessionStorage 行内元素、块级元素有哪些 行内元素：a、span、img、input... 块级元素：div、ul、li、ol、dt、dh、li、p、h1-6 iframe的优缺点 优点： 原封不动的吧嵌入网页展示出来 增加代码的可重用 用来加载速度较慢的内容 缺点： iframe阻塞onload事件加载 网页内容无法被搜索引擎识别，对SEO不友好 会产生很多页面，不利于管理 canvas和SVG的区别 canvas：通过javaScript来绘制2D图形，是逐像素进行渲染 依赖分辨率 不支持事件处理 能够以.png或.jpg的格式进行保存 适合做游戏 SVG：基于XML描述的2D图形语言，是矢量图 不依赖分辨率 支持事件处理 适合做大型区域渲染 回流重绘 回流当DOM变化影响了元素，比如元素的尺寸、布局、显示隐藏等改变了，需要重写构建。每个页面至少需要一次回流，就是在页面第一次加载的时候，这个时候一定会发生回流。 重绘当一个元素的外观发生变化，但是没有改变布局，重新渲染元素的外观。比如background-color、color 回流必将引起重绘，而重绘不一定会引起回流 如何避免回流重绘： 避免使用table布局 尽可能在DOM树的最末端改变class 避免设置多层内联样式 开启GPU加速 将动画效果应用到position属性为absolute或者fixed的元素上 src和href的区别 srcsrc指向外部资源的位置，将指向的内容嵌入到文档中当前标签所在的位置，如js脚本、img图片、iframe等 href用于在当前文档和引用资源之间确立联系，一般是用在link、a等元素 CSS3 CSS3新增特性 新增CSS选择器、伪类 特效：text-shadow、box-shadow 渐变：gradient 旋转过度：transform、transtion 动画：animation 盒模型 盒模型都是有四部分组成：content、padding、border、margin 标准盒模型和IE盒模型的区别在于设置width和height时，对应的范围不同 标准盒模型的width、height只包含了content IE盒模型的width、height包含了border、margin、padding 通过修改元素的box-sizing属性来改变元素的盒模型 box-sizeing: content-box表示标准盒模型（默认值） box-sizeing: border-box表示IE盒模型（怪异盒模型) trastion和aniamtion的区别 transtion：属于过度属性，强调过度，需要一个事件进行触发（如鼠标进入、离开）类似flash的补间动画，设置一个开始帧和结束帧 aniamtion：属于动画属性，它的实现不需要触发事件，设定好后可自动执行，且可以循环播放。也是类似补间动画，但是可以设置多个关键帧 元素水平垂直居中 绝对定位：先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。 123456789.parent &#123; position: relative;&#125; .child &#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);&#125; 绝对定位：设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。 123456789101112.parent &#123; position: relative;&#125; .child &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;&#125; 使用flex弹性盒子布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。 12345.parent &#123; display: flex; justify-content:center; align-items:center;&#125; p、em、rem的区别 px 固定像素单位，不能随其它元素的变化而变化 em是相对于父元素的单位，会随着父元素变化而变化 rem是相对于根元素html，它会随着html元素变化而变化 rem常用在移动端项目，设置根元素的fong-size，其它元素会随着根元素的变化而变化，从而达到不同手机屏幕的自适应大小。通常会配合postcss-pxtorem插件进行使用 如何解决1px问题 直接写0.5px 利用伪元素，先放大再缩小 使用viewport缩放来解决 什么是BFC布局，如何创建BFC布局？ BFC布局为块格式化上下文（Block Formatting Context，BFC）， 是CSS布局的一个概念，里面的元素不会影响到外面的元素。 创建BFC： 元素设置浮动：float有值并不为空 元素设置绝对定位： position（absolute、fixed） overfilow值为：hidden、auto、scroll display值为：inline-block、table-cell、table-caption、flex等 BFC作用： 解决margin重叠问题：由于BFC是一个独立的区域，内部元素和外部元素互不影响，将两个元素变为BFC，就解决了margin重叠问题 创建自适应两栏布局：可以用来创建自适应两栏布局，左边宽高固定，右边宽度自适应。 解决高度塌陷问题：在子元素设置浮动后，父元素会发生高度的塌陷，也就是父元素的高度为0解决这个问题，只需要将父元素变成一个BFC。 link和@import的区别 link是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS、rel连接属性等 @import是CSS提供等语法规则，只有导入样式表带作用。 link标签引入的CSS被同时加载，而@import引入的CSS将在页面加载完毕后被加载 @import是CSS2.1才有的语法，存在兼容性，而link作为HTML标签不存在兼容性问题 CSS选择器优先级 @important 内联样式 ID选择器 类选择器/属性选择器/伪类选择器 元素选择器/伪元素选择器 关系选择器/通配符选择器 JS基础 基础数据类型 string、number、boolean、object、function、undefined、null、symbol null和undefined的区别：null表示对是一个空的对象(object)、undefined是申明了但没赋值，在使用typeof检测类型时，null为object，undefined为undefined 123null == undefined // truenull === undefined //false 值类型（基本数据类型）：string、number、boolean、undefined、null、symbol 引用类型：object、function、array 值类型和引用类型区别： 值类型保存在栈中，占用空间固定，当一个方法执行时，每个方法都会创建自己的内存栈，方法中定义的变量会存放在这个内存栈中。当方法执行结束时，这个内存栈也会被销毁。所以，栈中存储的是基础变量。而引用变量存储在栈中是指向堆中的数组或对象的引用地址。这也就是为何修改引用类型总会影响到其它指向这个地址的引用变量。 值类型可以使用typeof进行数据类型检测 引用类型保存在堆中，占用空间不固定。创建对象会保存到堆内存中，这个内存不回随着方法结束而销毁，因为这个对象还可能被另外一个变量所引用，只有当一个对象没有被任何变量引用时，系统的垃圾回收机制会将它回收。 引用类型使用instanceof检测数据类型 使用new（）方法构造出来的对象是引用类型 闭包 闭包就是能够读取到其它函数内部变量的函数，创建一个最简单的闭包，就是在一个函数内部创建另外一个函数，创建的函数可以访问到当前函数的局部变量。在[[3-study/前端/手写基础函数#节流防抖|节流防抖]] 中广泛引用 闭包优点： 创建全局私有变量，避免变量全局污染 可以实现封装、缓存等 闭包缺点： 创建的变量不能被回收，容易消耗内存，使用不当会导致内存溢出 变量提升、作用域、作用域链 变量提升 js代码在解析的时候，会将所有的变量函数，提升到代码的最上面。变量提升，提升的只是变量申明，并不会吧变量赋值提升上来 12console.log(i) // 4var i = 4 作用域 作用域是一个变量或函数的可访问范围，作用域控制着变量或函数的可见性和生命周期 全局作用域：可以全局访问 最外层函数和最外层定义的变量拥有全局作用域 window上的对象属性方法拥有全局作用域 为定义直接复制的变量自动申明拥有全局作用域 过多的全局作用域变量会导致变量全局污染，命名冲突 函数作用域：只能在函数中访问使用哦 在函数中定义的变量，都只能在内部使用，外部无法访问 内层作用域可以访问外层，外层不能访问内存作用域 ES6中的块级作用域：只在代码块中访问使用 使用ES6中新增的let、const什么的变量，具备块级作用域，块级作用域可以在函数中创建（由{}包裹的代码都是块级作用域） let、const申明的变量不会变量提升，const也不能重复申明 块级作用域主要用来解决由变量提升导致的变量覆盖问题 123456var i = 3function fnc() &#123; console.log(i); var i = 6;&#125;fnc() // undefined 作用域链 变量在指定的作用域中没有找到，会依次向上一层作用域进行查找，直到全局作用域。这个查找的过程被称为作用域链。 call、apply、bind区别 都可以用作改变this指向 call和apply的区别在于传参，call、bind都是传入对象。apply传入一个数组。 call、apply改变this指向后会立即执行函数，bind在改变this后返回一个函数，不会立即执行函数，需要手动调用。 new操作符干了什么操作 创建一个空对象 设置原型，将对象的原型设置到函数的prototype对象上 改变this指向，将this指向该对象，并执行构造函数。 判断函数的返回类型，如果是值类型，返回创建的对象。如果是引用类型，返回这个引用类型的对象。 [[…/…/1-blog/设计模式/js设计模式(一)面向对象—封装#原型和原型链 |原型和原型链 ]] 原型: 每个对象在内部初始化的时候，都会初始化一个prototype原型属性 ，而对象的 _proto_属性，指向它的原型对象。 原型链: 当我们访问英国对象属性时，如果这个属性不存在，那么就会去它的原型对象上进行查找，而这个原型对象又会有自己的原型，会这样一直查找，知道找到顶级对象object为止。这个查找的过程被称为原型对象。 继承 原型链继承 利用对象的原型链，将子类Son.prototype指向父类的构造函数创建出来的实例对象new Person() 🌰 12345678910function Person() &#123; ...&#125;; function Son() &#123; ....&#125;;// 关键代码Son.prototype = new Person(); 优点： 子类可以继承父类构造函数、原型上的属性方法 缺点： 父类引用类型的实例对象被共享，容易造成修改的混乱。 创建子类的时候不能向父类传参 构造函数继承 利用.call()或者.apply()方法，在子类中借用父类的构造函数，初始化父类构造函数。 🌰 123456789function Person(name) &#123; ...&#125;; function Son(name) &#123; // 关键代码 Person.call(this, name) ...&#125; 优点： 子类在继承父类时，可以向父类构造函数中传参。 不会造成子类势力之间引用属性共享。 缺点： 只能继承父类构造函数中的属性方法，无法访问原型上的方法。 每个子类都会创建一个父类副本 组合继承 组合继承，将原型链继承和构造函数继承融合在一起。 🌰 12345678910111213function Person(name) &#123; ...&#125;; function Son(name) &#123; // 借用构造函数继承关键代码 Person.call(this, name);&#125;;// 原型链式继承关键代码Son.prototype = new Person();// 将子类的构造函数指向自己Son.prototype.constructon = Son; 优点： 结合前面两种继承方式的优点，子类的实例可以访问到父类原型上的属性方法 子类的实例之间不会被共享 缺点： 调用了两次父类构造函数 原型式继承 用函数包装一个对象，返回这个函数的调用（也就是ES5的Object.create的模拟实现），将传入的对象作为创建对象的原型 🌰 12345678910111213141516171819function create(obj) &#123; // 创建一个空的的构造函数 function F() &#123;&#125;; // 将空的构造函数原型指向传递进来的对象 F.prototype = obj; // 返回一个实例对象 return new F();&#125;const obj = &#123; name: &#x27;zs&#x27;, ...&#125;;const newObj1 = create(obj);const newObj2 = create(obj); 优缺点和原型链式继承一样，引用类型还是会被共享。 寄生式继承 在原型式继承基础上，在函数内部来做增强函数，返回对象。 🌰 123456789101112function createObj(obj)&#123; // 获取继承的子类对象，也就是上面的create方法实现 const newObj = Object.create(obj); // 函数增强 newObj.say = function() &#123; ... &#125; // 返回对象 return newObj;&#125; 类似原型式继承，但在原有的基础上可以自定义属性方法，依旧没有解决引用值被共享问题。（跟借用构造函数模式一样，每次创建对象都会创建一遍方法。） 寄生组合式继承 结合寄生继承和组合式继承优缺点，组合式继承缺点为调用了两次父类构造函数，优点为解决了引用值被共享问题。而寄生式继承缺点为没有解决引用值被共享问题，只要将两者结合就得到完美的继承方式。 🌰 123456789101112131415161718192021222324252627282930function createObj(son, parent) &#123; // 寄生式继承，利用父类构造函数的原型对象创建出一个新的对象，解决组合式继承创建两个父类问题 const newObj = Objcet.create(parent.prototype)； // 将新对象的constructor构造函数执行子类 newObj.constructor = son; // 将子类构造函数的原型指向心的 原型式继承 son.protoytype = newObj; &#125;function Person(name) &#123; ...&#125;;function Son(name) &#123; // 构造函数继承 Person.call(this, name); ...&#125;; // 实现继承createObj(Son, Person)// 更简洁的方式 在组合式继承的基础上 直接将son的原型通过API指向person的原型Son.prototype = Object.create(Person.prototype);const obj1 = new Son(&#x27;zx&#x27;);const obj2 = new Son(&#x27;lw&#x27;); 深拷贝、浅拷贝 浅拷贝 浅拷贝只是复制对象的值类型，通过Object.assign或者扩展运算符即可实现 深拷贝 通过递归实现 12345678910111213141516function deepClone(obj) &#123; // 判断是否为对象 if (!obj || typeof obj !==&#x27;object&#x27;) return obj; // 根据obj类型创建数组还是对象 let newObj = obj instanceof Object ? &#123;&#125; : []; // 循环遍历obj，处理子元素为对象，递归拷贝 for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newOb[key] = deepClone(obj[key]) &#125;; &#125;; return newObj;&#125;; 事件循环机制EventLoop（浏览器） 栈、队列理解 栈（Stack）中的任务后进先出，js中的执行栈是一个存储函数的栈结构，栈中的任务执行遵循先进后出的原则依次执行。 队列（Queue）中的任务先进先出，js运行时创建一个任务[[…/…/1-blog/数据结构/JavaScript数据结构之——队列|队列]]，用来处理列表（事件）和待执行的回调函数 宏观任务、微观任务 js中的任务分为两种：宏观任务(MacroTask|Task)、微观任务(MicorTask)。 宏任务：script全部代码、setTimeout、setInterval、I/O、UI Rendering 微任务：Promise.then、Process.nexTick(Node独有)、MutationObserver 同步任务、异步任务 js有一个主线程和一个执行栈（调用栈），所有的任务都会放到执行栈中等待被主线程执行。 js代码在执行时，所有函数都会压入执行栈中。同步任务会按照后进先出原则依次执行，直到执行栈清空。异步任务会在异步任务有了结果后，将注册的回掉函数放入异步任务队列中，等待主线程空闲后（执行栈中的同步任务执行完毕）。 异步队列中的任务又分为宏观任务和微观任务，当当前执行栈清空后，处理异步队列中的任务时，首先会判断是否有微观任务可执行，如果有就将微观任务压入执行栈中执行。当微观队列中的任务在执行栈被执行完毕，再来异步队列中将宏观任务放入执行栈。 简单的来说： 执行同步代码，这属于宏观任务 所有代码执行完毕，执行栈清空，执行异步队列中任务 异步队列中，先执行微观任务 微观任务执行完毕，再执行宏观任务 [[3-study/前端/手写基础函数#节流防抖|节流防抖]] 节流（throttle）：在n秒内只允许执行一次， [[…/…/1-blog/防抖debounce理解|防抖]]（debounce）：在n秒内多次触发但不执行，而是在n秒后执行，如果n秒内触发则重新计算。 事件冒泡、事件委托 事件发生的三个阶段：捕获阶段、目标阶段、冒泡阶段 事件冒泡：在一个对象上触发某类事件，如果此对象绑定了事件，就会触发事件，如果没有，就会向这个对象的父级对象传播，最终父级对象触发事件。 如何阻止： 普通浏览器：event.stopPropagation() IE浏览器：event.cancelBubble = true; 事件委托：利用浏览器事件冒泡机制。事件在冒泡的过程中会传到父节点，并且父节点可以通过事件对象获取到目标节点，可以吧子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件 事件委托可以不必要为每一个子节点都绑定监听事件，减少内存上的消耗。 使用事件委托还可以实现事件的动态绑定，比如新增一个子节点，并不需要为此单独增加一个监听事件，可以由父元素中的监听函数来处理。 对DOM元素进行增删改查 增 1document.createElement() 删 12element.removeAttribute()element.removeChild() 改 12element.innerHTML()element.setAttribute() 查 12345getElementById()getElementsByClassName()getElementsByTagName()querySelector()querySelectorAll() ajax、axios、fetch区别 ajax 基于原生的XHR开发 本身针对MVC编程，不符合现在前端MVVM潮流 axios 从浏览器中创建XMLHttpRequest 支持promise 支持请求拦击和响应拦截 从node.js创建http请求 客服端支持防止CSRF/XSRF fetch 浏览器原生实现的请求方式，ajax的替代品 只对网络请求报错，对400、500都当做成功的请求，需要封装 fetch默认不会带cookie，需要添加配置项 fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费 fetch没有办法原生监测请求的进度，而XHR可以 ES6 var、let、const区别 var声明变量可以重复声明，而let不可以 var是不受限于块级作用域，而let受限 var存在变量提升，let和const不存在变量提升 const声明的变量不可变 const声明之后必须赋值，否则会报错 [[3-study/前端/手写基础函数#promise|Promise]] Promise是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 它有三种状态 pending初始状态 fulfilled操作成功 rejected操作失败。 Promise状态改变只有两种可能 从pending------&gt;fulfilled 从pending------&gt;rejected Promise构造函数接收一个参数和一个带有resolve和reject参数的回调函数。 resolve的作用是将Promise状态从pending变为fulfilled，在异步操作成功时调用，并将异步结果返回，作为参数传递出去 reject的作用是将Promise状态从pending变为rejected，在异步操作失败后，将异步操作错误的结果，作为参数传递出去 Promise实例方法 promise.then() 对应resolve成功的处理 promise.catch()对应reject失败的处理 promise.call()将多个Promise实例，包装成一个新的Promise实例，返回的实例就是普通的Promise。有一个失败，代表该Primise失败。当所有的子Promise完成，返回值时全部值的数组 promise.race()类似promise.all()，区别在于有任意一个完成就算完成（例如：将异步和定时器放在一起，设置请求超时） 箭头函数和普通函数的区别 箭头函数时匿名函数，不能作为构造函数，不能使用new 箭头函数不绑定arguments 箭头函数没有自己的this，将所在的上下文的this作为自己的this值 没有prototype call()、applay()、bind()方法不能改变箭头函数中的this指向 forEach和map的区别 forEach返回值是undefined，不可以链式调用 map()返回一个新的数组，不改变原数组。forEach改变原数组。 Set、Map的区别 Set 创建： new Set([1, 1, 2, 3, 3, 4, 2]) add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 Map set(key, val): 向Map中添加新元素 get(key): 通过键值查找特定的数值并返回 has(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false delete(key): 通过键值从Map中移除对应的数据 clear(): 将这个Map中的所有元素删除 区别 Map是一种键值对的集合，和对象不同的是，键可以是任意值 Map可以遍历，可以和各种数据格式转换 Set是类似数组的一种的数据结构，但在Set中没有重复的值 谈谈你对ES6对理解 解构赋值 扩展运算符 模版字符串 箭头函数 async/await Class 引入Moldule语法 class类 Vue 基础知识 MVVM MVVM是一种软件架构模式，在vue中 M 代表model层（数据模型），负责数据模型。V代表View层（视图层），VM代表ViewModel（视图模型），它是Model和View之间的桥梁，数据会绑定到viewModel层，并自动将数据渲染到页面层，视图变化时会通知viewModel更新数据 Vue生命周期 创建前后： beforeCreated（创建前）： 数据观测和初始化事件还未开始，不能访问data、computed、watch、methods上的数据方法。 created(创建后)：实例创建完成，可以访问data、computed、watch、methods上的数据方法，但此时渲染节点还未挂在到DOM上，所以不能访问。 挂载前后： beforeMounted（挂载前）: Vue实例还未挂在到页面html上，此时可以发起服务器请求 mounted（挂载后）:Vue实例已经挂在完毕，可以操作DOM 更新前后： beforeUpdate（更新前）: 数据更新之前调用，还未渲染页面 updated（更新后）:DOM重新渲染，此时数据和界面都是新的。 销毁前后： beforeDestoryed（销毁前）:实例销毁前调用，这时候能够获取到this destoryed（销毁后）:实例销毁后调用，实例完全被销毁。 watch和computed的区别 watch：监听属性，用来监听数据的变化，没有缓存，当监听到的数据发生变化时都会执行毁掉函数 computed：计算属性，被监听的值有缓存，只有它依赖的属性值发生变化后，下一次获取computed的值时才会重新计算computed的值。（只有依赖发生变化后才会重新计算） v-for中key的作用 key是为了更高效的对比虚拟DOM中的每个节点是否相同，避免页面更新时重复更新节点 v-if和v-show的区别 v-if元素不可见 删除dom元素 v-show元素可见 通过设置元素的display：none样式属性 组件中的data为什么是一个函数 因为对象是一个引用类型，如果data时一个对象的情况下会造成多个组件共用一个data，data为一个函数，每个组件都会有自己的私有数据空间，不会干扰其他组件的运行。 Vue组件通信 父子组件 父传子 props $children $refs 子传父 $emit $parent 兄弟组件 provied inject eventBus Vuex Vuex的基本使用 Vuex用于vue中的数据状态管理，有五种属性： state：Vuex的基本数据，用于存储变量 getter：从state派生出来的数据，当相遇state的计算属性，在这里可以对state数据进行过滤、筛选等操作 mutation：提交更新state数据的方法 action：和mutation功能相似，都是用来提交更新，但action提交的是mutation，而不是直接变更数据，并且action可以包含异步操作 module：模块化Vuex，每个模块都有自己的state、mutation、actoion、getter mutation和action的区别 mutation更专注于修改state，必须是同步执行。 action提交的是mutation，而不是直接更新数据，可以是异步的。 action可以整合多个mutation Vuex和localstory的区别 Vuex存储在内存中，页面关闭刷新就会消失。而localstorage存储在本地，读取内存比读取硬盘速度要快 Vuex应用于组件之间的传值，localstorage主要用于不同页面之间的传递 Vuex是响应式的，localstorage需要刷新 路由守卫 全局前置钩子：beforeEach、beforeResolve、afterEach 路由独享守卫：beforeEnter 组件内钩子：beforeRouterEnter、beforeRouterUpdate、beforeRouterLeave hash和history的区别 hash hash模式是vue开发中的默认模式，地址栏URL携带#，#后为路由。 原理是通过onhashchange()事件监听路由hash的变化，这个好处就是当hash值发生变化，不需要向后端发起请求，window就可以监听事件的改变，并按照规则加载项对应的代码。除此之外，hash值的变化对应的URL都会被浏览器记录下来，这样就能实现浏览器历史页面的前进后退。 history vue还提供history模式，在history模式下URL中没有#，相比hash模式更加好看。但是需要后台配置支持。 history的原理是利用HTML5中hostory提供的pushState、replaceState这两个API，这两个API记录了浏览器历史栈，并且当在修改URL时不会触发页面刷新和后台请求。 动态路由 定义方式 params传参 路由配置： /index/:id 路由跳转：this.$router.push(&#123;name: 'index', params: &#123;id: &quot;zs&quot;&#125;&#125;); 路由参数获取：this.params.id 最后形成的路由：/index/zs query传参 路由配置：/index正常的路由配置 路由跳转：this.$rouetr.push(&#123;path: 'index', query:&#123;id: &quot;zs&quot;&#125;&#125;); 路由参数获取：this.query.id 最后形成的路由：/index?id=zs router和router 和router和route $router是指整个路由对象，可以使用this.$router.push(&#123;name: ;index'&#125;)进行页面跳转 $route时指当前页面的路由对象，可以使用this.$route.parmas.id来获取当前路由对象传递进来的参数 Vue性能优化 原理知识 双向绑定原理 data在初始化的时候，会实例化一个Observe类，在它会将data数据进行递归遍历，并且通过definereactive方法，这个方法通过Object.defineProperty方法，给每个值添加上一个getter和一个setter。在数据读取的时候会触发getter进行依赖（Watcher）收集，当数据改变时，会触发setter，对刚刚收集的依赖进行触发，并且更新watcher通知视图进行渲染。 依赖收集 依赖收集发生在defineReactive()方法中，在方法内new Dep()实例化一个Dep()实例，然后在getter中通过dep.depend()方法对数据依赖进行收集，然后在settter中通过dep.notify()通知更新。整个Dep其实就是一个观察者，吧收集的依赖存储起来，在需要的时候进行调用。在收集数据依赖的时候，会为数据创建一个Watcher，当数据发生改变通知每个Watcher，由Wathcer进行更新渲染。 Object.defineProperty()数据劫持缺陷 该方法只能监听到数据的修改，监听不到数据的新增和删除。vue2中会对数组的新增删除方法push、pop、shift、unshift、splice、sort、reserve通过重写的形式，在拦截里面进行手动收集触发依赖更新。 在vue2中，需要数据里添加或删除时，使用vue.$set/vue.$delete进行操作。 在Vue3中，改用proxy对对象进行代理，返回一个代理对象，只需要操作新对象就可以。 双向绑定原理 Vue双向绑定是一个指令v-model，可以将数据动态绑定到视图上，同时视图中变化也可以改变改值。他的本质是 v-bind 和 v-on 的语法糖。在 ⼀个组件上使⽤ v-model ，默认会为组件绑定名为 value 的 prop 和名为 input 的事件。 nextTick的实现 vue中的nextTick是浏览器eventLoop是应用。nextTick是将回调函数放到一个异步队列中，保证在异步更新DOM的watcher后面，从而获取到更新后的DOM。 Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用； 怎么理解 vue 中的虚拟 DOM 虚拟DOM，就是用一个JS对象来描述一个DOM节点。Vue是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作DOM,而操作真实DOM又是非常耗费性能的，这是因为浏览器的标准就把 DOM 设计的非常复杂，所以一个真正的 DOM 元素是非常庞大的。VNode类中包含了描述一个真实DOM节点所需要的一系列属性，tag表示节点的标签名，text表示节点中包含的文本，children表示该节点包含的子节点等。 模版编译原理 模版编译主要过程：template ---&gt; ast ---&gt; render，分别对象三个方法 parse 函数解析 template optimize 函数优化静态内容 generate 函数创建 render 函数字符串 调用parse方法，将template转化为AST（抽象语法树），AST定义了三种类型，一种html标签，一种文本，一种插值表达式，并且通过 children 这个字段层层嵌套形成了树状的结构。 optimize方法对AST树进行静态内容优化，分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化。 generate将AST抽象语法树编译成 render字符串，最后通过new Function(render)生成可执行的render函数 diff算法逻辑 diff算法发生在视图更新阶段，也就是当数据发生变化的时候，diff会对新就虚拟DOM进行对比，只渲染有变化的部分。 当数据发生变化的时候，依赖对应的watcher会通知更新，生成一个新的vnode，新的vnode会去和旧的vnode进行对比更新。 整个更新的过程就是调用path函数，主要做了三件事： 创建节点：新的vnode中有而旧的vnode中的节点，在旧vnode中进行创建 删除节点：新的vnode中没有二旧的vnode中有，在旧的vnode中删除 更新节点：新的vnode和旧的vnode中都有，以新的vnode位主，更新旧的vnode new Vue的流程 合并配置，调用一些初始化函数，触发生命周期钩子函数，调用$mount开启下一个阶段。 keep-live原理 keep-alive是Vue.js的一个内置组件。它能够将不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。 通过include、exclude来匹配和排除缓存，max定义缓存的上限。 keep-alive内部其实是一个函数式组件，没有template标签。在render中通过获取组件的name和include、exclude进行匹配。匹配不成功，则不需要进行缓存，直接返回该组件的Vnode。 匹配成功就进行缓存，获取组件的key在this.cache中进行查找，如果存在就直接将缓存的组件实例覆盖到当前的Vnode上，然后将当前组件的key从keys中进行删除，然后在push(key)添加到尾部，这样做是为了改变key当前的位置，也就实现了max功能。 不存在的话，就需要对组件进行缓存。将当前组件push(key)添加到尾部，然后再判断当前缓存的max是否超出指定个数，如果超出直接将第一个组件销毁（缓存淘汰策略LRU）。 LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 性能优化 网站优化 使用浏览器缓存机制 资源懒加载、预加载 骨架屏 合理使用雪碧图、字体图标、 代码优化 减少回流重绘 减少DOM的操作 节流防抖 使用事件委托 将CSS文件放在头部、js文件放在底部 请求优化 使用CDN加速 开启nginx，Gzip压缩 使用强缓存、协商缓存 减少、合并请求 webpack优化 按需加载 代码打包体积压缩 移除console 压缩图片、字体等本地资源 分离css文件，单独进行打包 浏览器相关 跨域 浏览器的同源策略会导致跨域问题 同源策略 同源指的是：协议、端口号、域名必须一致。 同源策略的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作 解决跨域问题 CORS：服务器开启跨域资源共享 JSONP：利用JavaScript标签不存在跨域限制，只支持GET请求 Nginx：反向代理 本地存储 Cookie 存储小，只有4k 不同域之间不能共享 不安全，容易被拦截 SessionStorage 存储在内存中，体积相对较大 页面关闭，数据会删除 相对Cookie安全 LocalStorage 体积大，可以存储更多内容 生命周期长，需要手动删除 存储在硬盘，不会像cookie一样被请求携带 从输入一个 URL 地址到浏览器完成渲染的整个过程 浏览器输入URL并回车 浏览器查找当前是否有缓存 DNS解析URL得到IP 浏览器DNS缓存 host文件缓存 建立TCP连接（三次握手） 发送HTTP请求 服务器处理请求，浏览器得到响应数据 浏览器解析渲染页面 解析DOM生成DOM树 解析CSS生成CSS树 合并DOM树和CSS树，生成渲染树 浏览器开始渲染页面（回流重绘发生在这个阶段） TCP连接关闭（四次挥手） 网络协议、安全相关 TCP、UDP协议 TCP和UDP都是在传输层定义的两种传输协议。基于UDP协议传输不能保证数据准确无误的送达，但UDP不仅可以支持一对一的传输方式，还可以支持一对一、一对多等形式。也不需要像TCP一样建立连接，所以传输速度快。 TCP的目的是提供可靠的数据，并且需要在传输前建立连接（三次握手）。只支持一对一进行传输。 区别： TCP协议可靠，UDP协议不可靠 TCP面向连接，UDP采用无连接 TCP可以保证数据顺序，UDP不能 TCP一对一传输，UDP可以一对多、多对一等形式 HTTP和HTTPS区别 HTTP是明文传输，不安全。HTTPS基于SSL进行加密传输，比较安全。 HTTPS需要CA证书，HTTP不需要。 HTTP端口为80，HTTPS端口为443 HTTP状态码 1XX: 请求正在处理 2XX：正常状态码 200 ：请求处理成功 201 ： 请求成功并且服务器创建了新资源 202 ：服务器已经接收请求，但尚未处理 3XXX：重定向状态 301 ：请求重定向 302: 临时重定向 303: 临时重定向，使用get请求新的url 304：浏览器缓存相关 4XX：错误状态码 400: 服务器无法理解请求格式，需要修改请求内容后再次发起请求 401: 请求未授权 403: 禁止访问 404: 服务器上无法找到请求资源 5XX：服务器错误 500: 服务端错误 503: 服务器暂时无法处理请求 HTTP三次握手、四次挥手 三次握手 三次握手是在建立TCP连接时，客户端和服务端总共发送三个包。进行三次握手的主要目的就是为了确认双方的接受能力和发送能力都是正常的，为后面传输可靠数据做准备。 报文： 序号：表示发送的数据字节流，确保TCP传输有序，对每个字节编号 确认序号：发送方期待接收的下一序列号，接收成功后的数据字节序列号加 1。只有ACK=1时才有效。 ACK：确认序号的标志，ACK=1表示确认号有效，ACK=0表示报文不含确认序号信息 SYN：连接请求序号标志，用于建立连接，SYN=1表示请求连接 FIN：结束标志，用于释放连接，FIN=1表示关闭本方数据流 三次握手： 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。 务器收到客户端的 SYN 报文之后，会以自己的SYN报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。 客户端收到SYN报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。 四次挥手 客户端会发送一个FIN报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。 如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 客户端收到 FIN 之后，一样发送一个ACK报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 为什么需要四次挥手 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。 HTTP缓存 强缓存 使用强制缓存策略，如果缓存资源有效，就直接使用缓存资源，不需要向服务器发送请求。强制缓存通过两种方式来设置，在request headers中的Expires属性和Cache-Contorl属性。 Expires属性，指定资源的过期时间。在过期时间以内，改资源可以被缓存使用，不需要向浏览器发送请求。这个时间依赖于服务器时间，会存在服务器时间和客户端时间不一致。 Cache-Control属性： private： 仅浏览器可以缓存 public：浏览器和代理服务器都可以缓存 max-age=xxx 过期时间，单位为秒 no-cache 不进行强缓存，但会有协商缓存 no-store 不强缓存，也不协商缓存 如果request header中，Cache- Control的值中有max-age=xxx，这个时候走强缓存。如果值为no-cache，表明没有命中，走协商缓存。如值为no-store，不使用缓存。 协商缓存 如果没有命中强制缓存，在设置协商缓存情况下，先向服务器发送一个请求，如果资源没有发生修改，则返回一个304的状态，让浏览器使用本地的缓存副本。如果资源发生修改，则返回修改后的资源。在request headers中的Etag属性和Last-Modified属性，来进行设置。其中，ETage优先于Last-Modified。 命中协商缓存条件： Cache-Control: no-cache max-age时间过期 Last-Modified（文件的修改时间）： 服务器在响应头中添加Last-Modified属性，来指出资源最后一次修改时间。当浏览器发起请求时，会在request headers中添加一个If-None-Since属性，值为上一次请求的资源返回的Last-Modified值。服务端会通过这个属性和资源最后一次修改时间进行对比，以此来判断资源是否修改。如果资源没有修改，请求返回304状态，客户端使用本地缓存。如果资源有修改，则返回修改的资源。 这种方式有一个缺点，Last-Modified标记的时间只能精确到秒。 ETag（文件改动）： 同样在服务器返回资源的时候，在头信息中添加ETag属性，这个属性是资源的唯一标识符。当资源改变时，这个值也会改变。在一下次请求资源时，会在request headers中添加一个If-None-Match属性，值为上一次请求的资源返回的ETag值。服务端会通过这个属性和资源最后一次修改时间进行对比，以此来判断资源是否修改。这种方式比Last-Modified更加准确。 区别 强缓存优先级高于协商缓存 强缓存不需要发请求，协商缓存需要。 强缓存返回的状态码为200，协商缓存返回304 ctrl+F5强制刷新会跳过所有缓存，而F5刷新跳过强缓存，但是会检查协商缓存。 POST和GET的区别 传递的参数不同，POST传递的参数在request body中，GET传递的参数在url后拼接 POST相对GET请求安全 GET请求长度有限制，POST没有 GET请求会被浏览器主动缓存，POST不会，要手动设置 GET请求一般用于查询，POST一般用于提交某种信息进行某些修改操作 XSS、csrf攻击 XSS（跨站脚本攻击） Xss(cross-site scripting) 是一种代码注入攻击，攻击者往Web页面里插入恶意 html 标签或者 javascript 代码。在骗取用户点击后获取用户，获取用户信息。 避免方式： url参数通过encodeURIComponent方法进行转义 尽量不使用InnerHtml插入HTML内容 对用户输入的地方和变量都需要仔细检查长度和对 ”&lt;”,”&gt;”,”;”,”’” 等字符做过滤 CSRF（跨站请求伪造） CSRF（Cross-site request forgery）攻击者盗用你的身份信息，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 避免方式： 添加验证码验证 使用token 服务端给用户生成一个token，加密后传递给用户 用户在提交请求时，需要携带这个token 服务端验证token是否正确 前端工程化 webpack的loader和plugin的区别 loader loader是导出一个函数的javascript模块，webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。如babel-loader、Css-loader、image-loader、url-loader、Saas-loader… plugin Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。如html-webpack-plugin、mini-css-extract-plugin、uglifyjs-webpack-plugin 手写系列🤮 节流防抖 new操作符 call、bind、apply实现 发布订阅模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class EventEmitter &#123; constructor() &#123; // 事件列表 this.eventList = &#123;&#125;; &#125; // 监听 on(name, callBack) &#123; // 以 name 为 key 创建容器 如果有容器就不用创建 if (!this.eventList[name]) &#123; this.eventList[name] = [] &#125; // 把事件放入容器 this.eventList[name].push([callBack]) &#125;; // 触发 emit(name, data) &#123; if (!this.eventList[name]) &#123; return new Error(&#x27;没有找到事件！&#x27;) &#125;; // 从容器中取出事件进行调用 this.eventList[name].forEach((item) =&gt; &#123; item(data) &#125;) &#125;; // 只触发一次 once(name, callBack) &#123; if (!this.eventList[name]) return; // 利用off 在callBack执行后 关闭订阅 function onceFn(callBack) &#123; callBack(); this.off(name, callBack); &#125;; this.on(name, onceFn) &#125;; // 关闭监听 若第二个参数没有 移除 name 下所有的事件 off(name, callBack) &#123; if (!this.eventList[name]) return; if (callBack) &#123; // 只移除对应的callBack this.eventList[name] = this.eventList[name].filter((item) =&gt; &#123;return item !== callBack&#125;); // name容器长度为0 直接删除整个 name 事件订阅发布 if (this.eventList[name].length === 0) &#123; delete this.eventList[name]; &#125;; &#125; else &#123; // 没有 callBack 直接删除整个 name 事件订阅发布 delete this.eventList[name]; &#125;; &#125;;&#125;; 函数柯里化实现 promise 实现一个队列 数组去重 深浅拷贝 交换两个变量的值 数组扁平化 输出结果 闭包 12345678910var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //&quot;The Window&quot; 1234567891011121314function aaa()&#123; var a=0; function bbb() &#123; a++; alert(a); &#125; return bbb&#125;var ccc=aaa();ccc(); //结果为1ccc(); //结果为2var ddd=aaa();ddd(); //结果为1ddd(); //结果为2 github 同步 参考： 2021」高频前端面试题 2021年我的前端[[…/…/4-前端要努力/前端面试/1、面试准备|面试准备]] 震惊！前端300基础面试题+答案、分类学习整理（良心制作）持续更新 高级知识点","categories":[{"name":"面试","slug":"面试","permalink":"https://wakaka378.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://wakaka378.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"js面向对象—封装","slug":"js面向对象—封装","date":"2020-06-20T13:00:27.000Z","updated":"2023-06-14T13:02:23.956Z","comments":true,"path":"post/20200620210027.html","link":"","permalink":"https://wakaka378.github.io/post/20200620210027.html","excerpt":"","text":"js设计模式(一)面向对象—封装 前言 最近一直在看typescript，主要的一个目的是为vue3.x做准备。3.x版本尤雨溪大神采用typescript重写底层，具体内容可以查看[译] 尤雨溪：Vue 3.0 计划-掘金。在typescript里，几乎完全采用ES6语法，其中最为重要的还是class类的使用，学到这块就有点懵逼了。什么？继承还可以这样玩？什么共有私有什么派生类？？？我之前学了个假js吧？？？ 于是回头来重新梳理学习一下面对对象编程，这一系列文章全部是基于ES5语法规则，别跟我说为啥不直接用ES6,ES6它最终也是编译成ES5运行。 小子只是个前端菜鸟，对编程还没有太深入的了解，只是个代码搬运工。如果文章有什么错误或者是理解上的错误，还请指条明路，感激不尽。 这一系列将以面对对象三个特性封装、继承、多态为题进行讲解，更好的理解面对对象编程。 面对过程编程和面对对象编程(OOP) 面对过程编程 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 面对对象编程 面对对象编程就是将你的需求抽象成一个对象，针对这个对象分析其特征和动作，这个对象我们称之为类 对象基础知识 对象理解 程序员经常会拿对象来开玩笑：没对象？自己new一个呗，要啥样都可以。那到底什么是对象呢？js中有一个说法是万物皆对象，对象就是可以拥有属性和方法的一个集合。人，是一个对象，他有吃饭睡觉的属性，有上班赚钱的方法。所有的一切都可以抽象为一个对象，只不过每个对象都属于自己的属性和方法。 什么叫面对对象编程？？？在js中，有两种编程风格。面对过程编程和面对对象编程，我们写轮播图写动画写页面，大部分都是面对过程编程(反正我个人目前是这样)。 对象三大特征 封装、继承、多态 一个对象被创建，这中间发生什么 | new 关键字做了什么（面试题） 1、创建一个新的对象，这个对象的类型是 `object` 2、设置这个新的对象的内部、可访问性和[[prototype]]属性为构造函数（指prototype.construtor所指向的构造函数）中设置的 3、将步骤1新创建的对象作为this的上下文 4、果该函数没有返回对象，则返回this。 原型和原型链 原型 JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。这个对象的所有属性和方法，都会被构造函数的所拥有。 prototype作为对象的内部属性，我们一般通过实例化对象的__proto__这个属性进行访问。 在原型对象中还有一个属性constructor，这个属性对应创建所有指向该原型的实例的构造函数 原型链 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回null。 1234567891011121314151617181920212223242526function Person(name, age) &#123; this.name = name this.age= age this.action = function () &#123; alert(&#x27;hello word&#x27;) &#125;&#125;var p = new Person(&#x27;尤雨溪&#x27;, 18) // 实例化Person这个对象console.log(p.name) // 尤雨溪/*他们之间的关系 构造函数的原型 == 实例化p.__proto__ 构造函数 == 构造函数原型的constructor*/ console.log(Person.prototype === p.__proto__) // true console.log(Person.prototype.constructor === Person) // trueconsole.log(p.constructor === Person) // true 面对对象—封装 什么是封装 封装就是把客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口。也就是说，封装就是将属性和方法组成一个类的过程就称之为封装。 对象封装的几种形式 对象字面量 优点：代码简单易懂 缺点：创建多个对象会产生大量的代码，编写麻烦，且并没有实例与原型的概念 12345678910111213141516171819202122// 创建对象var Person = &#123; name: &quot;尤雨溪&quot;, age: &quot;18&quot;, action : function() &#123; alert(&#x27;hello word!&#x27;); &#125;&#125;Person.namePerson.action()// 创建一个空对象 给空对象添加方法属性var Person = &#123;&#125;Person.name = &#x27;尤雨溪&#x27;Person.age= 18Person.action = function() &#123; alert(&#x27;hello word!&#x27;);&#125; 工厂模式 对象字面量的形式在创建多个对象的时候会产生大量代码，如果我们把创建新对象、添加对象属性、返回对象的过程放到这个函数中，每次需要创建对象的时候调用函数即可。 1234567891011121314151617function createPerson(name, age) &#123; var person = new Object(); person.name = name; person.age = age; person.action= function() &#123; alert(&#x27;hello word!&#x27;); &#125;; return person;&#125;//生成实例var p = createPerson(&#x27;尤雨溪&#x27;, 18);var p2 = createPerson(&#x27;阮一峰&#x27;,20)console.log(p.name)p.action() 优点：避免创建大量对象时代码的臃肿 缺点： p1与p2之间没有内在联系 构造函数 所谓&quot;构造函数&quot;，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。 12345678910111213function Person(name, age) &#123; // 通过this来添加属性方法 this.name = name this.age = age this.action = function () &#123; alert(&#x27;hello word&#x27;) &#125;&#125;// 实例化对象var p1 = new Person(&#x27;尤雨溪&#x27;, 18)var p2 = new Person(&#x27;阮一峰&#x27;, 20) 上面我们说过，通过new关键字实例化出来的对象，都会有一个constructor属性指向他们的构造函数 12console.log(p1.constructor === Person) // trueconsole.log(p2.constructor === Person) // true 优点：实例化对象和构造函数之间存在关联 缺点：浪费内存，构造函数中定义的方法名action一样，但实例化出来的对象名不一样，造成一个内存的浪费。 原型模式 上面我们说过，每个对象被实例化的时候，都会有一个原型prototype属性，这个属性是可以被其他对象继承的。所以我们可以将对象共有的属性方法，放到原型上，这样每次通过new出来的对象，在构造函数中的方法被多次创建。 12345678910111213141516function Person(name, age) &#123; // 通过this来添加属性方法 this.name = name this.age = age&#125;// 将共同拥有的方法挂在到原型上Person.prototype.action = function () &#123; alert(&#x27;hello wodr&#x27;) &#125;// 实例化对象var p1 = new Person(&#x27;尤雨溪&#x27;, 18)var p2 = new Person(&#x27;阮一峰&#x27;, 20)p1.action()p2.action() 属性和方法的类型 通过原型模式我们可以将方法属性直接放在原型上，所有的实例对象都可以访问这个属性方法，我们称为公有方法/属性。熟悉ES6的朋友知道，在用class定义类的时候，我们可以定义里面属性方法的类型。是保护类型，还是公开类型，还是私有类型，不同类型之间是不能相互访问的。在ES6中我们可以通过public等关键字来定义，那我们ES5是怎样区分他们的一个类型呢？ 我之前在学习面对对象这一块的时候没有太过注意这一块内容，现在我们开发也很少注意到这一块内容。其实在快速开发的时期，我们很少注意到这些javascrip基础理论知识，更缺乏对原生js的理解。 在面向对象中，每个属性都有它的一个类型，可以分为共有、私有、静态三种。 共有属性和方法 从字面量上的意思理解，共有，就是所有对象都有的属性或方法。 123456789101112131415function Person(name, age) &#123; // 通过this来添加属性方法 this.name = name // 共有属性 this.age = age &#125;// 将共同拥有的方法挂在到原型上Person.prototype.action = function () &#123; // 共有方法 console.log(`$&#123;this.name&#125;是干$&#123;this.job&#125;的`)&#125;// 实例化对象var p1 = new Person(&#x27;尤雨溪&#x27;, &#x27;程序员&#x27;)p1.action() 从上面代码可以看出，通过this添加的属性或者在原型上添加的属性和方法都是共有的 调用规则： 调用公有方法，我们必需先实例化对象 私有属性和方法 私有属性的理解可以从函数的作用域出发，函数内部定义的变量在函数外部无法访问。我们看下面栗子 1234567891011121314function Person(name, job) &#123; // 通过this来添加属性方法 var name = name // 私有属性 var job = job function action () &#123; // 私有方法 console.log(`$&#123;name&#125;是干$&#123;job&#125;的`) &#125;&#125;// 实例化对象var p = new Person(&#x27;尤雨溪&#x27;, &#x27;程序员&#x27;)console.log(p.name) // undefinedp.action() // p.action is not a function 报错 当实例化创建对象的时候，通过var定义的局部变量是无法在外界被访问，他只能在构造函数内部进行使用，并且不能通过this访问，我们吧代码变动一下再看。 123456789101112131415161718192021222324function Person(name, job) &#123; // 通过this来添加属性方法 var name = name // 私有属性 var job = job function action1 () &#123; // 私有方法 console.log(`$&#123;name&#125;是干$&#123;job&#125;的`, &#x27;通过this调用&#x27;) &#125; function action2 () &#123; // 私有方法 console.log(`$&#123;name&#125;是干$&#123;job&#125;的`, &#x27;在内部调用&#x27;) &#125; // 这样是不能调用的 this.action1() this.name action()&#125;// 实例化对象var p = new Person(&#x27;尤雨溪&#x27;, &#x27;程序员&#x27;) //尤雨溪是干程序员的 在内部调用 调用规则： 对象的私有方法和属性,外部是不可以访问的，只能在内部使用 特权方法 在函数内部通过this创建的属性和方法，在创建对象时，每个对象自身都会拥有一份并且可以在外部可以访问到。通过this创建的属性可以看作对象的共有属性，而通过this创建的方法不但可以访问这些对象的共有属性方法，还能访问自身的私有属性方法，被称之为特权方法 123456789101112131415function Person(name, job) &#123; // 通过this来添加属性方法 var name = name // 私有属性 this.job = job // 共有属性 this.action = function () &#123; // 特权方法 console.log(`$&#123;name&#125;是干$&#123;this.job&#125;的`) &#125;&#125;// 实例化对象var p = new Person(&#x27;尤雨溪&#x27;, &#x27;程序员&#x27;)console.log(p.name)p.action() // 尤雨溪是干程序员的 调用规则：通过实例化，可以访问共有属性方法和私有属性方法 静态属性和方法 共有属性方法和私有属性方法都用通过new创建对象才能访问，而静态属性方法不需要通过new关键字创建，就可以直接访问。 1234567891011121314151617181920212223function Person(name, job) &#123; var name = name // 私有属性 this.job = job // 共有属性 this.action = function () &#123; // 特权方法 console.log(`$&#123;name&#125;是干$&#123;this.job&#125;的`) &#125;&#125;Person.attr = &#x27;静态属性&#x27;Person.say = function () &#123; console.log(&#x27;大家好，我是静态方法&#x27;)&#125;console.log(Person.attr) // 静态属性Person.say() // 大家好，我是静态方法// 实例化对象var p = new Person(&#x27;尤雨溪&#x27;, &#x27;程序员&#x27;)console.log(p.attr ) // undefinedp.say() // 报错 调用规则：静态方法无需实例化对象，便可以调用，对象实例不能调用对象的静态方法，只能调用实例自身的静态属性和方法。 静态类 前面我们说过，对象创建有好几种形式，那我们通过字面量的形式创建的对象，它的类型时什么呢？对象字面量形式创建的对象添加的方法只能时静态属性和静态方法，而包含静态属性和静态方法的类叫静态类 123456789101112131415161718var person = &#123; name: &quot;尤雨溪&quot;, age: &quot;18&quot;, action : function() &#123; console.log(&#x27;hello word!&#x27;); &#125;&#125;person.attr = &#x27;我是静态属性&#x27;person.say = function () &#123; console.log(&#x27;大家好，我是静态方法&#x27;)&#125;console.log(person.name)person.action()person.attr person.say() 调用规则：不需要通过new创建对象 相关文章 [译] 尤雨溪：Vue 3.0 计划-掘金 js面向过程编程与面向对象编程的区别 JS面向对象编程之封装 Javascript 面向对象(共有方法，私有方法，特权方法，静态属性和方法，静态类)示例讲解","categories":[{"name":"Js","slug":"Js","permalink":"https://wakaka378.github.io/categories/Js/"},{"name":"设计模式","slug":"Js/设计模式","permalink":"https://wakaka378.github.io/categories/Js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Js","slug":"Js","permalink":"https://wakaka378.github.io/tags/Js/"},{"name":"面对对象","slug":"面对对象","permalink":"https://wakaka378.github.io/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"},{"name":"设计模式","slug":"设计模式","permalink":"https://wakaka378.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"vue中使用vue-socket.io","slug":"vue中使用vue-socket-io的一些心得、踩坑记录","date":"2020-06-19T16:00:00.000Z","updated":"2023-06-14T13:01:04.693Z","comments":true,"path":"post/20200620000000.html","link":"","permalink":"https://wakaka378.github.io/post/20200620000000.html","excerpt":"","text":"前言 vue项目中有使用到socket长连接，之前一直都是都是使用vue-socke.iogithub地址，但最近在使用时，出了一些莫名奇妙的bug，也是为此掉了不少头发，最后还是解决了。关于socket相关内容介绍以及使用场景，这里不会做太多介绍（主要是懒），可以翻看其他文章。本文主要介绍如何使用，以及再使用时需要注意一些什么。关于文章中使用的代码，我放上github地址。 安装 这里我们安装vue.socket.io模块和socket.io-client模块，也可以不用socket.io-client模块。 12345cnpm i vue-socket.io -Scnpm i socket.io-client -Syarn vue-socket.ioyarn i socket.io-client vue 客户端使用 使用socket.io-client连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import VueSocketIO from &#x27;vue-socket.io&#x27;import SocketIO from &quot;socket.io-client&quot;Vue.config.productionTip = false// socket 连接参数const socketOptions = &#123; autoConnect: false, // 自动连接 这里为我项目需求 需要在指定情况下才连接socket&#125;// 注册Vue.use( new VueSocketIO(&#123; debug: true , // debug调试，生产建议关闭 connection: SocketIO(&quot;127.0.0.1:1024&quot;, socketOptions), store, // 如果没有使用到store可以不用写 &#125;))new Vue(&#123; // 这里为全局监听socket事件消息，监听函数这里只写了一点，其实很有很多事件。 sockets: &#123; connecting() &#123; console.log(&#x27;正在连接&#x27;) &#125;, disconnect() &#123; console.log(&quot;Socket 断开&quot;); &#125;, connect_failed() &#123; cosnole.log(&#x27;连接失败&#x27;) &#125;, connect() &#123; console.log(&#x27;socket connected&#x27;) &#125; &#125;, router, store, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 字符串连接 如果是正常使用，项目启动就连接socket，可以不需要加载socket.io-client模块，直接使用。 12345678// 注册Vue.use( new VueSocketIO(&#123; debug: true , // debug调试，生产建议关闭 connection: 127.0.0.1:1024, store, // 如果没有使用到store可以不用写 &#125;)) 组件中使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;nav&quot;&gt; &lt;button @click=&quot;connect&quot;&gt;连接socket&lt;/button&gt; &lt;button @click=&quot;sendMessage&quot;&gt;发送数据&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; &#125; &#125;, methods:&#123; // 连接socket connect() &#123; this.$socket.open() // 开始连接socket // 订阅事件 this.sockets.subscribe(&#x27;welcome&#x27;, data =&gt; &#123; console.log(&#x27;welcome data &#x27;, data) &#125;) &#125;, // 发送消息 sendMessage() &#123; this.$socket.emit(&#x27;hello&#x27;, &#x27;这里是客户端&#x27;) &#125; &#125;, sockets:&#123; // welcome: data =&gt; &#123; console.log(&#x27;welcome data &#x27;, data) &#125; &#125;&#125;&lt;/script&gt; 客户端使用总结 客户端自带监听事件 connect：连接成功 connecting：正在连接 disconnect：断开连接 connect_failed：连接失败 error：错误发生，并且无法被其他事件类型所处理 reconnect_failed：重连失败 reconnect：成功重连 reconnecting：正在重连 监听自定义事件 全局监听 12345sockets:&#123; welcome: data =&gt; &#123; console.log(&#x27;welcome data&#x27;, data) &#125;&#125; 组件内监听 123this.sockets.subscribe(&#x27;welcome&#x27;, data =&gt; &#123; console.log(&#x27;welcome&#x27;, data)&#125;) 发送消息 注意：监听用的是this.sockets，发送消息是this.$socket，不要弄混。 1this.$socket.emit(&#x27;hello&#x27;, &#x27;这里是客户端&#x27;) 关于跨域问题 socket会存在跨域问题，之前看文章又说到在vue.config.js中配置代理，差不多和后台接口代理配置一样，但我试过好像没啥鸟用，如果有知道的同学麻烦留言告诉一声，实际项目中的解决方式还是后端配置跨域问题。 服务端使用 这里为啥要讲服务端使用，主要是为了让同学更好的体验socket，其次是为了引出后面的bug，也是一个扩展知识把，是不是觉得自己赚了😄。本地开启socket服务可以更好的进行调试。服务端主要还是使用node，毕竟咱也不会java、python…，这里以及配置了socket跨域。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* * @Descripttion: * @version: * @Author: fanliu * @Date: 2020-06-19 18:22 * @LastEditors: fanliu * @LastEditTime: 2020-06-19 18:30 */var http = require(&#x27;http&#x27;);var io = require(&#x27;socket.io&#x27;);// 创建server服务var server = http.createServer(function (req, res) &#123; var headers = &#123;&#125;; headers[&quot;Access-Control-Allow-Origin&quot;] = &quot;*&quot;; headers[&quot;Access-Control-Allow-Methods&quot;] = &quot;POST, GET, PUT, DELETE, OPTIONS&quot;; headers[&quot;Access-Control-Allow-Credentials&quot;] = true; headers[&quot;Access-Control-Max-Age&quot;] = &#x27;86400&#x27;; // 24 hours headers[&quot;Access-Control-Allow-Headers&quot;] = &quot;X-Requested-With, Access-Control-Allow-Origin, X-HTTP-Method-Override, Content-Type, Authorization, Accept&quot;; res.writeHead(200, headers); res.end();&#125;);// 启动服务器 监听 1024 端口server.listen(1024,function() &#123; console.log(&#x27;server runing at 127.0.0.1:1024&#x27;)&#125;)// 启动socket服务var socket = io.listen(server, &#123;origins: &#x27;*:*&#x27;&#125;);// 监听客户端连接socket.on(&#x27;connection&#x27;,function(socket) &#123; console.log(&#x27;客户端有连接&#x27;) // 监听客户端断开 socket.on(&#x27;disconnect&#x27;, () =&gt; &#123; console.log(&#x27;客户端断开&#x27;) &#125;) // 给客户端发送消息 socket.emit(&#x27;welcome&#x27;,&#x27;欢迎连接socket&#x27;) // 监听客户端消息 socket.on(&#x27;hello&#x27;, data =&gt; &#123; console.log(&#x27;接收客户端发送数据&#x27;, data) &#125;)&#125;); 服务端总结 服务端接收和发送消息和客户端对调的，客户端emit发送消息，那么服务端这里就要on监听客户端发送的消息，服务的发送同理。 踩坑 订阅事件记得要取消 socket主要还是用来写聊天室，加入socket房间后要订阅房间内所有的聊天内容，这时如果没有取消之前的订阅事件，下次进入会多次订阅消息。也就是别人只发一条消息，你这边接收到的却是两条甚至多条。哪如何取消订阅呢，我的处理方式是在离开当前聊天页面后，自动取消之前所有的订阅事件。 123beforeDestroy() &#123; this.sockets.unsubscribe(eventName)&#125; 同理，如果是有指定页面才加入socket房间，退出页面时也要记得关闭socket连接。比如你在created中开始连接socket，在beforeDestroy要记得关闭socket，不然下次进入也会连接socket。 12345678created() &#123; this.$socket.open() // 查看socket是否连接成功 this.$socket.connected&#125;beforeDestroy() &#123; this.$socket.close()&#125; Type Error: this.sockets.subscribe is not a function 这是我最近遇到的问题，原本以为是自己的this指向有问题，然后从到尾查遍了整个逻辑this，发现并不是这个问题。 在打印this.sockets之后我发现问题 subscribe订阅事件并没有直接存在，而是某个对象的属性，于是尝试了一下this.sockets.listenner.subscribe发现能用了。 你以为这就结束了？？？接着我又发现问题 1234567sockets:&#123; welcome: data =&gt; &#123; console.log(&#x27;welcome data &#x27;, data) &#125;&#125; 并且订阅的事件中，socket日志显示component: undefined没有看到数据 全局的订阅事件没有生效，并且socket自带的连接事件也没有启动打印。我直接傻了😢，之前使用的时候还没有这些问题，百度一大堆无果后，开始像官方求助。于是找到了问题。 Vue-Socket.io: #connect subscribe, component: undefined 大概的意思是说，出现问题的都是3.0.9的版本，将版本后可以解决这个问题。这也是我为啥要把socket服务端写进了的原因。自己本地写了一个小demo后，还真的是版本的问题，随后就有了这篇文章。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/tags/Vue/"},{"name":"socket.io","slug":"socket-io","permalink":"https://wakaka378.github.io/tags/socket-io/"}]}],"categories":[{"name":"Git","slug":"Git","permalink":"https://wakaka378.github.io/categories/Git/"},{"name":"工程化","slug":"Git/工程化","permalink":"https://wakaka378.github.io/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"npm","slug":"Git/工程化/npm","permalink":"https://wakaka378.github.io/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/npm/"},{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/categories/Vue/"},{"name":"工程化，prettier","slug":"Vue/工程化，prettier","permalink":"https://wakaka378.github.io/categories/Vue/%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%8Cprettier/"},{"name":"Js","slug":"Js","permalink":"https://wakaka378.github.io/categories/Js/"},{"name":"数据结构","slug":"Js/数据结构","permalink":"https://wakaka378.github.io/categories/Js/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DeBug","slug":"Git/DeBug","permalink":"https://wakaka378.github.io/categories/Git/DeBug/"},{"name":"总结","slug":"总结","permalink":"https://wakaka378.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"Github","slug":"Github","permalink":"https://wakaka378.github.io/categories/Github/"},{"name":"工具","slug":"Github/工具","permalink":"https://wakaka378.github.io/categories/Github/%E5%B7%A5%E5%85%B7/"},{"name":"Node","slug":"Github/工具/Node","permalink":"https://wakaka378.github.io/categories/Github/%E5%B7%A5%E5%85%B7/Node/"},{"name":"面试","slug":"面试","permalink":"https://wakaka378.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"设计模式","slug":"Js/设计模式","permalink":"https://wakaka378.github.io/categories/Js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://wakaka378.github.io/tags/npm/"},{"name":"工程化","slug":"工程化","permalink":"https://wakaka378.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"Vue3","slug":"Vue3","permalink":"https://wakaka378.github.io/tags/Vue3/"},{"name":"vue@cli","slug":"vue-cli","permalink":"https://wakaka378.github.io/tags/vue-cli/"},{"name":"prettier","slug":"prettier","permalink":"https://wakaka378.github.io/tags/prettier/"},{"name":"Js","slug":"Js","permalink":"https://wakaka378.github.io/tags/Js/"},{"name":"性能优化","slug":"性能优化","permalink":"https://wakaka378.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"节流防抖","slug":"节流防抖","permalink":"https://wakaka378.github.io/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"},{"name":"Git","slug":"Git","permalink":"https://wakaka378.github.io/tags/Git/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wakaka378.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"队列","permalink":"https://wakaka378.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"DeBug","slug":"DeBug","permalink":"https://wakaka378.github.io/tags/DeBug/"},{"name":"总结","slug":"总结","permalink":"https://wakaka378.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"Github","slug":"Github","permalink":"https://wakaka378.github.io/tags/Github/"},{"name":"工具","slug":"工具","permalink":"https://wakaka378.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Node","slug":"Node","permalink":"https://wakaka378.github.io/tags/Node/"},{"name":"面试","slug":"面试","permalink":"https://wakaka378.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"面对对象","slug":"面对对象","permalink":"https://wakaka378.github.io/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"},{"name":"设计模式","slug":"设计模式","permalink":"https://wakaka378.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/tags/Vue/"},{"name":"socket.io","slug":"socket-io","permalink":"https://wakaka378.github.io/tags/socket-io/"}]}