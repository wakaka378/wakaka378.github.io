{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://wakaka378.github.io","root":"/"},"pages":[{"title":"Repositories","date":"2023-04-09T10:54:23.884Z","updated":"2023-04-09T10:54:23.884Z","comments":false,"path":"repository/index.html","permalink":"https://wakaka378.github.io/repository/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2023-04-09T10:55:30.353Z","updated":"2023-04-09T10:55:30.352Z","comments":false,"path":"/404.html","permalink":"https://wakaka378.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2023-04-09T10:55:30.456Z","updated":"2023-04-09T10:55:30.456Z","comments":false,"path":"categories/index.html","permalink":"https://wakaka378.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-04-09T10:55:30.431Z","updated":"2023-04-09T10:55:30.431Z","comments":false,"path":"books/index.html","permalink":"https://wakaka378.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-04-09T10:55:30.487Z","updated":"2023-04-09T10:55:30.487Z","comments":true,"path":"links/index.html","permalink":"https://wakaka378.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-04-09T10:55:30.400Z","updated":"2023-04-09T10:55:30.400Z","comments":false,"path":"about/index.html","permalink":"https://wakaka378.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2023-04-09T10:55:30.548Z","updated":"2023-04-09T10:55:30.548Z","comments":false,"path":"tags/index.html","permalink":"https://wakaka378.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"release-it 自动发包","slug":"源码共读计划——【release-it-自动发包】","date":"2023-06-11T10:56:36.000Z","updated":"2023-06-13T11:15:56.533Z","comments":true,"path":"2023-06-11-源码共读计划——【release-it-自动发包】.html","link":"","permalink":"https://wakaka378.github.io/2023-06-11-%E6%BA%90%E7%A0%81%E5%85%B1%E8%AF%BB%E8%AE%A1%E5%88%92%E2%80%94%E2%80%94%E3%80%90release-it-%E8%87%AA%E5%8A%A8%E5%8F%91%E5%8C%85%E3%80%91.html","excerpt":"","text":"前言 作为一名合格的前(摸鱼)工程师，日常工作开发中或多或少都要和npm包打交道。之前工作中就有过发布npm包的经历，但那时年少无知，只知道无脑通过npm publish发包，也没有打 tag、版本、没生成 changelog的概念。直到看到源码共读中有自动发包章节，还可以自动打tag等功能，赶紧收藏学习起来。 前置准备 要在npm上发包，当然需要在npm上注册账号，这个就不再赘述。我们在注册完账号之后，先设置一下镜像源，再登录自己的npm账号。如果有同学和我一样，使用的是公司内部私有的npm服务器，使用的账号和镜像源都是公司提供的，不要弄混淆，下面我们开始具体步骤。 准备项目文件 首先创建一个文件夹，然后执行npm init -y 初始化我们的项目 设置镜像源 如果是在已有项目中接入，最好要查看一下当前项目镜像源，初始化项目可以跳过。 那为什么要设置镜像源呢？装过npm包的同学都知道，npm官方public仓库是部署在国外，使用官方镜像源装包速度很慢，所以我们有时候会将镜像源设置为https://registry.npm.taobao.org，也就是淘宝镜像。这个时候如果我们使用npm的账号是无法登录的，或者是说你把镜像设置为公司内部私有的镜像源，这个时候通过官方npm账号也是无法登录的，曾经我就在这里踩过坑。在哪注册的账号，需要将镜像源设置为注册地的仓库。这里我们使用npm官方镜像源，将镜像源设置为https://registry.npmjs.org 12345# 查看当前镜像源npm config get registry # 设置镜像源npm set registry https://registry.npmjs.org 另外一种设置镜像源方式，可以在项目根目录中新建.npmrc文件 1registry = https://registry.npmjs.org/ 登录npm 使用npm注册的账号密码登录 1234567891011# 登录npm login➜ npm loginUsername: 用户名Password: 密码Email: 注册邮箱Enter one-time password: 一次性密码 邮箱会收到邮件➜ npm whoami # 查看当前登录账号名称 自动发包 release-it 官网仓库 release-it它做了什么？ 同步提交git远端内容 更新版本号 产出changelog 提交变动 增加git tag 推送tag更新至远端 我们可以通过--dry-run可以看到具体进行了哪些操作 自动发包 安装 12345➜ npm init release-itnpx: 30 安装成功，用时 5.813 秒? Where to add the release-it config? ›❯ .release-it.json package.json or 1➜ npm install -D release-it 添加命令 123&quot;scripts&quot;: &#123; &quot;release&quot;: &quot;release-it&quot; &#125;, 配置 在项目根目录创建文件 .release-it.json .release-it.js .release-it.yaml .release-it.toml 或者是在pakcage.json文件中添加release-it属性，这里我就直接创建.release-it.json文件，添加以下配置或者可以查看 更多配置 123456789101112131415&#123; &quot;github&quot;: &#123; &quot;release&quot;: true &#125;, &quot;git&quot;: &#123; &quot;commitMessage&quot;: &quot;release: v$&#123;version&#125;&quot; &#125;, &quot;npm&quot;: &#123; &quot;publish&quot;: true &#125;, &quot;hooks&quot;: &#123; &quot;after:bump&quot;: &quot;echo 更新版本成功&quot; &#125;,&#125; 生成CHANGELOG 安装插件 1➜ npm i @release-it/conventional-changelog -D 然后将以下内容添加到.release-it.json文件中 12345678&#123; &quot;plugins&quot;: &#123; &quot;@release-it/conventional-changelog&quot;: &#123; &quot;preset&quot;: &quot;angular&quot;, &quot;infile&quot;: &quot;CHANGELOG.md&quot; &#125; &#125; 自动发布 运行命令，就可以进行发布 123➜ npm run release# or➜ npx release-it 将release-it参数放在--后面 1npm run release --minor --ci 发布其他版本 npm版本号 这里先初步补充一下npm版本号相关知识，npm的版本号遵循SemVer 规范，版本号格式必须采用X.Y.Z的格式，其中 X、Y 和 Z 为非负的整数。X 是主版本号、Y 是次版本号、而 Z 为修订号，英文对应表示为 major、minor、patch，每个号必须采用递增。 12X.Y.Z ===&gt; &#123;major&#125;.&#123;minor&#125;.&#123;patch&#125;2.4.1 这种格式都是正式版，而在正式版发布之前还会经历各种先行版本，先行版本号会在原有的基础上增加一个版本号标签，先行版本格式是在修订版本patch号后面加上一个-连接，再通过.进行分割 12# 格式major.minor.patch-&#123;identifier&#125;.&#123;identifier&#125;.&#123;identifier&#125; 通常第一个 identifier 为版本号标签，后面则是自增版本号。 常用的版本号标签有 alpha内部测试版 beta公开测试版 rc候选版本 发布先行版本 理解完npm版本号相关知识后，那如何发布alpha、beta、rc版本呢？ 我们可以看一下pre-releases ，就是通过不同的命令去创建发布不同的版本，比如我现在需要发布beta版本，就可以执行一下命令。 12345678➜ npx release-it major --preRelease=beta# 实际执行了三步# 1.版本号从 0.2.0 更新至 1.0.0-beta.0# 2.npm发布版本会打上beta标签，可以通过 npm i xxxx@beta 安装# 3.github release会打上pre-release标识# 综合起来就是release-it premajor --preReleaseId=beta --npm.tag=beta --github.preRelease beta可以换成&quot;alpha&quot;, &quot;beta&quot;, &quot;rc&quot; major可以替换成major、minor、patch 预发布版本在更改的过程中，原有的先行版本号会清零。比如我从1.2.1-alpha.4升级到beta版本，就会变成1.2.1-beta.0 升级版本时，会将预发布版本清空，此时版本号不会变动。比如我上一个版本是3.0.0-rc.2，当我直接升级patch号就会变成3.0.0 升级当前预发布版本 1➜ npx release-it --preRelease 将alpha版本修改为beta版本 1➜ npx release-it --preRelease=beta 升级major、minor、patch版本号 1➜ npx release-it major/minor/patch 当我们发布完后，需要使用到预发布版本依赖事，安装包的时候包名后面要带上@beta或者是其他版本 1npm install release-it-test-wakaka@beta -D 我们也可以将命令拆分开来使用 12345678# 只响应package.json中的版本号$ npx release-it major --preReleaseId=beta# 设置npm发版时的标识为beta$ npx release-it major --npm.tag=beta# 设置github release为预发布$ npx release-it major --github.preRelease 查看包 我们发布完之后，如何查看自己是否发布成功呢？有以下几种方式 npm官网查看 可以在npm官网上直接搜索包的名字，或者是登录账号后在packages中查看自己发布的包 在versions中可以看到历史的版本 使用npm view命令 123456789101112131415# 查看某个 package 的注册信息npm view &lt;package-name&gt;# 查看某个 package 的最新版本npm view &lt;package-name&gt; version# 查看某个 package 在 npm 服务器上所发布过的版本npm view &lt;package-name&gt; versions# 查看仓库依赖树上所有包的版本信息npm ls 直接安装 简单粗暴，直接通过npm install &lt;package-name&gt;安装一下包，如果发布成功，安装时最好另起项目，不要在当前包项目中安装。 踩坑 包名重复 发包前，最好确认一下包名有没有重复，如果包名重复是无法发布的。校验包名最简单的办法就是去npm官网上搜你需要发布的名字，如果有就需要换一个名字，没有就可以发布。 错误的包名，无法发布 修改后，发布成功 没有git仓库提交代码 在安装完@release-it/conventional-changelog后，如果没有在git远程仓库提交代码，也是会发布失败 添加远程仓库后 当我们改完代码后，需要进行提交。 123git add .git commit -m &#x27;xxxxx&#x27;git push changelog文件没有commit信息 为什么我提交了commit，但是生成的changelog中没有commit信息？ 这是因为提交的commit信息不符合angular规范，在.release-it.json文件中我们可以看到 12345678... &quot;plugins&quot;: &#123; &quot;@release-it/conventional-changelog&quot;: &#123; &quot;preset&quot;: &quot;angular&quot;, &quot;infile&quot;: &quot;CHANGELOG.md&quot; &#125; &#125;... 只要提交的规范符合angular规范，就可以了。 约定式提交 Angular提交信息规范 @release-it/conventional-changelog 总结 release-it使用下来，发现它帮我们节省了很多时间，整体发包流程都很规范。之前工作中进行发包的时候，直接一个npm publish就完事，也没有考虑到打tag、生成changelog这些事情。还有更多扩展性功能等待发现，比如配合上commitizen等工具，自定义commit信息，让changelog内容更丰富。配合git hooks，执行其他的一些操作。 同类型的产品还有standard-version，也是提供自动化发包流程，但整体来说还是release-it更灵活一些。 参考文章 package.json 配置完全解读 图文结合简单易学的npm 包的发布流程 聊聊 npm 的语义化版本（Semver） 自动产出changelog-第二节：自动产出","categories":[{"name":"Git","slug":"Git","permalink":"https://wakaka378.github.io/categories/Git/"},{"name":"工程化","slug":"Git/工程化","permalink":"https://wakaka378.github.io/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"npm","slug":"Git/工程化/npm","permalink":"https://wakaka378.github.io/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/npm/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://wakaka378.github.io/tags/npm/"},{"name":"工程化","slug":"工程化","permalink":"https://wakaka378.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"防抖debounce理解","slug":"防抖debounce理解","date":"2023-04-09T13:54:09.000Z","updated":"2023-04-18T12:13:20.878Z","comments":true,"path":"2023-04-09-防抖debounce理解.html","link":"","permalink":"https://wakaka378.github.io/2023-04-09-%E9%98%B2%E6%8A%96debounce%E7%90%86%E8%A7%A3.html","excerpt":"","text":"「我正在参与掘金会员专属活动-源码共读第一期，点击参与」 前言 防抖相信大家都不陌生，面试中会经常会被问题或提起。比如会问一些前端优化、手写防抖节流函数等等，这里就跟着underscore 源码来学习一下。 定义 在规定时间后才执行，如果触发则重新计时 也就是说，防抖函数在n秒内，无论触发了多少次函数回调，我都只只在n秒后执行一次。比如我们设置一个等待时间为5秒的防抖函数，如果5秒内有触发，就需要重新计时，直到5秒内没有触发就调用执行。 使用场景 最近项目中有一个表单搜索场景，在输入文字的过程中会持续触发oninput事件，而搜索接口只是在用户输入搜索文字后进行调用。如果是用户输入一个文字就搜索一次，不仅会频繁调用后台接口，前端显示效果也不好。 使用防抖的话，可以将接口调用设定在500ms内没有触发oninput事件后再调用接口，这样就可以解决问题。 还会在其他场景使用 一些频繁点击操作的按钮，比如登录、短信验证，避免用户短时间多次发送 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖 鼠标移动mousedown计算等场景 实现原理 实现原理其实很简单，就是利用定时器，函数在最开始执行的时候就设定一个定时器，如果在n秒内有执行就吧定时器清空，重新设定一个新的定时器，当n秒内没有再调用后，定时器计时结束后就会触发回调。 第一版 123456789101112131415161718192021/*** debounce防抖* @param &#123; function &#125; fn 回调* @param &#123; number &#125; wait 等待时间*/function debounce(fn, wait = 300) &#123; // 利用闭包生成唯一的一个定时器 let timer = null; // 返回一个函数，当作触发事件执行 return function (...args) &#123; if (timer) &#123; // 上一次存在定时器，需要清空 clearTimeout(timer); &#125; // 设定定时器，定时器结束后执行回调函数 fn 如果多次触发就重新设定 timer = setTimeout(() =&gt; &#123; fn.apply(this, args); &#125;, wait); &#125;;&#125; 我们再写一个输入框事件来测试一下 123456789101112131415161718&lt;input type=&quot;text&quot; oninput=&quot;oninputHandler(event)&quot; /&gt;&lt;script&gt; const testFn = debounce((event) =&gt; &#123; console.log(&#x27;执行防抖&#x27;, event.target.value); &#125;, 1000); // 执行防抖 停止 scroll 事件后 1 秒执行回调 function oninputHandler(event) &#123; testFn(event); &#125; // 不执行防抖 function oninputHandler(event) &#123; console.log(&#x27;input change value: &#x27; + event.target.value); &#125;&lt;/script&gt; 这是没有执行防抖 开启防抖后 效果还是很明显的，从原来的输入一个值就触发，到现在1秒内没有输入才触发，至此，简单版防抖就已经实现了。 第二版 接下来再来对防抖做一下改造，在首次调用的时候立即执行函数，等到n秒内没有触发，才可以重新触发执行。 听起来有点绕，也就是说在oninput事件第一次触发的时候就执行，后续的触发都不执行。等到1秒内没有执行后，再触发oninput时又会执行第一次。 1234567891011121314151617181920212223242526272829303132333435363738/*** debounce防抖* @param &#123; function &#125; fn 回调* @param &#123; number &#125; wait 等待时间* @param &#123; boolean &#125; immediate 是否立即执行*/function debounce(fn, wait = 300, immediate = false) &#123; // 利用闭包生成唯一的一个定时器 let timer = null; // 返回一个函数，当作触发事件执行 return function (...args) &#123; if (timer) &#123; // 上一次存在定时器，需要清空 clearTimeout(timer); &#125; // immediate: true 时，首次触发后立即执行 if (immediate) &#123; // 是否首次执行过 const isExecute = !timer; // 赋值定时器 避免重复执行 timer = setTimeout(() =&gt; &#123; timer = null; &#125;, wait); // 首次执行 isExecute &amp;&amp; fn.apply(this, args); &#125; else &#123; // 设定定时器，定时器结束后执行回调函数 fn 如果多次触发就重新设定 timer = setTimeout(() =&gt; &#123; fn.apply(this, args); &#125;, wait); &#125; &#125;;&#125; underscore 源码 来看一下underscore里是如何实现的，先将核心代码复制出来，用上面的oninput事件来调试，看一下它的一个具体步骤。 在debounced方法内部打上一个断点，然后在输入框输入数据触发防抖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function debounce(func, wait, immediate) &#123; var timeout, previous, args, result, context; var later = function () &#123; // now获取的是当前时间 previous 会在第一次进入的时候记录 对比两个时间差是否小于 wait 等待时间 var passed = now() - previous; if (wait &gt; passed) &#123; // 小于等待时间 说明在 wait时间内有触发 重新设定定时器 timeout = setTimeout(later, wait - passed); &#125; else &#123; // 超过等待时间 执行回调 // 清空 timeout 避免影响到下次使用 timeout = null; // 判断是否立即执行 if (!immediate) result = func.apply(context, args); // This check is needed because `func` can recursively invoke `debounced`. // 清空上下文、arguments 参数 在回调里面嵌套使用 if (!timeout) args = context = null; &#125; &#125;; // 先执行这里 通过 restArguments 将处理结果当作函数进行返回 回调时传递 arguments 参数 var debounced = restArguments(function (_args) &#123; context = this; args = _args; // 触发一次记录时间 用来和等待时间对比 previous = now(); if (!timeout) &#123; // 第一次进入时执行 // 执行 later 函数 timeout = setTimeout(later, wait); // 立即执行 if (immediate) result = func.apply(context, args); &#125; return result; &#125;); // 取消执行 清空定时器等参数 debounced.cancel = function () &#123; clearTimeout(timeout); timeout = args = context = null; &#125;; return debounced;&#125; 源码还是有很多亮点的 增加了cancel方法，可以随时取消。 在执行回调的时候，吧函数结果当作返回值return出去，是为了避免回调中有返回数据。 通过记录每次执行时间差，来判断是否需要执行回调。","categories":[{"name":"js","slug":"js","permalink":"https://wakaka378.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wakaka378.github.io/tags/js/"},{"name":"性能优化","slug":"性能优化","permalink":"https://wakaka378.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"节流防抖","slug":"节流防抖","permalink":"https://wakaka378.github.io/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"}]},{"title":"vue中使用vue-socket.io的一些心得、踩坑记录","slug":"vue中使用vue-socket-io的一些心得、踩坑记录","date":"2023-04-09T11:56:28.000Z","updated":"2023-04-09T12:35:17.795Z","comments":true,"path":"2023-04-09-vue中使用vue-socket-io的一些心得、踩坑记录.html","link":"","permalink":"https://wakaka378.github.io/2023-04-09-vue%E4%B8%AD%E4%BD%BF%E7%94%A8vue-socket-io%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E3%80%81%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html","excerpt":"","text":"前言 vue项目中有使用到socket长连接，之前一直都是都是使用vue-socke.io[github地址]，但最近在使用时，出了一些莫名奇妙的bug，也是为此掉了不少头发，最后还是解决了。关于socket相关内容介绍以及使用场景，这里不会做太多介绍（主要是懒），可以翻看其他文章。本文主要介绍如何使用，以及再使用时需要注意一些什么。关于文章中使用的代码，我放上github地址。前端小鸟一枚，立誓要成为前端菜鸟，不足地方留言指出，小子谢过。 安装 这里我们安装vue.socket.io模块和socket.io-client模块，也可以不用socket.io-client模块，请往下看。 12345cnpm i vue-socket.io -Scnpm i socket.io-client -Syarn vue-socket.ioyarn i socket.io-client vue 客户端使用 使用socket.io-client连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import VueSocketIO from &#x27;vue-socket.io&#x27;import SocketIO from &quot;socket.io-client&quot;Vue.config.productionTip = false// socket 连接参数const socketOptions = &#123; autoConnect: false, // 自动连接 这里为我项目需求 需要在指定情况下才连接socket&#125;// 注册Vue.use( new VueSocketIO(&#123; debug: true , // debug调试，生产建议关闭 connection: SocketIO(&quot;127.0.0.1:1024&quot;, socketOptions), store, // 如果没有使用到store可以不用写 &#125;))new Vue(&#123; // 这里为全局监听socket事件消息，监听函数这里只写了一点，其实很有很多事件。 sockets: &#123; connecting() &#123; console.log(&#x27;正在连接&#x27;) &#125;, disconnect() &#123; console.log(&quot;Socket 断开&quot;); &#125;, connect_failed() &#123; cosnole.log(&#x27;连接失败&#x27;) &#125;, connect() &#123; console.log(&#x27;socket connected&#x27;) &#125; &#125;, router, store, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 字符串连接 如果是正常使用，项目启动就连接socket，可以不需要加载socket.io-client模块，直接使用。 12345678// 注册Vue.use( new VueSocketIO(&#123; debug: true , // debug调试，生产建议关闭 connection: 127.0.0.1:1024, store, // 如果没有使用到store可以不用写 &#125;)) 组件中使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;nav&quot;&gt; &lt;button @click=&quot;connect&quot;&gt;连接socket&lt;/button&gt; &lt;button @click=&quot;sendMessage&quot;&gt;发送数据&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; &#125; &#125;, methods:&#123; // 连接socket connect() &#123; this.$socket.open() // 开始连接socket // 订阅事件 this.sockets.subscribe(&#x27;welcome&#x27;, data =&gt; &#123; console.log(&#x27;welcome data &#x27;, data) &#125;) &#125;, // 发送消息 sendMessage() &#123; this.$socket.emit(&#x27;hello&#x27;, &#x27;这里是客户端&#x27;) &#125; &#125;, sockets:&#123; // welcome: data =&gt; &#123; console.log(&#x27;welcome data &#x27;, data) &#125; &#125;&#125;&lt;/script&gt; 客户端使用总结 客户端自带监听事件 connect：连接成功 connecting：正在连接 disconnect：断开连接 connect_failed：连接失败 error：错误发生，并且无法被其他事件类型所处理 reconnect_failed：重连失败 reconnect：成功重连 reconnecting：正在重连 监听自定义事件 全局监听 12345sockets:&#123; welcome: data =&gt; &#123; console.log(&#x27;welcome data&#x27;, data) &#125;&#125; 组件内监听 123this.sockets.subscribe(&#x27;welcome&#x27;, data =&gt; &#123; console.log(&#x27;welcome&#x27;, data)&#125;) 发送消息 注意：监听用的是this.sockets，发送消息是this.$socket，不要弄混。 1this.$socket.emit(&#x27;hello&#x27;, &#x27;这里是客户端&#x27;) 关于跨域问题 socket会存在跨域问题，之前看文章又说到在vue.config.js中配置代理，差不多和后台接口代理配置一样，但我试过好像没啥鸟用，如果有知道的同学麻烦留言告诉一声，实际项目中的解决方式还是后端配置跨域问题。 服务端使用 这里为啥要讲服务端使用，主要是为了让同学更好的体验socket，其次是为了引出后面的bug，也是一个扩展知识把，是不是觉得自己赚了😄。本地开启socket服务可以更好的进行调试。服务端主要还是使用node，毕竟咱也不会java、python…，这里以及配置了socket跨域。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* * @Descripttion: * @version: * @Author: fanliu * @Date: 2020-06-19 18:22 * @LastEditors: fanliu * @LastEditTime: 2020-06-19 18:30 */var http = require(&#x27;http&#x27;);var io = require(&#x27;socket.io&#x27;);// 创建server服务var server = http.createServer(function (req, res) &#123; var headers = &#123;&#125;; headers[&quot;Access-Control-Allow-Origin&quot;] = &quot;*&quot;; headers[&quot;Access-Control-Allow-Methods&quot;] = &quot;POST, GET, PUT, DELETE, OPTIONS&quot;; headers[&quot;Access-Control-Allow-Credentials&quot;] = true; headers[&quot;Access-Control-Max-Age&quot;] = &#x27;86400&#x27;; // 24 hours headers[&quot;Access-Control-Allow-Headers&quot;] = &quot;X-Requested-With, Access-Control-Allow-Origin, X-HTTP-Method-Override, Content-Type, Authorization, Accept&quot;; res.writeHead(200, headers); res.end();&#125;);// 启动服务器 监听 1024 端口server.listen(1024,function() &#123; console.log(&#x27;server runing at 127.0.0.1:1024&#x27;)&#125;)// 启动socket服务var socket = io.listen(server, &#123;origins: &#x27;*:*&#x27;&#125;);// 监听客户端连接socket.on(&#x27;connection&#x27;,function(socket) &#123; console.log(&#x27;客户端有连接&#x27;) // 监听客户端断开 socket.on(&#x27;disconnect&#x27;, () =&gt; &#123; console.log(&#x27;客户端断开&#x27;) &#125;) // 给客户端发送消息 socket.emit(&#x27;welcome&#x27;,&#x27;欢迎连接socket&#x27;) // 监听客户端消息 socket.on(&#x27;hello&#x27;, data =&gt; &#123; console.log(&#x27;接收客户端发送数据&#x27;, data) &#125;)&#125;); 服务端总结 服务端接收和发送消息和客户端对调的，客户端emit发送消息，那么服务端这里就要on监听客户端发送的消息，服务的发送同理。 踩坑 订阅事件记得要取消 socket主要还是用来写聊天室，加入socket房间后要订阅房间内所有的聊天内容，这时如果没有取消之前的订阅事件，下次进入会多次订阅消息。也就是别人只发一条消息，你这边接收到的却是两条甚至多条。哪如何取消订阅呢，我的处理方式是在离开当前聊天页面后，自动取消之前所有的订阅事件。 123beforeDestroy() &#123; this.sockets.unsubscribe(eventName)&#125; 同理，如果是有指定页面才加入socket房间，退出页面时也要记得关闭socket连接。比如你在created中开始连接socket，在beforeDestroy要记得关闭socket，不然下次进入也会连接socket。 12345678created() &#123; this.$socket.open() // 查看socket是否连接成功 this.$socket.connected&#125;beforeDestroy() &#123; this.$socket.close()&#125; Type Error: this.sockets.subscribe is not a function 这是我最近遇到的问题，原本以为是自己的this指向有问题，然后从到尾查遍了整个逻辑this，发现并不是这个问题。 在打印this.sockets之后我发现问题 subscribe订阅事件并没有直接存在，而是某个对象的属性，于是尝试了一下this.sockets.listenner.subscribe发现能用了。 你以为这就结束了？？？接着我又发现问题 1234567sockets:&#123; welcome: data =&gt; &#123; console.log(&#x27;welcome data &#x27;, data) &#125;&#125; 并且订阅的事件中，socket日志显示component: undefined没有看到数据 全局的订阅事件没有生效，并且socket自带的连接事件也没有启动打印。我直接傻了😢，之前使用的时候还没有这些问题，百度一大堆无果后，开始像官方求助。于是找到了问题。 Vue-Socket.io: #connect subscribe, component: undefined 大概的意思是说，出现问题的都是3.0.9的版本，将版本后可以解决这个问题。这也是我为啥要把socket服务端写进了的原因。自己本地写了一个小demo后，还真的是版本的问题，随后就有了这篇文章。 总结 同学们在使用vue-socket.io时要注意一下版本，现在的3.0.9多多少少会出现问题，可以选择3.0.7版本。这个可以使用文章开头我的测试demo进行查看，socket服务代码也在项目中。 第一次在掘金中发表文章，表达有错误的地方还请多多谅解，之后也会发布更多前端技术文章，还请多多关注。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/tags/Vue/"},{"name":"socket.io","slug":"socket-io","permalink":"https://wakaka378.github.io/tags/socket-io/"}]}],"categories":[{"name":"Git","slug":"Git","permalink":"https://wakaka378.github.io/categories/Git/"},{"name":"工程化","slug":"Git/工程化","permalink":"https://wakaka378.github.io/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"npm","slug":"Git/工程化/npm","permalink":"https://wakaka378.github.io/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/npm/"},{"name":"js","slug":"js","permalink":"https://wakaka378.github.io/categories/js/"},{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/categories/Vue/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://wakaka378.github.io/tags/npm/"},{"name":"工程化","slug":"工程化","permalink":"https://wakaka378.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"js","slug":"js","permalink":"https://wakaka378.github.io/tags/js/"},{"name":"性能优化","slug":"性能优化","permalink":"https://wakaka378.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"节流防抖","slug":"节流防抖","permalink":"https://wakaka378.github.io/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"},{"name":"Vue","slug":"Vue","permalink":"https://wakaka378.github.io/tags/Vue/"},{"name":"socket.io","slug":"socket-io","permalink":"https://wakaka378.github.io/tags/socket-io/"}]}