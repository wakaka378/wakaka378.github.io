<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://wakaka378.github.io/atom.xml" rel="self"/>
  
  <link href="https://wakaka378.github.io/"/>
  <updated>2023-06-14T13:10:23.523Z</updated>
  <id>https://wakaka378.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>还在手动发包? 试试release-it 自动发包吧📦</title>
    <link href="https://wakaka378.github.io/8e08379d750c.html"/>
    <id>https://wakaka378.github.io/8e08379d750c.html</id>
    <published>2023-06-11T10:56:36.000Z</published>
    <updated>2023-06-14T13:10:23.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>作为一名合格的前(摸鱼)工程师，日常工作开发中或多或少都要和<code>npm</code>包打交道。之前工作中就有过发布<code>npm</code>包的经历，但那时年少无知，只知道无脑通过<code>npm publish</code>发包，也没有打 <code>tag</code>、版本、没生成 <code>changelog</code>的概念。直到看到源码共读中有自动发包章节，还可以自动打<code>tag</code>等功能，赶紧收藏学习起来。</p><h1 id="前置准备"><a class="markdownIt-Anchor" href="#前置准备"></a> 前置准备</h1><p>要在<code>npm</code>上发包，当然需要在<code>npm</code>上注册账号，这个就不再赘述。我们在注册完账号之后，先设置一下镜像源，再登录自己的<code>npm</code>账号。如果有同学和我一样，使用的是公司内部私有的<code>npm</code>服务器，使用的账号和镜像源都是公司提供的，不要弄混淆，下面我们开始具体步骤。</p><h2 id="准备项目文件"><a class="markdownIt-Anchor" href="#准备项目文件"></a> 准备项目文件</h2><p>首先创建一个文件夹，然后执行<code>npm init -y </code> 初始化我们的项目</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cca651314fc7476d952c0ce393d79f49~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><h3 id="设置镜像源"><a class="markdownIt-Anchor" href="#设置镜像源"></a> 设置镜像源</h3><p>如果是在已有项目中接入，最好要查看一下当前项目镜像源，初始化项目可以跳过。</p><p>那为什么要设置镜像源呢？装过<code>npm</code>包的同学都知道，<code>npm</code>官方<code>public</code>仓库是部署在国外，使用官方镜像源装包速度很慢，所以我们有时候会将镜像源设置为<code>https://registry.npm.taobao.org</code>，也就是淘宝镜像。这个时候如果我们使用<code>npm</code>的账号是无法登录的，或者是说你把镜像设置为公司内部私有的镜像源，这个时候通过官方<code>npm</code>账号也是无法登录的，曾经我就在这里踩过坑。在哪注册的账号，需要将镜像源设置为注册地的仓库。这里我们使用<code>npm</code>官方镜像源，将镜像源设置为<code>https://registry.npmjs.org</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前镜像源</span></span><br><span class="line">npm config get registry  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置镜像源</span></span><br><span class="line">npm set registry https://registry.npmjs.org  </span><br></pre></td></tr></table></figure><p>另外一种设置镜像源方式，可以在项目根目录中新建<code>.npmrc</code>文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry = https://registry.npmjs.org/</span><br></pre></td></tr></table></figure><h2 id="登录npm"><a class="markdownIt-Anchor" href="#登录npm"></a> 登录npm</h2><p>使用<code>npm</code>注册的账号密码登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录</span></span><br><span class="line">npm login</span><br><span class="line"></span><br><span class="line">➜ npm login</span><br><span class="line">Username: 用户名</span><br><span class="line">Password: 密码</span><br><span class="line">Email: 注册邮箱</span><br><span class="line">Enter one-time password: 一次性密码  邮箱会收到邮件</span><br><span class="line"></span><br><span class="line">➜ npm whoami </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前登录账号名称</span></span><br></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/900461879c9141c8b73dc3e5a40af383~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><h1 id="自动发包"><a class="markdownIt-Anchor" href="#自动发包"></a> 自动发包</h1><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frelease-it%2Frelease-it" title="https://github.com/release-it/release-it">release-it 官网仓库</a></p><p><code>release-it</code>它做了什么？</p><ul><li>同步提交<code>git</code>远端内容</li><li>更新版本号</li><li>产出<code>changelog</code></li><li>提交变动</li><li>增加<code>git tag</code></li><li>推送tag更新至远端</li></ul><p>我们可以通过<code>--dry-run</code>可以看到具体进行了哪些操作</p><h2 id="自动发包-2"><a class="markdownIt-Anchor" href="#自动发包-2"></a> 自动发包</h2><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ npm init <span class="keyword">release</span>-it</span><br><span class="line">npx: <span class="number">30</span> 安装成功，用时 <span class="number">5.813</span> 秒</span><br><span class="line">? <span class="keyword">Where</span> <span class="keyword">to</span> <span class="keyword">add</span> the <span class="keyword">release</span>-it config? ›</span><br><span class="line">❯   .<span class="keyword">release</span>-it.json</span><br><span class="line">    package.json</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ <span class="built_in">npm</span> install -D release-<span class="literal">it</span></span><br></pre></td></tr></table></figure><p>添加命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;release&quot;</span><span class="punctuation">:</span> <span class="string">&quot;release-it&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><p>在项目根目录创建文件</p><ul><li><code>.release-it.json</code></li><li><code>.release-it.js</code></li><li><code>.release-it.yaml</code></li><li><code>.release-it.toml</code></li></ul><p>或者是在<code>pakcage.json</code>文件中添加<code>release-it</code>属性，这里我就直接创建<code>.release-it.json</code>文件，添加以下配置或者可以查看<br /><a href="https://github.com/release-it/release-it/blob/master/docs/configuration.md">更多配置</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;github&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;release&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;git&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;commitMessage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;release: v$&#123;version&#125;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;npm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;publish&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hooks&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;after:bump&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo 更新版本成功&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生成changelog"><a class="markdownIt-Anchor" href="#生成changelog"></a> 生成CHANGELOG</h3><p>安装插件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ <span class="built_in">npm</span> i @release-it/conventional-changelog -D</span><br></pre></td></tr></table></figure><p>然后将以下内容添加到<code>.release-it.json</code>文件中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@release-it/conventional-changelog&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;preset&quot;</span><span class="punctuation">:</span> <span class="string">&quot;angular&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;infile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CHANGELOG.md&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自动发布"><a class="markdownIt-Anchor" href="#自动发布"></a> 自动发布</h3><p>运行命令，就可以进行发布</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ npm run release</span><br><span class="line"><span class="meta"># or</span></span><br><span class="line">➜ npx release-it</span><br></pre></td></tr></table></figure><p>将<code>release-it</code>参数放在<code>--</code>后面</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">run</span> release <span class="comment">--minor --ci</span></span><br></pre></td></tr></table></figure><h2 id="发布其他版本"><a class="markdownIt-Anchor" href="#发布其他版本"></a> 发布其他版本</h2><h3 id="npm版本号"><a class="markdownIt-Anchor" href="#npm版本号"></a> npm版本号</h3><p>这里先初步补充一下<code>npm</code>版本号相关知识，<code>npm</code>的版本号遵循<a href="https://semver.org/lang/zh-CN/">SemVer 规范</a>，<strong>版本号格式必须采用X.Y.Z的格式</strong>，其中 X、Y 和 Z 为非负的整数。<strong>X 是主版本号、Y 是次版本号、而 Z 为修订号，英文对应表示为 major、minor、patch</strong>，每个号必须采用递增。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X.Y.Z <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>&gt; &#123;major&#125;.&#123;minor&#125;.&#123;patch&#125;</span><br><span class="line"><span class="number">2.4</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>这种格式都是正式版，而在正式版发布之前还会经历各种先行版本，先行版本号会在原有的基础上增加一个<strong>版本号标签</strong>，先行版本格式是在修订版本<strong>patch</strong>号后面加上一个<code>-</code>连接，再通过<code>.</code>进行分割</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"># 格式</span></span><br><span class="line"><span class="language-xml">major.minor.patch-</span><span class="template-variable">&#123;identifier&#125;</span><span class="language-xml">.</span><span class="template-variable">&#123;identifier&#125;</span><span class="language-xml">.</span><span class="template-variable">&#123;identifier&#125;</span></span><br></pre></td></tr></table></figure><p>通常第一个 <code>identifier</code> 为版本号标签，后面则是自增版本号。<br />常用的版本号标签有</p><ul><li><code>alpha</code>内部测试版</li><li><code>beta</code>公开测试版</li><li><code>rc</code>候选版本</li></ul><h3 id="发布先行版本"><a class="markdownIt-Anchor" href="#发布先行版本"></a> 发布先行版本</h3><p>理解完<code>npm</code>版本号相关知识后，那如何发布<code>alpha、beta、rc</code>版本呢？</p><p>我们可以看一下<a href="https://github.com/release-it/release-it/blob/master/docs/pre-releases.md">pre-releases</a> ，就是通过不同的命令去创建发布不同的版本，比如我现在需要发布<code>beta</code>版本，就可以执行一下命令。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ npx release-it major <span class="attribute">--preRelease</span>=beta</span><br><span class="line"><span class="comment"># 实际执行了三步</span></span><br><span class="line"><span class="comment"># 1.版本号从 0.2.0 更新至 1.0.0-beta.0</span></span><br><span class="line"><span class="comment"># 2.npm发布版本会打上beta标签，可以通过 npm i xxxx@beta 安装</span></span><br><span class="line"><span class="comment"># 3.github release会打上pre-release标识</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 综合起来就是</span></span><br><span class="line">release-it premajor <span class="attribute">--preReleaseId</span>=beta --npm.<span class="attribute">tag</span>=beta --github.preRelease</span><br></pre></td></tr></table></figure><ul><li><code>beta</code>可以换成<code>&quot;alpha&quot;, &quot;beta&quot;, &quot;rc&quot;</code></li><li><code>major</code>可以替换成<code>major、minor、patch</code></li></ul><p>预发布版本在更改的过程中，原有的先行版本号会清零。比如我从<code>1.2.1-alpha.4</code>升级到<code>beta</code>版本，就会变成<code>1.2.1-beta.0</code></p><p>升级版本时，会将预发布版本清空，此时版本号不会变动。比如我上一个版本是<code>3.0.0-rc.2</code>，当我直接升级<code>patch</code>号就会变成<code>3.0.0</code></p><p>升级当前预发布版本</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ npx release-<span class="keyword">it</span> <span class="comment">--preRelease</span></span><br></pre></td></tr></table></figure><p>将<code>alpha</code>版本修改为<code>beta</code>版本</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ npx release-<span class="keyword">it</span> <span class="comment">--preRelease=beta</span></span><br></pre></td></tr></table></figure><p>升级<strong>major、minor、patch</strong>版本号</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ npx release-it major<span class="regexp">/minor/</span>patch</span><br></pre></td></tr></table></figure><p>当我们发布完后，需要使用到预发布版本依赖事，安装包的时候包名后面要带上<code>@beta</code>或者是其他版本</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install release-<span class="literal">it</span>-test-wakaka@beta -D</span><br></pre></td></tr></table></figure><p>我们也可以将命令拆分开来使用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只响应package.json中的版本号</span></span><br><span class="line">$ npx release-<span class="keyword">it</span> major <span class="comment">--preReleaseId=beta</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置npm发版时的标识为beta</span></span><br><span class="line">$ npx release-<span class="keyword">it</span> major <span class="comment">--npm.tag=beta</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置github release为预发布</span></span><br><span class="line">$ npx release-<span class="keyword">it</span> major <span class="comment">--github.preRelease</span></span><br></pre></td></tr></table></figure><h1 id="查看包"><a class="markdownIt-Anchor" href="#查看包"></a> 查看包</h1><p>我们发布完之后，如何查看自己是否发布成功呢？有以下几种方式</p><h2 id="npm官网查看"><a class="markdownIt-Anchor" href="#npm官网查看"></a> npm官网查看</h2><p>可以在<code>npm</code>官网上直接搜索包的名字，或者是登录账号后在<code>packages</code>中查看自己发布的包</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/272e26ba10ce436ba57b8929324234b6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><p>在<code>versions</code>中可以看到历史的版本</p><h2 id="使用npm-view命令"><a class="markdownIt-Anchor" href="#使用npm-view命令"></a> 使用<code>npm view</code>命令</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 查看某个 <span class="keyword">package</span> <span class="title">的注册信息</span></span><br><span class="line"></span><br><span class="line">npm view &lt;<span class="keyword">package</span>-name&gt;</span><br><span class="line"></span><br><span class="line"># 查看某个 <span class="keyword">package</span> <span class="title">的最新版本</span></span><br><span class="line"></span><br><span class="line">npm view &lt;<span class="keyword">package</span>-name&gt; version</span><br><span class="line"></span><br><span class="line"># 查看某个 <span class="keyword">package</span> <span class="title">在 npm 服务器上所发布过的版本</span></span><br><span class="line"></span><br><span class="line">npm view &lt;<span class="keyword">package</span>-name&gt; versions</span><br><span class="line"></span><br><span class="line"># 查看仓库依赖树上所有包的版本信息</span><br><span class="line"></span><br><span class="line">npm ls</span><br></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5de038b60720431392391cb7038b31f8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><h2 id="直接安装"><a class="markdownIt-Anchor" href="#直接安装"></a> 直接安装</h2><p>简单粗暴，直接通过<code>npm install &lt;package-name&gt;</code>安装一下包，如果发布成功，安装时最好另起项目，不要在当前包项目中安装。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ce42ffdc77a441cba0e4e9b4b914650~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><h1 id="踩坑"><a class="markdownIt-Anchor" href="#踩坑"></a> 踩坑</h1><h2 id="包名重复"><a class="markdownIt-Anchor" href="#包名重复"></a> 包名重复</h2><p>发包前，最好确认一下包名有没有重复，如果包名重复是无法发布的。校验包名最简单的办法就是去<code>npm</code>官网上搜你需要发布的名字，如果有就需要换一个名字，没有就可以发布。</p><p>错误的包名，无法发布<br /><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec191fae05844230ad21d343c7d8e5bc~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><p>修改后，发布成功</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0de13ab045e4b16a1b2181ab6a1ff98~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><h2 id="没有git仓库提交代码"><a class="markdownIt-Anchor" href="#没有git仓库提交代码"></a> 没有git仓库提交代码</h2><p>在安装完<code>@release-it/conventional-changelog</code>后，如果没有在<code>git</code>远程仓库提交代码，也是会发布失败<br /><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/554377c317a9413fbe6def8294878ffe~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><p>添加远程仓库后</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6ea2cba27e34fe08f2b0feca46c68d6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><p>当我们改完代码后，需要进行提交。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git <span class="keyword">commit</span> -m <span class="string">&#x27;xxxxx&#x27;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="changelog文件没有commit信息"><a class="markdownIt-Anchor" href="#changelog文件没有commit信息"></a> changelog文件没有commit信息</h2><p>为什么我提交了commit，但是生成的changelog中没有commit信息？</p><p>这是因为提交的commit信息不符合<code>angular</code>规范，在<code>.release-it.json</code>文件中我们可以看到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@release-it/conventional-changelog&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;preset&quot;</span>: <span class="string">&quot;angular&quot;</span>,</span><br><span class="line">      <span class="string">&quot;infile&quot;</span>: <span class="string">&quot;CHANGELOG.md&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>只要提交的规范符合<code>angular</code>规范，就可以了。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0e6e6a55b594568a41b3d9ce421d697~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><p><a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">约定式提交</a></p><p><a href="https://zj-git-guide.readthedocs.io/zh_CN/latest/message/Angular%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E8%A7%84%E8%8C%83/">Angular提交信息规范</a></p><p><a href="https://github.com/release-it/conventional-changelog">@release-it/conventional-changelog</a></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p><code>release-it</code>使用下来，发现它帮我们节省了很多时间，整体发包流程都很规范。之前工作中进行发包的时候，直接一个<code>npm publish</code>就完事，也没有考虑到打<code>tag</code>、生成<code>changelog</code>这些事情。还有更多扩展性功能等待发现，比如配合上<code>commitizen</code>等工具，自定义<code>commit</code>信息，让<code>changelog</code>内容更丰富。配合<a href="https://github.com/release-it/release-it#hooks">git hooks</a>，执行其他的一些操作。</p><p>同类型的产品还有<a href="https://github.com/conventional-changelog/standard-version">standard-version</a>，也是提供自动化发包流程，但整体来说还是<code>release-it</code>更灵活一些。</p><p><strong>参考文章</strong></p><p><a href="https://juejin.cn/post/7161392772665540644">package.json 配置完全解读</a></p><p><a href="https://juejin.cn/post/7125709933709885448#heading-6">图文结合简单易学的npm 包的发布流程</a></p><p><a href="https://juejin.cn/post/7133175128988319775">聊聊 npm 的语义化版本（Semver）</a><br /><a href="https://segmentfault.com/a/1190000039813329">自动产出changelog-第二节：自动产出</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;作为一名合格的前(摸鱼)工程师，日常工作开发中或多或少都要和&lt;code&gt;npm&lt;/code&gt;包打交道。之前工作中就有过发布&lt;code&gt;npm&lt;/</summary>
      
    
    
    <content src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38f0a541fade49a3936bf73ce1b78a00~tplv-k3u1fbpfcp-watermark.image?" type="image"/>
    
    
    <category term="Git" scheme="https://wakaka378.github.io/categories/Git/"/>
    
    <category term="工程化" scheme="https://wakaka378.github.io/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    <category term="npm" scheme="https://wakaka378.github.io/categories/Git/%E5%B7%A5%E7%A8%8B%E5%8C%96/npm/"/>
    
    
    <category term="npm" scheme="https://wakaka378.github.io/tags/npm/"/>
    
    <category term="工程化" scheme="https://wakaka378.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>记一次vue@cli创建项目prettier失效</title>
    <link href="https://wakaka378.github.io/8d142cc6d228.html"/>
    <id>https://wakaka378.github.io/8d142cc6d228.html</id>
    <published>2023-05-31T13:41:00.000Z</published>
    <updated>2023-06-14T13:16:09.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次vuecli创建项目prettier失效"><a class="markdownIt-Anchor" href="#记一次vuecli创建项目prettier失效"></a> 记一次vue@cli创建项目prettier失效</h1><p>最近在学vue3，使用<code>vue@cli</code>创建项目的时候突然发现<code>prettier</code>失效。各种上网查资料，修改vscode配置操作都不行。后来开两个项目，一个使用<code>vue@cli</code>一个手动创建，发现使用<code>vue@cli</code>创建的项目就是存在失效的问题，排查了很久才发现是官方配置问题，可以查看我提的<a href="https://github.com/vuejs/create-eslint-config/issues/9">issues</a></p><h1 id="vuecli创建项目"><a class="markdownIt-Anchor" href="#vuecli创建项目"></a> vue@cli创建项目</h1><p>Vue3支持用<code>vue@cli</code>创建项目，但前提是<code>vue@cli</code>版本要在5.x以上，4.x的版本升级一下就可以。</p><p>创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vue@last</span><br></pre></td></tr></table></figure><p>这一指令将会安装并执行 <code>create-vue</code>，它是 Vue 官方的项目脚手架工具。你将会看到一些诸如 TypeScript 和测试支持之类的可选功能提示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">✔ Project name<span class="punctuation">:</span> … &lt;your-project-name&gt; <span class="comment">// 项目名称</span></span><br><span class="line">✔ Add TypeScript? … No / Yes <span class="comment">// 添加ts</span></span><br><span class="line">✔ Add JSX Support? … No / Yes <span class="comment">// 添加jsx支持</span></span><br><span class="line">✔ Add Vue Router for Single Page Application development? … No / Yes <span class="comment">// 添加 router</span></span><br><span class="line">✔ Add Pinia for state management? … No / Yes <span class="comment">// 添加 Pinia</span></span><br><span class="line">✔ Add Vitest for Unit testing? … No / Yes <span class="comment">// 添加 vitest</span></span><br><span class="line">✔ Add an End-to-End Testing Solution? … No / Cypress / Playwright <span class="comment">// 添加端到端测试</span></span><br><span class="line">✔ Add ESLint for code quality? … No / Yes <span class="comment">// 添加Eslit</span></span><br><span class="line">✔ Add Prettier for code formatting? … No / Yes <span class="comment">// 添加Prettier</span></span><br></pre></td></tr></table></figure><p>按照自己的需求选择完之后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> vue-project2</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>我当时是选择了<code>eslint</code>和<code>prettier</code>配置，最后会生成对应的配置文件，这里就只关心一下<code>.eslintrc.cjs</code>文件</p><figure class="highlight cjs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eslint-env node */</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;plugin:vue/vue3-essential&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@vue/eslint-config-typescript&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@vue/eslint-config-prettier/skip-formatting&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="string">&#x27;latest&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><p>由于是vue3项目，我直接把<code>vetur</code>插件禁用掉，使用<code>volar</code>插件</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38e16164b8c24e02a51b9ebbcc8663e8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><p>对应的<code>eslint</code>、<code>prettier</code>插件都有安装，VsCode自动保存修复也打开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;source.fixAll&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改一下代码，测试一下<code>prettier</code>功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouterLink</span>, <span class="title class_">RouterView</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;./components/HelloWorld.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;Vue logo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">src</span>=<span class="string">&quot;@/assets/logo.svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;125&quot;</span> <span class="attr">height</span>=<span class="string">&quot;125&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">msg</span>=<span class="string">&quot;You did it!&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">RouterView</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很容易发现代码会有几个错误在里面，相同的代码我放在一个<code>prettier</code>功能完好的项目里面就发现错误。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a64a8a2edc99462a868b538b18ec8ef6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><h1 id="排查"><a class="markdownIt-Anchor" href="#排查"></a> 排查</h1><p>为什么会这样，我修改了<code>vue@cli</code>创建项目的好多配置，主要排查对象放在<code>eslint</code>、<code>vscode编辑器</code>上，甚至重新安装相关依赖，不使用脚手架提供的，还是没有发现问题。</p><p>吃完饭后无意中发现<code>eslint</code>的一个配置后面加了<code>skip-formatting</code>，为啥要跳过配置？然后把这个选项移除，惊奇的发现可以用了。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* eslint-env node */</span><br><span class="line">require(&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  root: true,</span><br><span class="line">  &#x27;extends&#x27;: [</span><br><span class="line">    &#x27;plugin:vue/vue3-essential&#x27;,</span><br><span class="line">    &#x27;eslint:recommended&#x27;,</span><br><span class="line">    &#x27;@vue/eslint-config-typescript&#x27;,</span><br><span class="line"><span class="deletion">-   &#x27;@vue/eslint-config-prettier/skip-formatting&#x27;</span></span><br><span class="line"><span class="addition">+   &#x27;@vue/eslint-config-prettier&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: &#x27;latest&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后查看这个包文件，<code>skip-formatting</code>到底是什么意思？它在<code>node_modules/@vue/eslint-config-prettier/skip-formatting.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">extends</span>: [<span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&quot;./index.js&quot;</span>)],</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&quot;prettier/prettier&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有一个很关键的代码<code>&quot;prettier/prettier&quot;: &quot;off&quot;,</code>它把<code>prettier</code>关闭了，为什么要关闭这个配置呢，百思不得其解，然后去查阅<code>Vue</code>仓库下的<a href="https://github.com/vuejs/create-vue">create-vue</a>相关代码，发现官方用的是另外一个<code>eslint</code>配置仓库<a href="https://github.com/vuejs/create-eslint-config">create-eslint-config</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">&#x27;node:path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Linter</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;eslint&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> createESLintConfig <span class="keyword">from</span> <span class="string">&#x27;@vue/create-eslint-config&#x27;</span> <span class="comment">// create-eslint-config项目</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; pkg, files &#125; = <span class="title function_">createESLintConfig</span>(&#123;</span><br><span class="line">    <span class="attr">vueVersion</span>: <span class="string">&#x27;3.x&#x27;</span>,</span><br><span class="line">    <span class="comment">// we currently don&#x27;t support other style guides</span></span><br><span class="line">    <span class="attr">styleGuide</span>: <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">    <span class="attr">hasTypeScript</span>: needsTypeScript,</span><br><span class="line">    needsPrettier, <span class="comment">// needsPrettier参数从脚手架配置命令行参数里面获取</span></span><br><span class="line"></span><br><span class="line">    additionalConfig,</span><br><span class="line">    additionalDependencies</span><br><span class="line">  &#125;)</span><br><span class="line">  ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看一下<code>create-eslint-config</code>项目里面的相关代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// This is also used in `create-vue`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">createConfig</span> (&#123;</span><br><span class="line">  vueVersion = <span class="string">&#x27;3.x&#x27;</span>, <span class="comment">// &#x27;2.x&#x27; | &#x27;3.x&#x27; (<span class="doctag">TODO:</span> 2.7 / vue-demi)</span></span><br><span class="line"></span><br><span class="line">  styleGuide = <span class="string">&#x27;default&#x27;</span>, <span class="comment">// default | airbnb | typescript</span></span><br><span class="line">  hasTypeScript = <span class="literal">false</span>, <span class="comment">// js | ts</span></span><br><span class="line">  needsPrettier = <span class="literal">false</span>, <span class="comment">// true | false</span></span><br><span class="line"></span><br><span class="line">  additionalConfig = &#123;&#125;, <span class="comment">// e.g. Cypress, createAliasSetting for Airbnb, etc.</span></span><br><span class="line">  additionalDependencies = &#123;&#125; <span class="comment">// e.g. eslint-plugin-cypress</span></span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="comment">// This is the pkg object to extend</span></span><br><span class="line">  <span class="keyword">const</span> pkg = &#123; <span class="attr">devDependencies</span>: &#123;&#125; &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addDependency</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">    pkg.<span class="property">devDependencies</span>[name] = versionMap[name]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="title function_">deepMerge</span>(pkg.<span class="property">devDependencies</span>, additionalDependencies)</span><br><span class="line">  <span class="title function_">deepMerge</span>(eslintConfig, additionalConfig)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (needsPrettier) &#123;</span><br><span class="line">    <span class="title function_">addDependency</span>(<span class="string">&#x27;prettier&#x27;</span>)</span><br><span class="line">    <span class="title function_">addDependency</span>(<span class="string">&#x27;@vue/eslint-config-prettier&#x27;</span>)</span><br><span class="line">    eslintConfig.<span class="property">extends</span>.<span class="title function_">push</span>(<span class="string">&#x27;@vue/eslint-config-prettier/skip-formatting&#x27;</span>) <span class="comment">// 这里往eslint的extend属性里面添加了配置</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> files = &#123;</span><br><span class="line">    <span class="string">&#x27;.eslintrc.cjs&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>就是这行<code>eslintConfig.extends.push('@vue/eslint-config-prettier/skip-formatting') </code>它添加的是配置里面对应的<code>skip-formatting</code>配置，也就是关掉<code>prettier</code>那个。</p><p>在<a href="https://github.com/vuejs/create-eslint-config/commit/cf0bd483ce698413cf8ecbef9ab941f813d83453">这个commit</a>里面，作者重构了这个配置，目的是为了使用<code>prettier</code>时，不使用<code>eslint</code>格式化。</p><p>但我们日常开发中，通常都是<code>prettier</code>和<code>eslint</code>都是一起使用的，如果要想单独使用某一个的话，<code>skip-formatting</code>参数应该是根据用户是否在<code>prettier</code>和<code>eslint</code>二选一的时候决定，也不知道这样做是为了什么。</p><h1 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h1><p>最后的解决办法就很简单</p><ol><li>不使用<code>skip-formatting</code>这个配置文件</li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* eslint-env node */</span><br><span class="line">require(&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  root: true,</span><br><span class="line">  &#x27;extends&#x27;: [</span><br><span class="line">    &#x27;plugin:vue/vue3-essential&#x27;,</span><br><span class="line">    &#x27;eslint:recommended&#x27;,</span><br><span class="line">    &#x27;@vue/eslint-config-typescript&#x27;,</span><br><span class="line"><span class="deletion">-   &#x27;@vue/eslint-config-prettier/skip-formatting&#x27;</span></span><br><span class="line"><span class="addition">+   &#x27;@vue/eslint-config-prettier&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: &#x27;latest&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>这个文件不是吧<code>prettier</code>给关掉了吗，我们打开就行。</li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* eslint-env node */</span><br><span class="line">require(&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  root: true,</span><br><span class="line">  extends: [</span><br><span class="line">    &#x27;plugin:vue/vue3-essential&#x27;,</span><br><span class="line">    &#x27;eslint:recommended&#x27;,</span><br><span class="line">    &#x27;@vue/eslint-config-typescript&#x27;,</span><br><span class="line">    &#x27;@vue/eslint-config-prettier/skip-formatting&#x27;</span><br><span class="line">  ],</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: &#x27;latest&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="addition">+  rules: &#123;</span></span><br><span class="line"><span class="addition">+    &#x27;prettier/prettier&#x27;: &#x27;error&#x27;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记一次vuecli创建项目prettier失效&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#记一次vuecli创建项目prettier失效&quot;&gt;&lt;/a&gt; 记一次vue@cli创建项目prettier失效&lt;/h1&gt;
&lt;p&gt;最近在学vue3</summary>
      
    
    
    <content src="https://www.runoob.com/wp-content/uploads/2017/01/vue.png" type="image"/>
    
    
    <category term="Vue" scheme="https://wakaka378.github.io/categories/Vue/"/>
    
    <category term="工程化，prettier" scheme="https://wakaka378.github.io/categories/Vue/%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%8Cprettier/"/>
    
    
    <category term="Vue3" scheme="https://wakaka378.github.io/tags/Vue3/"/>
    
    <category term="vue@cli" scheme="https://wakaka378.github.io/tags/vue-cli/"/>
    
    <category term="prettier" scheme="https://wakaka378.github.io/tags/prettier/"/>
    
  </entry>
  
  <entry>
    <title>防抖debounce理解</title>
    <link href="https://wakaka378.github.io/b1ab80e28404.html"/>
    <id>https://wakaka378.github.io/b1ab80e28404.html</id>
    <published>2023-04-09T13:54:09.000Z</published>
    <updated>2023-06-14T13:17:40.439Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebd170e14b414cc89fd50f01fdb78487~tplv-k3u1fbpfcp-watermark.image?" alt="" style="width:100%" /></p><blockquote><p>「我正在参与掘金会员专属活动-源码共读第一期，<a href="https://juejin.cn/post/7169502488557518878" title="https://juejin.cn/post/7169502488557518878">点击参与</a>」</p></blockquote><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p><strong>防抖</strong>相信大家都不陌生，面试中会经常会被问题或提起。比如会问一些前端优化、手写<strong>防抖节流函数</strong>等等，这里就跟着<a href="https://github.com/jashkenas/underscore/blob/master/modules/debounce.js">underscore</a> 源码来学习一下。</p><h1 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h1><p><strong>在规定时间后才执行，如果触发则重新计时</strong><br />也就是说，防抖函数在n秒内，无论触发了多少次函数回调，我都只只在n秒后执行一次。比如我们设置一个等待时间为5秒的防抖函数，如果5秒内有触发，就需要重新计时，直到5秒内没有触发就调用执行。</p><h1 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h1><p>最近项目中有一个表单搜索场景，在输入文字的过程中会持续触发<code>oninput</code>事件，而搜索接口只是在用户输入搜索文字后进行调用。如果是用户输入一个文字就搜索一次，不仅会频繁调用后台接口，前端显示效果也不好。</p><p>使用<strong>防抖</strong>的话，可以将接口调用设定在<code>500ms</code>内没有触发<code>oninput</code>事件后再调用接口，这样就可以解决问题。</p><p>还会在其他场景使用</p><ul><li>一些频繁点击操作的按钮，比如登录、短信验证，避免用户短时间多次发送</li><li>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖</li><li>鼠标移动<code>mousedown</code>计算等场景</li></ul><h1 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h1><p>实现原理其实很简单，就是利用定时器，函数在最开始执行的时候就设定一个定时器，如果在n秒内有执行就吧定时器清空，重新设定一个新的定时器，当n秒内没有再调用后，定时器计时结束后就会触发回调。</p><h1 id="第一版"><a class="markdownIt-Anchor" href="#第一版"></a> 第一版</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* debounce防抖</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type"> function </span>&#125; fn 回调</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type"> number </span>&#125; wait 等待时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait = <span class="number">300</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 利用闭包生成唯一的一个定时器</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个函数，当作触发事件执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="comment">// 上一次存在定时器，需要清空</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设定定时器，定时器结束后执行回调函数 fn  如果多次触发就重新设定</span></span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再写一个输入框事件来测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> oninput=<span class="string">&quot;oninputHandler(event)&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> testFn = <span class="title function_">debounce</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行防抖&#x27;</span>, event.<span class="property">target</span>.<span class="property">value</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;, <span class="number">1000</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 执行防抖 停止 scroll 事件后 1 秒执行回调</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">oninputHandler</span>(<span class="params">event</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">testFn</span>(event);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 不执行防抖</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">oninputHandler</span>(<span class="params">event</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;input change value: &#x27;</span> + event.<span class="property">target</span>.<span class="property">value</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这是没有执行防抖<br /><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5957c66dae0b4b6b89381351da99ae35~tplv-k3u1fbpfcp-watermark.image?" alt="Kapture 2022-12-04 at 21.56.21.gif" /></p><p>开启防抖后<br /><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebd170e14b414cc89fd50f01fdb78487~tplv-k3u1fbpfcp-watermark.image?" alt="Kapture 2022-12-04 at 21.57.44.gif" /></p><p>效果还是很明显的，从原来的输入一个值就触发，到现在1秒内没有输入才触发，至此，<strong>简单版防抖</strong>就已经实现了。</p><h1 id="第二版"><a class="markdownIt-Anchor" href="#第二版"></a> 第二版</h1><p>接下来再来对<strong>防抖</strong>做一下改造，在首次调用的时候立即执行函数，等到n秒内没有触发，才可以重新触发执行。</p><p>听起来有点绕，也就是说在<code>oninput</code>事件第一次触发的时候就执行，后续的触发都不执行。等到1秒内没有执行后，再触发<code>oninput</code>时又会执行第一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* debounce防抖</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type"> function </span>&#125; fn 回调</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type"> number </span>&#125; wait 等待时间</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type"> boolean </span>&#125; immediate 是否立即执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait = <span class="number">300</span>, immediate = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 利用闭包生成唯一的一个定时器</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个函数，当作触发事件执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="comment">// 上一次存在定时器，需要清空</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// immediate: true 时，首次触发后立即执行</span></span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        <span class="comment">// 是否首次执行过</span></span><br><span class="line">        <span class="keyword">const</span> isExecute = !timer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 赋值定时器 避免重复执行</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首次执行</span></span><br><span class="line">        isExecute &amp;&amp; fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设定定时器，定时器结束后执行回调函数 fn  如果多次触发就重新设定</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="underscore-源码"><a class="markdownIt-Anchor" href="#underscore-源码"></a> underscore 源码</h1><p>来看一下<a href="https://github.com/jashkenas/underscore">underscore</a>里是如何实现的，先将核心代码复制出来，用上面的<code>oninput</code>事件来调试，看一下它的一个具体步骤。</p><p>在<code>debounced</code>方法内部打上一个断点，然后在输入框输入数据触发<strong>防抖</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, immediate</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, previous, args, result, context;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// now获取的是当前时间 previous 会在第一次进入的时候记录  对比两个时间差是否小于 wait 等待时间</span></span><br><span class="line">    <span class="keyword">var</span> passed = <span class="title function_">now</span>() - previous;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait &gt; passed) &#123;</span><br><span class="line">      <span class="comment">// 小于等待时间 说明在 wait时间内有触发 重新设定定时器</span></span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(later, wait - passed);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 超过等待时间 执行回调</span></span><br><span class="line">      <span class="comment">// 清空 timeout  避免影响到下次使用</span></span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否立即执行</span></span><br><span class="line">      <span class="keyword">if</span> (!immediate) result = func.<span class="title function_">apply</span>(context, args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This check is needed because `func` can recursively invoke `debounced`.</span></span><br><span class="line">      <span class="comment">// 清空上下文、arguments 参数 在回调里面嵌套使用</span></span><br><span class="line">      <span class="keyword">if</span> (!timeout) args = context = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 先执行这里  通过 restArguments 将处理结果当作函数进行返回 回调时传递 arguments 参数</span></span><br><span class="line">  <span class="keyword">var</span> debounced = <span class="title function_">restArguments</span>(<span class="keyword">function</span> (<span class="params">_args</span>) &#123;</span><br><span class="line">    context = <span class="variable language_">this</span>;</span><br><span class="line">    args = _args;</span><br><span class="line">    <span class="comment">// 触发一次记录时间  用来和等待时间对比</span></span><br><span class="line">    previous = <span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      <span class="comment">// 第一次进入时执行</span></span><br><span class="line">      <span class="comment">// 执行 later 函数</span></span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(later, wait);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 立即执行</span></span><br><span class="line">      <span class="keyword">if</span> (immediate) result = func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消执行 清空定时器等参数</span></span><br><span class="line">  debounced.<span class="property">cancel</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = args = context = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码还是有很多亮点的</p><ul><li>增加了<code>cancel</code>方法，可以随时取消。</li><li>在执行回调的时候，吧函数结果当作返回值<code>return</code>出去，是为了避免回调中有返回数据。</li><li>通过记录每次执行时间差，来判断是否需要执行回调。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebd170e14b414cc89fd50f01fdb78487~tplv-k3u1fbpfcp-watermark.image?
&quot; alt=&quot;&quot; st</summary>
      
    
    
    <content src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebd170e14b414cc89fd50f01fdb78487~tplv-k3u1fbpfcp-watermark.image?" type="image"/>
    
    
    <category term="js" scheme="https://wakaka378.github.io/categories/js/"/>
    
    
    <category term="Js" scheme="https://wakaka378.github.io/tags/Js/"/>
    
    <category term="性能优化" scheme="https://wakaka378.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="节流防抖" scheme="https://wakaka378.github.io/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据结构之——队列</title>
    <link href="https://wakaka378.github.io/b5876a494e6d.html"/>
    <id>https://wakaka378.github.io/b5876a494e6d.html</id>
    <published>2022-12-05T13:02:58.000Z</published>
    <updated>2023-06-14T13:07:37.856Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c26fc06add2243f081195d58751c407b~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" alt="" /></p><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p><strong>队列</strong>相信大家都不陌生，它是属于<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>等一种，不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计出来的。而对于我们前端技术人员来说，理解数据结构都非常重要。在我们解决一些问题的时候，使用不同的数据结构会带来不同性能，因此数据结构是这些问题的解决方案中不可或缺的一部分。</p><h1 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h1><p>之前在做<strong>IM</strong>相关产品的时候，会经常用到<strong>队列</strong>，比如说之前有遇到一个场景，进入到多人聊天室时会将未读消息批量加载，然后通过消息获取到对应信息后，为了保证消息顺序的正确，需要一条一条按序存入<code>IndexDB</code>中。这里就会使用到队列，最先存进来的获取数据的消息会被最先放入到<code>IndexDb</code>当中。</p><p>还有一个场景大家肯定不陌生，那就是<strong>事件循环Event Loop</strong>。先将执行栈中的<strong>宏任务和微任务</strong>分别放入<strong>队列</strong>中，再从<strong>队列</strong>中取出来依次执行。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5d0e73a944e45c39f49ab301dbfbcad~tplv-k3u1fbpfcp-watermark.image?" alt="js-eventloop16.png" /></p><h1 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h1><p>队列是遵循<strong>FIFO(First In First Out，先进先出，也称为先来先服务)原则</strong>的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。跟它相反的是<strong>栈</strong>，遵循<strong>先入后出(LIFO，last-in-first-out) 的原则</strong>。</p><p>举个简单例子，我们做核酸排队，其实就是一个简单的<strong>队列</strong>。最先来的人最先捅嗓子眼，后面来的人需要在我后面排队，等我捅完之后再捅。我简单的画了张图，理解一下相关的定义。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc5364f43f054b3fa41d896c797a1b62~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><h1 id="简单版"><a class="markdownIt-Anchor" href="#简单版"></a> 简单版</h1><p>利用数组的<code>shift、push</code>方法，实现一个简单版的队列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queueList</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; el </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queueList</span>.<span class="title function_">push</span>(el)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queueList</span>.<span class="title function_">shift</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取队列长度</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> 队列长队</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queueList</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空队列</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queueList</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断队列是否为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> 是否为空</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queueList</span>.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>()</span><br><span class="line">queue.<span class="title function_">dequeue</span>(<span class="number">1</span>)</span><br><span class="line">queue.<span class="title function_">dequeue</span>(<span class="number">2</span>)</span><br><span class="line">queue.<span class="title function_">dequeue</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">enqueue</span>(), queue.<span class="title function_">isEmpty</span>()) <span class="comment">// 1 false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="链式队列"><a class="markdownIt-Anchor" href="#链式队列"></a> 链式队列</h1><h2 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h2><p>链式队列相对于上一版就要复杂些，它的结构就像一个链条一样，一环扣一环。在队列中，每一个元素通过<code>next</code>指向下一个元素，下一个元素又会有<code>next</code>指向它后面的，这样各元素就通过<code>next</code>连接起来，形成一条链子。</p><p>同时还会有两个指针，一个指针指向<code>队头</code>元素，另外一个指针指向<code>队尾</code>元素。当元素位置发生变动时，这两个指针也会随之改变。这里我们用<code>head</code>表示队头，<code>tail</code>表示队尾，<code>next</code>为当前元素的下一个元素，看一下整个流程。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49fb206df6e941bb931b6e94f7e2fada~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><p>执行<code>enqueue</code>入队操作，此时<code>A4</code>的<code>next</code>指向空，<code>tail</code>指向<code>A[3]</code>。当<code>A5</code>执行<code>enqueue</code>入队操作时，<code>A4</code>的<code>next</code>就会指向<code>A5</code>, 同时<code>tail</code>也会指向，<code>A5</code>的<code>next</code>就会为<code>null</code></p><p>执行<code>dequeue</code>出队操作，首先<code>A0</code>的<code>next</code>不会指向<code>A1</code>，因为<code>A0</code>已经出去了，不在当前队列中。然后<code>head</code>会指向<code>A1</code>，成为新的队头。</p><h2 id="node节点"><a class="markdownIt-Anchor" href="#node节点"></a> Node节点</h2><p>理解完上面一张图，我们来先来实现一下<code>enqueue</code>入队操作。在入队前，我们需要先定义一个<code>Node</code>节点，用来表示每一个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码很简单，就是实现一个<code>Node</code>节点的时候，将元素放入<code>element</code>，同时给它添加一个<code>next</code>属性，用来指向下一个节点。</p><h2 id="创建队列"><a class="markdownIt-Anchor" href="#创建队列"></a> 创建队列</h2><p>接下来创建队列，先声明一下类，定义属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前队列长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span> </span><br><span class="line">    <span class="comment">// 头部指针</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span> </span><br><span class="line">    <span class="comment">// 尾部指针</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="enqueue"><a class="markdownIt-Anchor" href="#enqueue"></a> enqueue</h2><p>然后按照上面的思路，实现一下<code>enqueue</code>操作，需要进行以下几个操作。</p><ul><li>创建节点<code>Node</code></li><li>添加元素<ul><li>如果当前队列为空，添加到<code>head</code></li><li>如果当前队列不为空，添加到<code>tail</code></li></ul></li><li>修改<code>tail</code>指向</li><li>修改长度</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入队</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; value 入队属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">enqueue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建节点</span></span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(value)    </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断队列是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;  <span class="comment">// 这里先不看 isEmpty 方法</span></span><br><span class="line">    <span class="comment">// 队列为空 将节点元素添加到头部</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = node</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 队列不为空 将队尾的 next 指向新元素</span></span><br><span class="line">    <span class="keyword">const</span> currentNode = <span class="variable language_">this</span>.<span class="property">tail</span>  <span class="comment">// 做一下缓存 避免影响到后面</span></span><br><span class="line">    currentNode.<span class="property">next</span> = node</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置新的队尾</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tail</span> = node</span><br><span class="line">  <span class="comment">// 修改长度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;enqueue element&#x27;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testQueue = <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">testQueue.<span class="title function_">enqueue</span>(<span class="string">&#x27;vue&#x27;</span>) <span class="comment">// enqueue element vue</span></span><br><span class="line">testQueue.<span class="title function_">enqueue</span>(<span class="string">&#x27;react&#x27;</span>) <span class="comment">// enqueue element react</span></span><br><span class="line">testQueue.<span class="title function_">enqueue</span>(<span class="string">&#x27;angular&#x27;</span>) <span class="comment">// enqueue element angular</span></span><br></pre></td></tr></table></figure><h2 id="dequeue"><a class="markdownIt-Anchor" href="#dequeue"></a> dequeue</h2><p>接下来是出队，主要是以下几个步骤。</p><ul><li>判断是否为空<ul><li>队列为不为空，获取头部<code>head</code>元素返回。</li><li>队列为空，不执行。</li></ul></li><li>修改队列长度</li><li>将头部指针指向<code>next</code>中的元素</li><li>清空队尾<code>tail</code></li><li>返回队头<code>head</code>元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队 最先进入的最先出去</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">dequeue</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 判断是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> currentHead = <span class="variable language_">this</span>.<span class="property">head</span> <span class="comment">// 缓存head</span></span><br><span class="line">  <span class="comment">// 将头部指针指向下一个元素</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span> = currentHead.<span class="property">next</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改长度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>--</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空尾部</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> currentHead.<span class="property">element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testQueue = <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">testQueue.<span class="title function_">enqueue</span>(<span class="string">&#x27;vue&#x27;</span>) <span class="comment">// enqueue element vue</span></span><br><span class="line">testQueue.<span class="title function_">enqueue</span>(<span class="string">&#x27;react&#x27;</span>) <span class="comment">// enqueue element react</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(testQueue.<span class="title function_">dequeue</span>(), <span class="string">&#x27;---dequeue1&#x27;</span>) <span class="comment">// vue ---dequeue1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(testQueue.<span class="title function_">dequeue</span>(), <span class="string">&#x27;---dequeue2&#x27;</span>) <span class="comment">// react ---dequeue2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(testQueue.<span class="title function_">dequeue</span>(), <span class="string">&#x27;---dequeue3&#x27;</span>) <span class="comment">// undefined ---dequeue3</span></span><br><span class="line">testQueue.<span class="title function_">enqueue</span>(<span class="string">&#x27;angular&#x27;</span>) <span class="comment">// enqueue element angular</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(testQueue.<span class="title function_">dequeue</span>(), <span class="string">&#x27;---dequeue4&#x27;</span>) <span class="comment">// angular ---dequeue4</span></span><br></pre></td></tr></table></figure><h2 id="其他方法"><a class="markdownIt-Anchor" href="#其他方法"></a> 其他方法</h2><p>主要的功能已经实现了，剩下的几个简单方法，对应注释我都写上了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> queue size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">getSize</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> 队列是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span> === <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">head</span> === <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> 队列字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> queueStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123; <span class="comment">// 不为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tempNode = <span class="variable language_">this</span>.<span class="property">head</span> <span class="comment">// 缓存 head  避免修改影响到队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环头部</span></span><br><span class="line">    <span class="keyword">while</span>(tempNode) &#123;</span><br><span class="line">      <span class="comment">// 获取 element</span></span><br><span class="line">      queueStr += tempNode.<span class="property">element</span> +( tempNode.<span class="property">next</span> ? <span class="string">&#x27;---&gt;&#x27;</span> :<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 修改 tempNode 进入下一次循环</span></span><br><span class="line">      tempNode = tempNode.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queueStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 当前队列长度</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span> </span><br><span class="line">    <span class="comment">// 头部指针</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="literal">null</span> </span><br><span class="line">    <span class="comment">// 尾部指针</span></span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="literal">null</span> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;*&#125; value 入队属性</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  enqueue(value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    <span class="keyword">const</span> node = new Node(value)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 队列为空 将节点元素添加到头部</span></span><br><span class="line">      <span class="keyword">this</span>.head = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 队列不为空 将队尾的 next 指向新元素</span></span><br><span class="line">      <span class="keyword">const</span> currentNode = <span class="keyword">this</span>.tail  <span class="comment">// 做一下缓存 避免影响到后面</span></span><br><span class="line">      currentNode.next = node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的队尾</span></span><br><span class="line">    <span class="keyword">this</span>.tail = node</span><br><span class="line">    <span class="comment">// 修改长度</span></span><br><span class="line">    <span class="keyword">this</span>.size++</span><br><span class="line"></span><br><span class="line">    console.log(<span class="string">&#x27;enqueue element&#x27;</span>, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队 最先进入的最先出去</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  dequeue()&#123;</span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> currentHead = <span class="keyword">this</span>.head <span class="comment">// 缓存head</span></span><br><span class="line">    <span class="comment">// 将头部指针指向下一个元素</span></span><br><span class="line">    <span class="keyword">this</span>.head = currentHead.next</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改长度</span></span><br><span class="line">    <span class="keyword">this</span>.size--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空尾部</span></span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentHead.element</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空队列</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取队列长度</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> queue size</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getSize()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 队列是否为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> 队列是否为空</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.head === <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 打印队列</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> 队列字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  print() &#123;</span><br><span class="line">    let queueStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isEmpty()) &#123; <span class="comment">// 不为空</span></span><br><span class="line"></span><br><span class="line">      let tempNode = <span class="keyword">this</span>.head <span class="comment">// 缓存 head  避免修改影响到队列</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 循环头部</span></span><br><span class="line">      <span class="keyword">while</span>(tempNode) &#123;</span><br><span class="line">        <span class="comment">// 获取 element</span></span><br><span class="line">        queueStr += tempNode.element +( tempNode.next ? <span class="string">&#x27;---&gt;&#x27;</span> :<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 tempNode 进入下一次循环</span></span><br><span class="line">        tempNode = tempNode.next</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queueStr</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testQueue = new MyQueue();</span><br><span class="line">testQueue.enqueue(<span class="string">&#x27;vue&#x27;</span>)</span><br><span class="line">testQueue.enqueue(<span class="string">&#x27;react&#x27;</span>)</span><br><span class="line"><span class="comment">// testQueue.enqueue(&#x27;angular&#x27;)</span></span><br><span class="line">console.log(testQueue.dequeue(), <span class="string">&#x27;---dequeue1&#x27;</span>)</span><br><span class="line">console.log(testQueue.dequeue(), <span class="string">&#x27;---dequeue2&#x27;</span>)</span><br><span class="line"><span class="comment">// console.log(testQueue.clear(), &#x27;---clear&#x27;);</span></span><br><span class="line">console.log(testQueue.dequeue(), <span class="string">&#x27;---dequeue3&#x27;</span>)</span><br><span class="line">testQueue.enqueue(<span class="string">&#x27;angular&#x27;</span>)</span><br><span class="line">console.log(testQueue.dequeue(), <span class="string">&#x27;---dequeue4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(testQueue.getSize(), &#x27;---getSize&#x27;)</span></span><br><span class="line"><span class="comment">// console.log(testQueue.isEmpty(), &#x27;---isEmpty&#x27;)</span></span><br><span class="line"><span class="comment">// console.log(testQueue.print(), &#x27;---print&#x27;)</span></span><br></pre></td></tr></table></figure><h1 id="yocto-queue源码"><a class="markdownIt-Anchor" href="#yocto-queue源码"></a> yocto-queue源码</h1><p>看一下<a href="https://github.com/sindresorhus/yocto-queue/blob/main/index.js">yocto-queue</a>的实现逻辑，大体逻辑上是差不多，但多了几个知识点。</p><h2 id="自定义迭代器"><a class="markdownIt-Anchor" href="#自定义迭代器"></a> 自定义迭代器</h2><p>在<code>print</code>打印队列函数，这里是用了是用了<a href="https://es6.ruanyifeng.com/#docs/symbol#Symbol-iterator">Symbol.iterator</a>自定义了一个迭代器，可以遍历整个队列，提供外界使用。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b216d6024ca946f09325739b7f96fcab~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><h2 id="class-getter-setter"><a class="markdownIt-Anchor" href="#class-getter-setter"></a> Class getter setter</h2><p>在<code>size</code>函数前面有一个 <code>get</code>关键字，可以直接获取到<code>return</code>返回的值，。同理，如果前面是<code>set</code>，就可以直接修改数据。<br /><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3687b4b4df624fd5a486f88de1710d7b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><h2 id="私有属性"><a class="markdownIt-Anchor" href="#私有属性"></a> 私有属性<code>#</code></h2><p>我们都知道，<code>class</code>类的属性默认都是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Public_class_fields">公有</a>的，在实现类的后，可以访问到类里面的属性。但可以使用增加哈希前缀 <code>#</code> 的方法来定义<strong>私有类字段</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">  [[count]] = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">value</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错，这个就很好理解。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="title class_">Add</span>();</span><br><span class="line">counter.#count <span class="comment">// 报错</span></span><br><span class="line">counter.#count = <span class="number">42</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>看完<a href="https://github.com/sindresorhus/yocto-queue/blob/main/index.js">yocto-queue</a>的实现后不由感慨，原来队列实现还可以这么优雅简洁，<strong>迭代器</strong>的使用也是很巧妙，这个思路可以收藏✅。写完后发现，数组版本和链式版本有啥区别？明明链式版本更简单易懂，为什么还要实现链式版本？后来刷题的时候才想通。数组的特点是<strong>查询数据快，插入数据慢</strong>，查询的时间复杂度是<strong>O(1)</strong>，插入的时间复杂度是<strong>O(n)</strong>。它插入元素时，移动的是整个数组。而链式结构刚好和它相反，在查询时的复杂度是<strong>O(n)</strong>，插入的是<strong>O(1)</strong>。插入元素只需要修改<code>next</code>指向就可以，比数组快上不少，这就是数据结构的魅力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c26fc06add2243f081195d58751c407b~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:151</summary>
      
    
    
    <content src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c26fc06add2243f081195d58751c407b~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" type="image"/>
    
    
    <category term="Js" scheme="https://wakaka378.github.io/categories/Js/"/>
    
    <category term="数据结构" scheme="https://wakaka378.github.io/categories/Js/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Js" scheme="https://wakaka378.github.io/tags/Js/"/>
    
    <category term="数据结构" scheme="https://wakaka378.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="队列" scheme="https://wakaka378.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>一个躺平的年中</title>
    <link href="https://wakaka378.github.io/22c4eb459fc8.html"/>
    <id>https://wakaka378.github.io/22c4eb459fc8.html</id>
    <published>2022-07-23T13:06:41.000Z</published>
    <updated>2023-06-14T13:07:33.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个躺平的年中"><a class="markdownIt-Anchor" href="#一个躺平的年中"></a> 一个躺平的年中</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3df9aaab1c149e0b7ed0a30b3fbcef9~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" alt="" /></p><blockquote><p>「时光不负，创作不停，本文正在参加<a href="https://juejin.cn/post/7108989863126368286" title="https://juejin.cn/post/7108989863126368286">2022年中总结征文大赛</a>」</p></blockquote><p>这篇年中总结来的有点晚，活动快结束的时候才觉得写。不知道为什么，记忆力比之前下降了好多，很多事情都容易忘记。以至于现在回想一下上半年经历的一切，都需要从手机照片、社交账号里去寻找，花了一上午时间翻阅，简单的来做一个年中总结吧。</p><p>关于上半年，总结起来就几个关键词：<strong>躺平</strong> <strong>居家 一无所事</strong></p><h1 id="躺平"><a class="markdownIt-Anchor" href="#躺平"></a> 躺平</h1><p>由于去年经历了教育行业大裁员休息三个月后，随便找了一份并不满意的工作。团队氛围、身边的同事、工作的内容都远远不及上一家，时常怀念火花的团队氛围。在年前的转正会上没有通过，给了延期转正。</p><p>想起原因来，也是觉得可笑。 在转正评审会上，我复盘了一下迭代中我负责的某个功能出现的推迟交付，交付质量差的问题。主要责任还是我承担下来，但并不都是我的问题，将部分原因指向团队层面的问题和产品人员。然而没有想到领导给出的结论是我态度上的问题，从而做出延期转正的决定。当时觉得不可理喻，本来就不怎么看好这份工作，更是对它彻底失望。但由于经济原因，我需要这份工作，需要继续在北京立足下去。只能被迫接受，但那时已经做出了三月份跳槽的决定。开始制定学习计划、买课程、写项目，希望能在金三银四中成功跳槽。</p><p>到了金(铜)三银(铁)四，互联网开始出现大规模裁员，只准备了两周的复习后，就开始骑驴找马四处投简历。但没想到行情会差成这样，投了大半个月简历后，能面试的不超过两家。身边朋友都在吐槽今年找工作难，加上自身经济问题，只能先苟着。在面试前，给自己定制了许多学习计划，要完成多少多少。出去看了一圈之后，回来彻底躺平。什么学习计划都抛在脑后，买的课也不怎么看，周末也不打开电脑，彻底和现状妥协。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94203bddd0f04d4fae58e6cf9c8a9e1a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><h1 id="居家"><a class="markdownIt-Anchor" href="#居家"></a> 居家</h1><p>由于跳槽失败只能被迫接受这份工作，在四月份的时候通过了转正评审，本以为可以一直这样每天苟下去，月底就接到领导通知，部门产品和银行合作的二期项目启动了，我被外派到银行上班，也只好默默接受。五月份北京突如其来的疫情，打乱了我五一出门的计划，这波疫情持续很久，加上银行管控严格，每天都是在家办公。每天都是睡到晨会前十分钟起床，省去了交通通行时间，可以自己在家做饭，家里的办公比公司自在，没有太多约束。甚至可以一整天都不在工作岗位上，只要你能应付过领导的检查。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f9bab2712c24aa0b8b6db8e8798d01a~tplv-k3u1fbpfcp-watermark.image?" alt="在家办公每天一杯冰美式" /></p><h1 id="一无所事"><a class="markdownIt-Anchor" href="#一无所事"></a> 一无所事</h1><p>上半年工作处处不顺，情感上也到处碰壁，学习上一塌糊涂，彻底摆乱躺平。回顾上半年，没干成一件事，去年立下的flag也没几项完成了。整个人处在一个迷茫阶段，不知道自己要干啥，也没有目标，浑浑噩噩的度过每一天。躺平了，不写了，就这样吧。。。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23c61356fcc34d0da6fe98589180f4e2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一个躺平的年中&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一个躺平的年中&quot;&gt;&lt;/a&gt; 一个躺平的年中&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpf</summary>
      
    
    
    <content src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3df9aaab1c149e0b7ed0a30b3fbcef9~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" type="image"/>
    
    
    <category term="总结" scheme="https://wakaka378.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="https://wakaka378.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>掘金自动签到➕定时执行➕邮箱推送 你还想要啥❓</title>
    <link href="https://wakaka378.github.io/692e96f41680.html"/>
    <id>https://wakaka378.github.io/692e96f41680.html</id>
    <published>2022-01-16T13:15:12.000Z</published>
    <updated>2023-06-14T13:15:58.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="掘金自动签到-定时执行-邮箱推送-你还想要啥"><a class="markdownIt-Anchor" href="#掘金自动签到-定时执行-邮箱推送-你还想要啥"></a> 掘金自动签到 ➕ 定时执行 ➕邮箱推送 你还想要啥❓</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4f074044ab4321ad0675aab5d58a00~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" alt="" /></p><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>冒着被关进小黑屋的风险  写了个掘金自动签到抽奖程序 包含了自动执行、签到、免费抽奖、沾喜气、邮件通知的脚本，以后再也不用每天忘记签到了😄</p><p>事情是这样的  元旦那天由于玩的太嗨 忘记了掘金签到这么一回事 作为一名专业的摸鱼🐟选手 怎么能断签呢（好吧 我是为了第二天5120矿石）果断买了补签卡 后来在想  为啥不写一个每天自动执行的签到脚本呢？？</p><p><strong>重要❗</strong></p><p>掘金团队已经对签到脚本采取措施，禁止🙅‍♂️使用自动签到脚本，违者将清空所有矿石或者封号，具体规则可参见<a href="https://juejin.cn/pin/7065954293509160997">禁止脚本签到行为沸点</a> ，大家还是遵循社区规范，每天登陆掘金进行签到。之前有使用过该项目的，建议将fork下来的仓库workflow手动禁止，或者直接删除项目，文章中的github项目链接我已删除。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c842de5e857466c88d6bdb7486e7ae9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><h1 id="具备能力"><a class="markdownIt-Anchor" href="#具备能力"></a> 具备能力</h1><ul><li>[x] <code>action</code> 每天9点定时执行</li><li>[x] 邮件通知<ul><li>[ ] cookie过期邮件通知</li></ul></li><li>[x] 签到</li><li>[x] 沾喜气</li><li>[x] 抽奖</li><li>[ ] 设定想要兑换的周边 自动计算还需要签到多少天<br />目前就具备这么多能力  项目会持续维护 添加的新的功能（前提是不会被优弧关起来）如果有更好的项目可以在评论区提出</li></ul><h1 id="start-quickly"><a class="markdownIt-Anchor" href="#start-quickly"></a> Start quickly</h1><p>用编辑器打开项目后  需要将带有<strong>手动填写</strong>的几项数据修改为自己的 其他不要动</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置文件</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 需要手动填写</span></span><br><span class="line">  <span class="attr">cookie</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="comment">// 请求地址</span></span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&#x27;https://api.juejin.cn&#x27;</span>,</span><br><span class="line">  <span class="comment">// api地址</span></span><br><span class="line">  <span class="attr">api</span>: &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 邮箱配置</span></span><br><span class="line">  <span class="attr">emailConfig</span>: &#123;</span><br><span class="line">    <span class="comment">// 邮箱服务 163|qq</span></span><br><span class="line">    <span class="attr">service</span>: <span class="string">&#x27;163&#x27;</span>,</span><br><span class="line">    <span class="comment">// 邮箱 手动填写</span></span><br><span class="line">    <span class="attr">email</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// 邮箱授权码  手动填写</span></span><br><span class="line">    <span class="attr">pass</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="cookie获取方式"><a class="markdownIt-Anchor" href="#cookie获取方式"></a> cookie获取方式</h2><blockquote><p>cookie 有过期时间 大概是一个月  或者是退出登陆也会过期<br />登陆进入到掘金，<strong>F12</strong>打开控制台，选择<strong>network</strong>后随便点击一个接口，找到请求头中的<code>cookie</code>，选中数据后右键<strong>复制值</strong></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3d16490afb8465d93dcbf544497436d~tplv-k3u1fbpfcp-zoom-1.image" alt="image" /></p><h2 id="邮箱设置"><a class="markdownIt-Anchor" href="#邮箱设置"></a> 邮箱设置</h2><p>这里以163邮箱为例  qq邮箱同理  如果是163邮箱  直接将<code>service</code>字段设置为163（qq邮箱就写qq） 然后填入你自己的邮箱 邮件发送成功  登陆邮箱会看到你给自己发了一条邮件  就像这样</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9824a69bd1d14e24bdfdec640d590485~tplv-k3u1fbpfcp-zoom-1.image" alt="image" /></p><p><strong>授权码获取⚠️：</strong><br />登陆进入163邮箱  打开设置</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bccfbc6f48e74f9fa10f04d375df9044~tplv-k3u1fbpfcp-zoom-1.image" alt="image" /></p><p>将以下几个设置打开  打开<code>IMAP/SMTP</code>服务时会弹窗发送短信 微信扫码后就可以发送短信（qq邮箱这一步开启需要手动进行验证发送短信）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b361b1ae8a48398aae7d64626e3534~tplv-k3u1fbpfcp-zoom-1.image" alt="image" /></p><p>我这里已经添加过了  就直接点击新增授权  也是一样会弹出二维码扫码发送短信<br /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27da536385c044d6a185191e1ff76489~tplv-k3u1fbpfcp-zoom-1.image" alt="image" /></p><p>短信发送完毕后点击我已发送  然后就会得到你的授权码（注意授权码只展示一次）  将授权吗粘贴到配置文件中的 <code>pass</code>字段</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f2a43fde0c54462a0e7de66287b88a5~tplv-k3u1fbpfcp-zoom-1.image" alt="image" /></p><p>将所有的参数填入无误后  可以用命令<code>node index.js</code>本地运行  可以收到邮件并且邮件里有日志消息 恭喜你🎉 以后再也不用每天签到了（会不会被官方打死）</p><p>确认无误后将修改后的项目<code>push</code> 项目已经设置了自动执行  每天<strong>9点</strong>会自动执行签到  并且发送邮件进行通知</p><p>自从用了自动签到后  妈妈再也不用担心我忘记签到了   兑换Switch不是梦</p><h1 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现"></a> 具体实现</h1><p>如果只关注脚本功能  看到这里就可以左拐🚪了 如果对实现感兴趣 这里也和你分享一下具体的实现思路</p><p>有了想法之后就开始去扒掘金签到相关的接口  挨个接口点开看 都是给了些啥数据 每个数据都是用来干啥的 经过漫长的调试后  脚本签到能力就完成了 功能主要由一下几个接口组成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 签到</span></span><br><span class="line"><span class="attr">checkIn</span>: <span class="string">&#x27;/growth_api/v1/check_in&#x27;</span>,</span><br><span class="line"><span class="comment">// 查询签到</span></span><br><span class="line"><span class="attr">getCheckStatus</span>: <span class="string">&#x27;/growth_api/v1/get_today_status&#x27;</span>,</span><br><span class="line"><span class="comment">// 查询签到天数</span></span><br><span class="line"><span class="attr">getCheckInDays</span>: <span class="string">&#x27;/growth_api/v1/get_counts&#x27;</span>,</span><br><span class="line"><span class="comment">// 查询当前矿石</span></span><br><span class="line"><span class="attr">getCurrentPoint</span>: <span class="string">&#x27;/growth_api/v1/get_cur_point&#x27;</span>,</span><br><span class="line"><span class="comment">// 查询抽奖</span></span><br><span class="line"><span class="attr">getlotteryStatus</span>: <span class="string">&#x27;/growth_api/v1/lottery_config/get&#x27;</span>,</span><br><span class="line"><span class="comment">// 抽奖</span></span><br><span class="line"><span class="attr">draw</span>: <span class="string">&#x27;/growth_api/v1/lottery/draw&#x27;</span>,</span><br><span class="line"><span class="comment">// 沾喜气</span></span><br><span class="line"><span class="attr">dipLucky</span>: <span class="string">&#x27;/growth_api/v1/lottery_lucky/dip_lucky&#x27;</span></span><br><span class="line"><span class="comment">// 获取沾喜气列表用户</span></span><br><span class="line"><span class="attr">getLuckyUserList</span>: <span class="string">&#x27;/growth_api/v1/lottery_history/global_big&#x27;</span></span><br></pre></td></tr></table></figure><p>接下来就很简单了  接接口嘛  谁还不会了  找个请求库直接干 这里我选用的是<code>axios</code></p><p>先配置一下请求  在<code>index.js</code>写入 将<code>config</code>文件中的<code>cookie</code>丢进请求头中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置请求地址</span></span><br><span class="line">axios.defaults.baseURL = config.baseUrl</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置cookie</span></span><br><span class="line">axios.defaults.headers[<span class="string">&#x27;cookie&#x27;</span>] = config.cookie</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相应拦截处理</span></span><br><span class="line">axios.interceptors.response.use((response) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="keyword">data</span> &#125; = response</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">data</span>.err_msg === <span class="string">&#x27;success&#x27;</span> &amp;&amp; <span class="keyword">data</span>.err_no === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">data</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Promise.reject(<span class="keyword">data</span>.err_msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> Promise.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下来就直接请求接口，请求循序依次为</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba37964d4e1c43dca962b5a5e13f4d5b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" /></p><p>以下主要代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看今天是否已经签到</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125; 是否签到过 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getCheckStatus</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> getCheckStatusRes = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: config.<span class="property">api</span>.<span class="property">getCheckStatus</span>,</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> getCheckStatusRes.<span class="property">data</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`查询签到失败!【<span class="subst">$&#123;error&#125;</span>】`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询当前矿石</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getCurrentPoint</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> getCurrentPointRes = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123; <span class="attr">url</span>: config.<span class="property">api</span>.<span class="property">getCurrentPoint</span>, <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span> &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`当前总矿石: <span class="subst">$&#123;getCurrentPointRes.data&#125;</span>数`</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`查询矿石失败!<span class="subst">$&#123;error.err_msg&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询免费抽奖次数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125; 是否有免费抽奖次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getlotteryStatus</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> getlotteryStatusRes = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123; <span class="attr">url</span>: config.<span class="property">api</span>.<span class="property">getlotteryStatus</span>, <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> getlotteryStatusRes.<span class="property">data</span>.<span class="property">free_count</span> === <span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`查询免费抽奖失败！【<span class="subst">$&#123;error&#125;</span>】`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取沾喜气列表用户historyId</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125; 被沾的幸运儿的history_id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getLuckyUserHistoryId</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 接口为分页查询  默认查询条10条数据 &#123;page_no: 0, page_size: 5&#125;</span></span><br><span class="line">    <span class="keyword">const</span> luckyList = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123; <span class="attr">url</span>: config.<span class="property">api</span>.<span class="property">getLuckyUserList</span>, <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span> &#125;)</span><br><span class="line">    <span class="comment">// 随机抽取一位幸运儿  沾他</span></span><br><span class="line">    <span class="keyword">return</span> luckyList.<span class="property">data</span>.<span class="property">lotteries</span>[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * luckyList.<span class="property">data</span>.<span class="property">lotteries</span>.<span class="property">length</span>)]?.<span class="property">history_id</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`获取沾喜气列表用户historyId失败`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 沾喜气</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dipLucky</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取historyId</span></span><br><span class="line">    <span class="keyword">const</span> historyId = <span class="keyword">await</span> <span class="title function_">getLuckyUserHistoryId</span>()</span><br><span class="line">    <span class="comment">// 沾喜气接口   传递lottery_history_id</span></span><br><span class="line">    <span class="keyword">const</span> dipLuckyRes = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123; <span class="attr">url</span>: config.<span class="property">api</span>.<span class="property">dipLucky</span>, <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>, <span class="attr">data</span>: &#123; <span class="attr">lottery_history_id</span>: historyId &#125; &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`占喜气成功! 🎉 【当前幸运值：<span class="subst">$&#123;dipLuckyRes.data.total_value&#125;</span>/6000】`</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`占喜气失败！ <span class="subst">$&#123;error&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽奖</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">draw</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> freeCount = <span class="keyword">await</span> <span class="title function_">getlotteryStatus</span>()</span><br><span class="line">    <span class="keyword">if</span> (freeCount) &#123;</span><br><span class="line">      <span class="comment">// 没有免费抽奖次数</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;今日免费抽奖以用完&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始抽奖</span></span><br><span class="line">    <span class="keyword">const</span> drawRes = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123; <span class="attr">url</span>: config.<span class="property">api</span>.<span class="property">draw</span>, <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span> &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`恭喜你抽到【<span class="subst">$&#123;drawRes.data.lottery_name&#125;</span>】🎉`</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先沾一下喜气</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">dipLucky</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawRes.<span class="property">data</span>.<span class="property">lottery_type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 抽到矿石 查询总矿石</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">getCurrentPoint</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`抽奖失败!=======&gt; 【<span class="subst">$&#123;error&#125;</span>】`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *查询签到天数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Object</span>&#125; continuousDay 连续签到天数 sumCount 总签到天数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getCheckInDays</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> getCheckInDays = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123; <span class="attr">url</span>: config.<span class="property">api</span>.<span class="property">getCheckInDays</span>, <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">continuousDay</span>: getCheckInDays.<span class="property">data</span>.<span class="property">cont_count</span>, <span class="attr">sumCount</span>: getCheckInDays.<span class="property">data</span>.<span class="property">sum_count</span> &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`查询签到天数失败!🙁【<span class="subst">$&#123;getCheckInDays.err_msg&#125;</span>】`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 签到</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">checkIn</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 查询今天是否签到没</span></span><br><span class="line">    <span class="keyword">const</span> checkStatusRes = <span class="keyword">await</span> <span class="title function_">getCheckStatus</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!checkStatusRes) &#123;</span><br><span class="line">      <span class="comment">// 签到</span></span><br><span class="line">      <span class="keyword">const</span> checkInRes = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123; <span class="attr">url</span>: config.<span class="property">api</span>.<span class="property">checkIn</span>, <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span> &#125;)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`签到成功，当前总矿石<span class="subst">$&#123;checkInRes.data.sum_point&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 查询签到天数</span></span><br><span class="line">      <span class="keyword">const</span> getCheckInDaysRes = <span class="keyword">await</span> <span class="title function_">getCheckInDays</span>()</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`连续抽奖<span class="subst">$&#123;getCheckInDaysRes.continuousDay&#125;</span>天  总签到天数<span class="subst">$&#123;getCheckInDaysRes.sumCount&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 签到成功 去抽奖</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">draw</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;今日已经签到 ✅&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`签到失败!=======&gt; <span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动执行"><a class="markdownIt-Anchor" href="#自动执行"></a> 自动执行</h2><p>关于自动执行 我最开始想的方案是通过服务器部署  开启一个定时任务去执行  这种方式需要有服务器  比较麻烦  也有人用云函数 我又懒得去注册 后了找到一种方案就是 白嫖<code>Github Action</code> 通过<code>CI</code>设置定时任务 每天自动执行  <code>Github</code>人人都有 要求也较低  由于我不是很懂<code>CI</code>这方面的东西  这次为了脚本也只是学了个皮毛  具体代码如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">jjCheckInScript</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="comment"># 每天9点执行 时间格式 minute hour day month week 设置的时间是UTC 不是北京时间 需要+8</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&quot;0 1 * * *&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">start:</span></span><br><span class="line">    <span class="comment"># 运行环境为最新版的Ubuntu</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span>  </span><br><span class="line"></span><br><span class="line">      [[<span class="string">安装node</span>]]<span class="string">.js</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span>  </span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;14&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 安装依赖并且执行脚本</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Start</span> <span class="string">task</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">node</span> <span class="string">index.js</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里关键的代码是<code>schedule</code>  将触发任务的方式改为定时执行 到了设定好的时间后会自动执行任务  任务会以最新版本的<code>ubuntu</code>系统进行运行 安装<code>node</code> 安装项目中的依赖后  执行<code>index.js</code>中的代码  如果想要修改执行时间 按照<code> minute hour day month week</code> 的格式修改<code>schedule</code>字段即可（设置的时间是<code>UTC</code> 北京时间 需要**+8**）</p><h2 id="邮件发送"><a class="markdownIt-Anchor" href="#邮件发送"></a> 邮件发送📧</h2><p>邮件发送这里选用的是<a href="https://nodemailer.com/about/">Nodemail</a>库 它的功能十分强大 支持多种邮箱服务 支持<code>HTML</code>内容、纯文本内容、附件、图片等等 发送邮件方式也很简单 具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">&#x27;nodemailer&#x27;</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 日志处理  将脚本日志通过ejs渲染成html</span></span><br><span class="line"><span class="keyword">const</span> logs = []</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">oldLog</span> = <span class="variable language_">console</span>.<span class="property">log</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">oldErr</span> = <span class="variable language_">console</span>.<span class="property">error</span></span><br><span class="line">​</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  logs.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">    <span class="attr">text</span>: str</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">oldLog</span>(str)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">error</span> = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  logs.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    <span class="attr">text</span>: str</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">oldErr</span>(str)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sendEmail</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> template = ejs.<span class="title function_">compile</span>(fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;email.ejs&#x27;</span>), <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line">    <span class="keyword">const</span> transporter = nodemailer.<span class="title function_">createTransport</span>(&#123;</span><br><span class="line">      <span class="attr">service</span>: process.<span class="property">env</span>.<span class="property">SERVICE</span>, <span class="comment">// 邮箱服务</span></span><br><span class="line">      <span class="attr">port</span>: <span class="number">465</span>, <span class="comment">// 端口</span></span><br><span class="line">      <span class="attr">secure</span>: <span class="literal">true</span>, <span class="comment">// 使用TLS，SSL加密端口465</span></span><br><span class="line">      <span class="attr">secureConnection</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">auth</span>: &#123;</span><br><span class="line">        <span class="attr">user</span>: process.<span class="property">env</span>.<span class="property">EMAIL</span>, <span class="comment">// 发送者邮箱</span></span><br><span class="line">        <span class="attr">pass</span>: process.<span class="property">env</span>.<span class="property">PASS</span>, <span class="comment">// 邮箱授权码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 发送邮件</span></span><br><span class="line">    <span class="keyword">await</span> transporter.<span class="title function_">sendMail</span>(&#123;</span><br><span class="line">      <span class="attr">from</span>: process.<span class="property">env</span>.<span class="property">EMAIL</span>,</span><br><span class="line">      <span class="attr">to</span>: process.<span class="property">env</span>.<span class="property">EMAIL</span>,</span><br><span class="line">      <span class="attr">subject</span>: <span class="string">&#x27;掘金签到通知🔔&#x27;</span>,</span><br><span class="line">      <span class="attr">html</span>: <span class="title function_">template</span>(&#123;</span><br><span class="line">        <span class="attr">logs</span>: logs</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">​</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`邮件发送失败！<span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邮件内容 我这里用<code>ejs</code>写了一个简单的日志模版 用来承载脚本的<code>log</code> 在前面我对<code>console.log console.error</code>进行重写 将<code>str</code>存储到<code>logs</code>数组中 吧<code>logs</code>数据传入模版引擎生成<code>html</code></p><p>邮件发送其实很简单 具体配置可以查看<a href="https://nodemailer.com/smtp/">官方文档</a> 这里就解释一下用到的配置</p><ul><li><strong>service:</strong> 邮箱服务 <code>Node mai l</code>内部已经支持了很多<a href="https://nodemailer.com/smtp/well-known/">邮箱服务</a> 如果填写这个字段就不需要写<code>host</code></li><li><strong>host:</strong> 邮箱的主机IP地址 这一项一版在开启<code>IMAP/SMTP</code>后会展示邮箱的IP地址</li><li><strong>prot:</strong> 端口号 默认的为<code>465</code></li><li><strong>secure：</strong> 配置安全链接</li><li><strong>secureConnection:</strong> 使用<code>SSL</code>（默认为false）</li><li><strong>auth.user:</strong> 发送者邮箱</li><li><strong>auth.pass:</strong> 邮箱授权码</li><li><strong>from:</strong> 发送者邮箱</li><li><strong>to:</strong> 接受者邮箱</li><li><strong>subject:</strong> 邮件主题</li><li><strong>html:</strong> 邮件内容<code>html</code>字符串</li></ul><h2 id="actions-secrets-密码安全"><a class="markdownIt-Anchor" href="#actions-secrets-密码安全"></a> Actions secrets 密码安全</h2><p>关于<code>cookie</code> 邮箱授权码 刚开始是写在一个配置文件夹里面 后来啦哥提出了更好的方式 就是用<code>Actions secrets</code> 这种方式可以避免关键数据暴露 （万一那个无聊的家伙拿你cookie去梭哈了呢😏） 还是小心为上</p><p>其实使用也很简单 我之前对这块完全不熟悉 看了会<a href="https://docs.github.com/cn/actions/security-guides/encrypted-secrets">官方文档</a> 三下五除二就弄好了 在添加好<code>secrets</code>数据后 我们需要在<code>blank.yml</code>文件中对数据进行获取 获取方式也很简单 直接通过<code>$&#123;&#123;secrets.youKey&#125;&#125;</code>就可以获取到 以该项目为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 环境变量</span><br><span class="line"><span class="attr">env</span>:</span><br><span class="line">  <span class="attr">COOKIE</span>: $&#123;&#123; secrets.<span class="property">COOKIE</span> &#125;&#125;</span><br><span class="line">  <span class="attr">PASS</span>: $&#123;&#123; secrets.<span class="property">PASS</span> &#125;&#125;</span><br><span class="line">  <span class="attr">EMAIL</span>: $&#123;&#123; secrets.<span class="property">EMAIL</span> &#125;&#125;</span><br><span class="line">  <span class="attr">SERVICE</span>: $&#123;&#123; secrets.<span class="property">SERVICE</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>在设置完之后 我们就可以在环境变量中使用这些数据 就像这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="property">env</span>.<span class="property">COOKIE</span></span><br><span class="line">process.<span class="property">env</span>.<span class="property">EMAIL</span></span><br></pre></td></tr></table></figure><p>但是获取到的数据在<code>Actions</code>中是无法进行展示的 在输出日志中 你定义的所有密码都会被清除 并在输出日志之前用星号替换 也是为了防止泄漏</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bda476d9d0b945b58637d5d178bd5bf2~tplv-k3u1fbpfcp-zoom-1.image" alt="image" /></p><p>如果觉得这样还不够安全 在代码中可以随意使用到数据 可以尝试一下对<a href="https://docs.github.com/cn/actions/security-guides/encrypted-secrets#limits-for-secrets">密码进行加密</a></p><h2 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> Q&amp;A</h2><h3 id="自动执行延迟"><a class="markdownIt-Anchor" href="#自动执行延迟"></a> 自动执行延迟</h3><p>在开发测试的时 发现jobs没有按时执行 九点五分到公司打开<code>actions</code>时发现并没有执行<code>jobs</code>  刚开始还以为是<code>cron</code> 时间填写错误  修改时间后发现<code>github actions</code>定时任务会有延迟  延迟时间几分钟到十几分钟甚至一小时都有  但这个并不影响我们签到功能  只要是在今天签到都可以</p><p>以我测试为例  将 <code>corn</code>时间设置为每天的<code>12:30</code>  但实际执行时间为 <code>12:51</code> 差不多延迟了<code>20分钟</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">on:</span></span><br><span class="line">  <span class="meta"># 定时执行</span></span><br><span class="line"><span class="symbol">  schedule:</span></span><br><span class="line">    - cron: <span class="string">&quot;30 4 * * *&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aacc559213ae4cb6bf9078929357c27f~tplv-k3u1fbpfcp-zoom-1.image" alt="jobs执行时间" /></p><p>查看相关文档后发现  在GitHub中关于Schedule的定义：</p><blockquote><p>Note: The schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.</p><p>注意: 在高负载的 GitHub action 工作流运行期间，调度事件可能会被延迟。高负载时间包括每个小时的开始。为了减少延迟的机会，请安排您的工作流在一小时的不同时间运行。</p></blockquote><p>也就是说  Schedule中的cron时间并不是真正执行的时候  而是工作流进入到GitHub进行计划排队时间 说简单点就是工作流进入到GitHub执行的队列时间  具体什么时候执行工作流 则需要看GitHub工作流的负载</p><p>这个问题在签到需求中并不是致命的问题  如果想要解决可以参考<a href="https://zhuanlan.zhihu.com/p/379365305">Github Action的 Schedule 运行不准时的解决办法</a>这篇文章</p><h3 id="为啥不用documentcookie"><a class="markdownIt-Anchor" href="#为啥不用documentcookie"></a> 为啥不用<code>document.cookie</code>?</h3><p>控制台输入命令获取到的cookie并不完整</p><p>这是控制台获取到的<code>cookie</code>，对比一下接口的<code>cookie</code>，相差很大<br /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91221fa2088b453dadcbbd408872d045~tplv-k3u1fbpfcp-zoom-1.image" alt="image" /></p><h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明📢</h2><p>本项目仅适用于学习交流  并不具备其他用途  也没有经过掘金官方团队  若是被封号  与我无关（手动狗头保命）</p><p>有其他想法或功能 欢迎👏进行讨论   如果对你有帮助 给个<code>Star</code>行不行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;掘金自动签到-定时执行-邮箱推送-你还想要啥&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#掘金自动签到-定时执行-邮箱推送-你还想要啥&quot;&gt;&lt;/a&gt; 掘金自动签到 ➕ 定时执行 ➕邮箱推送 你还想要啥❓&lt;/h1&gt;
&lt;p&gt;&lt;img src</summary>
      
    
    
    <content src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4f074044ab4321ad0675aab5d58a00~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" type="image"/>
    
    
    <category term="Github" scheme="https://wakaka378.github.io/categories/Github/"/>
    
    <category term="工具" scheme="https://wakaka378.github.io/categories/Github/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Node" scheme="https://wakaka378.github.io/categories/Github/%E5%B7%A5%E5%85%B7/Node/"/>
    
    
    <category term="Github" scheme="https://wakaka378.github.io/tags/Github/"/>
    
    <category term="工具" scheme="https://wakaka378.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Node" scheme="https://wakaka378.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>2021当程序员碰到本命年...</title>
    <link href="https://wakaka378.github.io/f0d2269aa2b7.html"/>
    <id>https://wakaka378.github.io/f0d2269aa2b7.html</id>
    <published>2021-12-07T13:09:02.000Z</published>
    <updated>2023-06-14T13:09:51.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2021当程序员碰到本命年"><a class="markdownIt-Anchor" href="#2021当程序员碰到本命年"></a> 2021当程序员碰到本命年…</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec96d155e57f4d889baf7a8dc40a8771~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" alt="" /></p><blockquote><p>「时光不负，创作不停，本文正在参加<a href="https://juejin.cn/post/7034786723137585188/" title="https://juejin.cn/post/7034786723137585188/">2021年终总结征文大赛</a>」</p></blockquote><h2 id="工作"><a class="markdownIt-Anchor" href="#工作"></a> 工作</h2><h3 id="拒绝pua"><a class="markdownIt-Anchor" href="#拒绝pua"></a> ❌拒绝pua</h3><p>第一次离职发生在今年3月份，离开了在厦门公司，在公司工作两年，见证了公司有入职时的十几人团队到离职时的两百多号人的发展历程。两年来，公司教会了我很多。一个人的前端，技术栈怎么舒服怎么来，也没有绩效考核、提心吊胆code Review、没完没了的会议。要说坏处，那就是太累了，所有事情都得你一个人去承担。不光是技术，公司也教会我，<strong>「工作的事情不能太感性」</strong>，大家都是出来打工都是为了钱，只要是和利益相关的都要坚守自己的底线，不要被老板的一些大饼所诱惑。我当初就是太天真，20年疫情期间遵循公司降薪后，还没日没夜的在家干活，回公司后处于降薪的同时，还要自己承担房租（我从武汉跟随公司来厦门，那会是包住的）。本来不高的工资加上降薪，自己承担房租，那会手上还有车贷，几乎是每个月到手的钱立马就没了。那会坚信公司有困难，大家都走了，我不能在关键时刻离开公司（哼～天真的我），要和公司一起度过难关，等公司挺过去了不会亏待我们这些员工。可等公司挺过去了（我们那会做的是线上教育），还反过来在你身上猛嘬一口。</p><p>最后实在忍受不了，今年3月份和公司提了离职。离职处理完家中事情后，开始着手复习。在家一边复习一边投简历，瞄准的城市是 <strong>「北京」</strong>，在线上面试了几家之后，收到了那会觉得还不错的offer，总体薪资水平在14k左右。对于当时的我来说，已经是之前的两倍多了。时机成熟之后，只身一人坐上了北上的飞机，开始北漂生活。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4770a3d82959431da9bed7f7bc99c87b~tplv-k3u1fbpfcp-watermark.image?" alt="WeChatae43c1783d058567a341b99611a4c773.png" /></p><p>来北京后，并没有着急入职，而是继续投简历面试。最后选择入职某花思维教育公司，开启了第二份工作。</p><h3 id="教育行业裁员"><a class="markdownIt-Anchor" href="#教育行业裁员"></a> 😔教育行业裁员</h3><p>由于在第一家公司做教育，来北京后找工作也是针对教育行业。那会觉得做教育行业的公司应该都还不错，比较老东家就是靠着做教育渡过疫情发展壮大的。四月份入职新公司后，被分到通信研发中心负责公司通信产品研发。那是我第一次在一个有完整的制度规范、开发流程的公司里上班。以前都不知道什么是codeReview、什么是showcase、版本发布还能这样弄等等。就好像一个山沟沟里的孩子，看到见了满地的高楼大厦一般。团队氛围非常喜欢，组里的小哥哥小姐姐超棒，leader人也不错（这里真的很感谢他们对我的包容，尤其是leader为团队承受了很多外界压力）。 其实在某花的工作还是很辛苦的，早10晚9，中间俩小时休息和下午一小时吃饭。平时下班就八点多，到家基本都在十点左右，要是碰到开发紧急或者需要发版，通常都是在十点下班（因为十点后打车报销）。工作很累，但是自己很喜欢，对工作充满了干劲。</p><p><strong>「时代的一粒灰，落在个人头上就是一座山」</strong></p><p>双减政策落地，教育行业备受打击 7月份公司开始裁员。其实那会心里已经有底了，我肯定是要被裁掉的。被叫到一个办公室后，直接签好赔偿协议离职协议，那会还没有转正赔偿只有0.5，不过有总比没有强。上午还在写代码，下午交完工牌还了设备就离职了。直到我们办完离职手续，leader开会回来才知道我们组里今年入职的同学全部都被裁了，我从他眼里看到了无助以及愧疚，大家走之前吃了一顿散伙饭，和leader、留下来的同事一一道别后，开始第三份工作寻找之路。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d722c3bd4b5484f8f59689c9ff61f9e~tplv-k3u1fbpfcp-watermark.image?" alt=" 团建的时候和小伙伴凌晨四点爬起来看日出，吹了半小时风后看了个寂寞 " /></p><h3 id="跑路要快"><a class="markdownIt-Anchor" href="#跑路要快"></a> 🏃跑路要快</h3><p>离职后我并没有着急找工作，而是给自己放了一个月的假。那会时间节点还不是很好，自己也没有复习，再加上外面全是教育行业裁员的，整体行情并不是很好。于是休息够了之后，就开始了系统的复习。来北京前复习过一次，但都是粗略的过一遍知识点，并没有完整的复习。这次复习我列好需要复习的一些知识点、面试常问的面试题、开始看一些源码，复习的同时并记录下笔记，留下了这篇<a href="https://juejin.cn/post/7000669234208440356">2021前端面试复习</a>，这也是今年发布的第一篇文章。一个月复习后，9月份开始陆陆续续投简历约面试。几乎保持一天两家的评率，大概持续了两周，面了十家左右。小公司几乎一面一个准，稍微大一点的公司一面二面都会通过，但是经常会卡在三面或者是算法题。我是完全没有算法基础的，面试一问算法题我就慌，记得有一家问斐波那契数列第n求和的问题，想半天都没有回答上来。后来面了一些中厂后，被面试官全程碾压。备受打击之后选择逃避，开始浑浑噩噩的过日子，每天沉迷游戏电影。</p><p>直到手上积蓄花光之后，开始着急找工作了有危机感了，那会已经来到十月。那会的现状是小公司不想去，大一点的公司要么位置太远要么不想去。进过一顿筛选后，选择入职一家C轮融资2亿的医疗公司。这家公司主要给医院写后台管理系统，没有前端，后台大部分都是全栈。十月中旬入职后，上午签署了一大堆各种协议，下午开始接触公司业务代码。闲的无聊看了一下公司大群聊天消息，突然发现这家公司现在有经济危机，两个月前的工资还没发。我意识到不对劲，直接找到hr说自己不合适，hr很是不解，入职流程走的好好的，怎么就不合适呢。于是让我领导和我谈谈，领导他也是个爽快人，就直接说公司目前资金流转不开，确实发生了拖欠工资，但近期会有好转，已经找到新的投资人（鬼知道哦）。我二话没说，流程都不用走了，直接跑路。所以大家以后在找工作时，发现公司不对劲赶紧跑。</p><h3 id="现状"><a class="markdownIt-Anchor" href="#现状"></a> 🐟现状</h3><p>从医疗公司离职后，又投了一段时间简历，十月底的时候入职了现在公司。没有之前的资金问题，出手也很大方，也没有太多的套路。公司主要做可视化方面，智慧园区、智慧城市、3D可视化等，这些都和我没关。我所在的是2D可视化，用GoJs话流程图的。其实公司还好，让我很不爽的一点就是需要驻场开发。近期就被派到某信银行现场开发（不就是外包嘛）。在客户现场开发就没有公司本部那么舒服，没有外网（最不爽的一点），只能用银行的垃圾电脑等。但总体好，没啥开发任务，有很多学（摸）习（鱼）时间，也不需要怎么加班，五点半左右我就跑了。</p><p>对于现状我并不满意，不喜欢公司团队氛围、技术氛围也不好，没有什么进步空间，每天都是为了工作而工作。但不得不向生活低头屈服，为了💰还是要接着干。不过可以通过这份工作多余的时间，静下心来刷题、写技术文档、学习新的技术、做开源项目等等事情。既能赚钱，又有时间做自己的事情，何乐不为。</p><h2 id="个人技术"><a class="markdownIt-Anchor" href="#个人技术"></a> 个人技术</h2><p>技术方面，除了在某花时候用过一段时间react，其他的技术栈还是和之前工作一样，但是这一年的更多是收获了出技术栈以外的东西。以前在小公司一个人开发管理项目的时候，觉得自己已经很厉害了，不管是技术还是项目管理方面。直到来到北京后，发现自己才是小丑。这里很感谢能够有在某花的工作经历，那段经历让我打开了视野，让我觉得自己还很渺小，自己还是很弱，需要保持学习不断进步。<br />/minad</p><h2 id="生活感情"><a class="markdownIt-Anchor" href="#生活感情"></a> 生活感情</h2><p>生活上也是处处碰壁，过年的时候父亲住院动手术，我只好提前回家（回家第一天就报废一条车胎和轮毂🥲）。3月份离职的时候，还没有到原定的离职日期我便连夜飞回家，父亲意外受伤，从县医院转到武汉人民医院，直到八九月份才慢慢恢复。女朋友也在夏天的时候大病一场，本以为年底会平静一些，谁想最近姐姐也因病住院，前天刚做完手术。家庭关系也很紧张，父母不停的吵架甚至到了分居的地步。</p><p>但还好，这一切一切都没有压垮我，因为我遇到了我生命中的她，最初来北京的目的也是为了能够和她在一起。来北京后也是她一直在照顾我，找工作帮我出谋划策、陪我找房子、在我有困难的时候出现在我身边。而我也在为满足她做一条咸鱼的理想在不断的努力。</p><p><strong>我俩的备注，懂的同学可以评论区留言😏</strong><br /><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c171820a38684a4caf9117157cedf71e~tplv-k3u1fbpfcp-watermark.image?" alt="1051638887323_.pic.jpg" /></p><p>我吧今年这一切的不顺，都归罪于我今年本命年（虽然我不信这个），我相信一切都会过去的，现在所有的问题都会有结果，<strong>我对我未来的生活充满了希望</strong>。</p><p>总结一下</p><h2 id="flag"><a class="markdownIt-Anchor" href="#flag"></a> flag</h2><p>今年在技术方面收获甚少，也没有做知识输出，近期已经做好了规划，迎接明年的金三银四</p><ul><li>[ ] <strong>多输出技术文章</strong></li><li>[ ] <strong>LeetCode不能停</strong></li><li>[ ] <strong>Vue3全家桶学习</strong></li><li>[ ] <strong>源码的学习还是需要继续</strong></li><li>[ ] <strong>node学习（近期在规划已经在规划用node koa express做一套东西）</strong></li><li>[ ] <strong><a href="https://juejin.cn/post/7007077511779581982">todoList项目要完成</a></strong></li><li>[ ] <strong>保持健康 要有一个好身体</strong></li><li>[ ] <strong>要多下厨，毕竟外卖不健康</strong></li><li>[ ] <strong>换一家喜欢的公司</strong></li><li>[ ] <strong>多看书，不管是技术书还是其他的</strong></li><li>[ ] <strong>带家人出去旅游一次散散心</strong></li><li>[ ] <strong>答应她明年带她去看南京的梧桐</strong></li><li>[ ] <strong>要有存款 有钱才有底气</strong></li><li>[ ] <strong>多和家人联系</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2021当程序员碰到本命年&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2021当程序员碰到本命年&quot;&gt;&lt;/a&gt; 2021当程序员碰到本命年…&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.co</summary>
      
    
    
    <content src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec96d155e57f4d889baf7a8dc40a8771~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" type="image"/>
    
    
    <category term="总结" scheme="https://wakaka378.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="https://wakaka378.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2021前端面试复习</title>
    <link href="https://wakaka378.github.io/fd8759a87419.html"/>
    <id>https://wakaka378.github.io/fd8759a87419.html</id>
    <published>2021-08-26T13:10:52.000Z</published>
    <updated>2023-06-14T13:13:09.231Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d56cc46a99b4f7d9f114171e9738058~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp" alt="" /></p><p>一个在教育行业苦干两年的前端菜鸟，离职后就在准备复习面试，记录一下这次前端复习过程。前端知识是在是太多，持续更新中… 希望对真正找工作的你有所帮助，文末我整理了一下面试文章，感兴趣的可以看看，尤其是<strong>2021高频前端面试题汇总</strong>系列，帮助很大。文章有所不足的地方还指明。</p><h2 id="html5-css3"><a class="markdownIt-Anchor" href="#html5-css3"></a> HTML5、CSS3</h2><h3 id="html5"><a class="markdownIt-Anchor" href="#html5"></a> HTML5</h3><h4 id="html5新增特性"><a class="markdownIt-Anchor" href="#html5新增特性"></a> HTML5新增特性</h4><ul><li><p>语义化标签：<code>header</code>、<code>nav</code>、<code>footer</code>、<code>section...</code></p></li><li><p>媒体标签：<code>audio</code>音频、<code>video视频</code></p></li><li><p>表单类型属性：<code>email</code>、<code>number</code>、<code>时间控件</code>、<code>color颜色拾取器</code>、<code>placeholder</code>、<code>autofocus自动获取焦点...</code></p></li><li><p>cavas绘图</p></li><li><p>web存储：<code>localStorage</code>、<code>sessionStorage</code></p></li></ul><h4 id="行内元素-块级元素有哪些"><a class="markdownIt-Anchor" href="#行内元素-块级元素有哪些"></a> 行内元素、块级元素有哪些</h4><p>行内元素：<code>a</code>、<code>span</code>、<code>img</code>、<code>input...</code></p><p>块级元素：<code>div</code>、<code>ul</code>、<code>li</code>、<code>ol</code>、<code>dt</code>、<code>dh</code>、<code>li</code>、<code>p</code>、<code>h1-6</code></p><h4 id="iframe的优缺点"><a class="markdownIt-Anchor" href="#iframe的优缺点"></a> iframe的优缺点</h4><p><strong>优点</strong>：</p><ul><li>原封不动的吧嵌入网页展示出来</li><li>增加代码的可重用</li><li>用来加载速度较慢的内容</li></ul><p><strong>缺点</strong>：</p><ul><li>iframe阻塞onload事件加载</li><li>网页内容无法被搜索引擎识别，对SEO不友好</li><li>会产生很多页面，不利于管理</li></ul><h4 id="canvas和svg的区别"><a class="markdownIt-Anchor" href="#canvas和svg的区别"></a> canvas和SVG的区别</h4><p><strong>canvas</strong>：通过javaScript来绘制2D图形，是逐像素进行渲染</p><ul><li>依赖分辨率</li><li>不支持事件处理</li><li>能够以.png或.jpg的格式进行保存</li><li>适合做游戏</li></ul><p><strong>SVG</strong>：基于XML描述的2D图形语言，是矢量图</p><ul><li>不依赖分辨率</li><li>支持事件处理</li><li>适合做大型区域渲染</li></ul><h4 id="回流重绘"><a class="markdownIt-Anchor" href="#回流重绘"></a> 回流重绘</h4><p><strong>回流</strong>当DOM变化影响了元素，比如元素的尺寸、布局、显示隐藏等改变了，需要重写构建。每个页面至少需要一次回流，就是在页面第一次加载的时候，这个时候一定会发生回流。</p><p><strong>重绘</strong>当一个元素的外观发生变化，但是没有改变布局，重新渲染元素的外观。比如<code>background-color</code>、<code>color</code></p><p><strong>回流必将引起重绘，而重绘不一定会引起回流</strong></p><p><strong>如何避免回流重绘：</strong></p><ul><li>避免使用<code>table</code>布局</li><li>尽可能在<code>DOM</code>树的最末端改变<code>class</code></li><li>避免设置多层内联样式</li><li>开启GPU加速</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或者<code>fixed</code>的元素上</li></ul><h4 id="src和href的区别"><a class="markdownIt-Anchor" href="#src和href的区别"></a> src和href的区别</h4><p><strong>src</strong>src指向外部资源的位置，将指向的内容嵌入到文档中当前标签所在的位置，如js脚本、<code>img</code>图片、<code>iframe</code>等</p><p><strong>href</strong>用于在当前文档和引用资源之间确立联系，一般是用在<code>link</code>、<code>a</code>等元素</p><h3 id="css3"><a class="markdownIt-Anchor" href="#css3"></a> CSS3</h3><h4 id="css3新增特性"><a class="markdownIt-Anchor" href="#css3新增特性"></a> CSS3新增特性</h4><ul><li>新增CSS选择器、伪类</li><li>特效：<code>text-shadow</code>、<code>box-shadow</code></li><li>渐变：<code>gradient</code></li><li>旋转过度：<code>transform</code>、<code>transtion</code></li><li>动画：<code>animation</code></li></ul><h4 id="盒模型"><a class="markdownIt-Anchor" href="#盒模型"></a> 盒模型</h4><p>盒模型都是有四部分组成：<code>content</code>、<code>padding</code>、<code>border</code>、<code>margin</code></p><p>标准盒模型和IE盒模型的区别在于设置<code>width</code>和<code>height</code>时，对应的范围不同</p><ul><li><p>标准盒模型的<code>width</code>、<code>height</code>只包含了<code>content</code></p></li><li><p>IE盒模型的<code>width</code>、<code>height</code>包含了<code>border</code>、<code>margin</code>、<code>padding</code></p></li></ul><p>通过修改元素的<code>box-sizing</code>属性来改变元素的盒模型</p><ul><li><code>box-sizeing: content-box</code>表示标准盒模型（默认值）</li><li><code>box-sizeing: border-box</code>表示IE盒模型（怪异盒模型)</li></ul><h4 id="trastion和aniamtion的区别"><a class="markdownIt-Anchor" href="#trastion和aniamtion的区别"></a> trastion和aniamtion的区别</h4><p><code>transtion</code>：属于过度属性，强调过度，需要一个事件进行触发（如鼠标进入、离开）类似<code>flash</code>的补间动画，设置一个开始帧和结束帧</p><p><code>aniamtion</code>：属于动画属性，它的实现不需要触发事件，设定好后可自动执行，且可以循环播放。也是类似补间动画，但是可以设置多个关键帧</p><h4 id="元素水平垂直居中"><a class="markdownIt-Anchor" href="#元素水平垂直居中"></a> 元素水平垂直居中</h4><ul><li><p>绝对定位：先将元素的左上角通过<code>top:50%</code>和<code>left:50%</code>定位到页面的中心，然后再通过<code>translate</code>来调整元素的中心点到页面的中心。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;    </span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.child</span> &#123;    </span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>绝对定位：设置四个方向的值都为0，并将<code>margin</code>设置为<code>auto</code>，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>flex</code>弹性盒子布局，通过<code>align-items:center</code>和<code>justify-content:center</code>设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="p-em-rem的区别"><a class="markdownIt-Anchor" href="#p-em-rem的区别"></a> p、em、rem的区别</h4><ul><li><code>px</code> 固定像素单位，不能随其它元素的变化而变化</li><li><code>em</code>是相对于父元素的单位，会随着父元素变化而变化</li><li><code>rem</code>是相对于根元素<code>html</code>，它会随着html元素变化而变化</li></ul><p><code>rem</code>常用在移动端项目，设置根元素的<code>fong-size</code>，其它元素会随着根元素的变化而变化，从而达到不同手机屏幕的自适应大小。通常会配合<code>postcss-pxtorem</code>插件进行使用</p><h4 id="如何解决1px问题"><a class="markdownIt-Anchor" href="#如何解决1px问题"></a> 如何解决1px问题</h4><ul><li>直接写<code>0.5px</code></li><li>利用伪元素，先放大再缩小</li><li>使用viewport缩放来解决</li></ul><h4 id="什么是bfc布局如何创建bfc布局"><a class="markdownIt-Anchor" href="#什么是bfc布局如何创建bfc布局"></a> 什么是BFC布局，如何创建BFC布局？</h4><p>BFC布局为<strong>块格式化上下文</strong>（Block Formatting Context，BFC）， 是CSS布局的一个概念，里面的元素不会影响到外面的元素。</p><p><strong>创建BFC</strong>：</p><ul><li>元素设置浮动：<code>float</code>有值并不为空</li><li>元素设置绝对定位：<code> position（absolute、fixed）</code></li><li><code>overfilow</code>值为：<code>hidden</code>、<code>auto</code>、<code>scroll</code></li><li><code>display</code>值为：<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>等</li></ul><p><strong>BFC作用</strong>：</p><ul><li>解决<code>margin</code>重叠问题：由于BFC是一个独立的区域，内部元素和外部元素互不影响，将两个元素变为BFC，就解决了margin重叠问题</li><li>创建自适应两栏布局：可以用来创建自适应两栏布局，左边宽高固定，右边宽度自适应。</li><li>解决高度塌陷问题：在子元素设置浮动后，父元素会发生高度的塌陷，也就是父元素的高度为0解决这个问题，只需要将父元素变成一个BFC。</li></ul><h4 id="link和import的区别"><a class="markdownIt-Anchor" href="#link和import的区别"></a> link和@import的区别</h4><ul><li><code>link</code>是HTML提供的标签，不仅可以加载<code>CSS</code>文件，还可以定义<code>RSS、rel</code>连接属性等</li><li><code>@import</code>是CSS提供等语法规则，只有导入样式表带作用。</li><li><code>link</code>标签引入的CSS被同时加载，而<code>@import</code>引入的CSS将在页面<strong>加载完毕</strong>后被加载</li><li><code>@import</code>是CSS2.1才有的语法，存在兼容性，而<code>link</code>作为HTML标签不存在兼容性问题</li></ul><h4 id="css选择器优先级"><a class="markdownIt-Anchor" href="#css选择器优先级"></a> CSS选择器优先级</h4><ul><li><code>@important</code></li><li>内联样式</li><li>ID选择器</li><li>类选择器/属性选择器/伪类选择器</li><li>元素选择器/伪元素选择器</li><li>关系选择器/通配符选择器</li></ul><h2 id="js基础"><a class="markdownIt-Anchor" href="#js基础"></a> JS基础</h2><h4 id="基础数据类型"><a class="markdownIt-Anchor" href="#基础数据类型"></a> 基础数据类型</h4><p><code>string</code>、<code>number</code>、<code>boolean</code>、<code>object</code>、<code>function</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code></p><p><code>null</code>和<code>undefined</code>的区别：<code>null</code>表示对是一个空的对象(object)、<code>undefined</code>是申明了但没赋值，在使用<code>typeo</code>f检测类型时，<code>nul</code>l为<code>object</code>，<code>undefined</code>为<code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>值类型（基本数据类型）：<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code></p><p>引用类型：<code>object</code>、<code>function</code>、<code>array</code></p><p>值类型和引用类型区别：</p><ul><li>值类型保存在<strong>栈</strong>中，<strong>占用空间固定</strong>，当一个方法执行时，每个方法都会创建自己的内存栈，方法中定义的变量会存放在这个内存栈中。当方法执行结束时，这个内存栈也会被销毁。所以，栈中存储的是基础变量。而引用变量存储在栈中是指向堆中的数组或对象的引用地址。这也就是为何修改引用类型总会影响到其它指向这个地址的引用变量。</li><li>值类型可以使用<code>typeof</code>进行数据类型检测</li><li>引用类型保存在<strong>堆</strong>中，<strong>占用空间不固定</strong>。创建对象会保存到堆内存中，这个内存不回随着方法结束而销毁，因为这个对象还可能被另外一个变量所引用，只有当一个对象没有被任何变量引用时，系统的垃圾回收机制会将它回收。</li><li>引用类型使用<code>instanceof</code>检测数据类型</li><li>使用new（）方法构造出来的对象是引用类型</li></ul><h4 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h4><p>闭包就是能够读取到其它函数内部变量的函数，创建一个最简单的闭包，就是在一个函数内部创建另外一个函数，创建的函数可以访问到当前函数的局部变量。在[[3-study/前端/手写基础函数#节流防抖|节流防抖]] 中广泛引用</p><p><strong>闭包优点：</strong></p><ul><li>创建全局私有变量，避免变量全局污染</li><li>可以实现封装、缓存等</li></ul><p><strong>闭包缺点：</strong></p><ul><li>创建的变量不能被回收，容易消耗内存，使用不当会导致内存溢出</li></ul><h4 id="变量提升-作用域-作用域链"><a class="markdownIt-Anchor" href="#变量提升-作用域-作用域链"></a> 变量提升、作用域、作用域链</h4><h5 id="变量提升"><a class="markdownIt-Anchor" href="#变量提升"></a> 变量提升</h5><p>js代码在解析的时候，会将所有的变量函数，提升到代码的最上面。变量提升，提升的只是变量申明，并不会吧变量赋值提升上来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h5><p>作用域是一个变量或函数的可访问范围，作用域控制着变量或函数的可见性和生命周期</p><ol><li><p>全局作用域：可以全局访问</p><ul><li>最外层函数和最外层定义的变量拥有全局作用域</li><li>window上的对象属性方法拥有全局作用域</li><li>为定义直接复制的变量自动申明拥有全局作用域</li><li>过多的全局作用域变量会导致变量全局污染，命名冲突</li></ul></li><li><p>函数作用域：只能在函数中访问使用哦</p><ul><li>在函数中定义的变量，都只能在内部使用，外部无法访问</li><li>内层作用域可以访问外层，外层不能访问内存作用域</li></ul></li><li><p>ES6中的块级作用域：只在代码块中访问使用</p><ul><li><p>使用ES6中新增的<code>let</code>、<code>const</code>什么的变量，具备块级作用域，块级作用域可以在函数中创建（由{}包裹的代码都是块级作用域）</p></li><li><p><code>let</code>、<code>const</code>申明的变量不会变量提升，<code>const</code>也不能重复申明</p></li><li><p>块级作用域主要用来解决由变量提升导致的变量覆盖问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">3</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fnc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fnc</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="作用域链"><a class="markdownIt-Anchor" href="#作用域链"></a> 作用域链</h5><p>变量在指定的作用域中没有找到，会依次向上一层作用域进行查找，直到全局作用域。这个查找的过程被称为作用域链。</p><h4 id="call-apply-bind区别"><a class="markdownIt-Anchor" href="#call-apply-bind区别"></a> call、apply、bind区别</h4><ul><li>都可以用作改变<code>this</code>指向</li><li><code>call</code>和<code>apply</code>的区别在于传参，<code>call</code>、<code>bind</code>都是传入对象。<code>apply</code>传入一个数组。</li><li><code>call</code>、<code>apply</code>改变this指向后会立即执行函数，<code>bind</code>在改变this后返回一个函数，不会立即执行函数，需要手动调用。</li></ul><h4 id="new操作符干了什么操作"><a class="markdownIt-Anchor" href="#new操作符干了什么操作"></a> new操作符干了什么操作</h4><ol><li><p>创建一个空对象</p></li><li><p>设置原型，将对象的原型设置到函数的<code>prototype</code>对象上</p></li><li><p>改变this指向，将this指向该对象，并执行构造函数。</p></li><li><p>判断函数的返回类型，如果是值类型，返回创建的对象。如果是引用类型，返回这个引用类型的对象。</p></li></ol><h4 id="1-blog设计模式js设计模式一面向对象封装原型和原型链-原型和原型链"><a class="markdownIt-Anchor" href="#1-blog设计模式js设计模式一面向对象封装原型和原型链-原型和原型链"></a> [[…/…/1-blog/设计模式/js设计模式(一)面向对象—封装#原型和原型链 |原型和原型链 ]]</h4><ul><li><p>原型: 每个对象在内部初始化的时候，都会初始化一个<code>prototype</code>原型属性 ，而对象的 <code>_proto_</code>属性，指向它的原型对象。</p></li><li><p>原型链: 当我们访问英国对象属性时，如果这个属性不存在，那么就会去它的原型对象上进行查找，而这个原型对象又会有自己的原型，会这样一直查找，知道找到顶级对象object为止。这个查找的过程被称为原型对象。</p></li></ul><h4 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h4><h5 id="原型链继承"><a class="markdownIt-Anchor" href="#原型链继承"></a> 原型链继承</h5><p>利用对象的原型链，将子类<code>Son.prototype</code>指向父类的构造函数创建出来的实例对象<code>new Person()</code></p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键代码</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>子类可以继承父类构造函数、原型上的属性方法</li></ul><p><strong>缺点：</strong></p><ul><li>父类引用类型的实例对象被共享，容易造成修改的混乱。</li><li>创建子类的时候不能向父类传参</li></ul><h5 id="构造函数继承"><a class="markdownIt-Anchor" href="#构造函数继承"></a> 构造函数继承</h5><p>利用<code>.call()</code>或者<code>.apply()</code>方法，在子类中借用父类的构造函数，初始化父类构造函数。</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="comment">// 关键代码  </span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>子类在继承父类时，可以向父类构造函数中传参。</li><li>不会造成子类势力之间引用属性共享。</li></ul><p>缺点：</p><ul><li>只能继承父类构造函数中的属性方法，无法访问原型上的方法。</li><li>每个子类都会创建一个父类副本</li></ul><h5 id="组合继承"><a class="markdownIt-Anchor" href="#组合继承"></a> 组合继承</h5><p>组合继承，将原型链继承和构造函数继承融合在一起。</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 借用构造函数继承关键代码</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链式继承关键代码</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">// 将子类的构造函数指向自己</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructon</span> = <span class="title class_">Son</span>;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>结合前面两种继承方式的优点，子类的实例可以访问到父类原型上的属性方法</li><li>子类的实例之间不会被共享</li></ul><p><strong>缺点：</strong></p><ul><li>调用了两次父类构造函数</li></ul><h5 id="原型式继承"><a class="markdownIt-Anchor" href="#原型式继承"></a> 原型式继承</h5><p>用函数包装一个对象，返回这个函数的调用（也就是ES5的Object.create的模拟实现），将传入的对象作为创建对象的原型</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个空的的构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将空的构造函数原型指向传递进来的对象</span></span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回一个实例对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj1 = <span class="title function_">create</span>(obj);</span><br><span class="line"><span class="keyword">const</span> newObj2 = <span class="title function_">create</span>(obj);</span><br></pre></td></tr></table></figure><p>优缺点和原型链式继承一样，引用类型还是会被共享。</p><h5 id="寄生式继承"><a class="markdownIt-Anchor" href="#寄生式继承"></a> 寄生式继承</h5><p>在原型式继承基础上，在函数内部来做增强函数，返回对象。</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="comment">// 获取继承的子类对象，也就是上面的create方法实现</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 函数增强</span></span><br><span class="line">  newObj.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 返回对象</span></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似原型式继承，但在原有的基础上可以自定义属性方法，依旧没有解决引用值被共享问题。（跟借用构造函数模式一样，每次创建对象都会创建一遍方法。）</p><h5 id="寄生组合式继承"><a class="markdownIt-Anchor" href="#寄生组合式继承"></a> 寄生组合式继承</h5><p>结合寄生继承和组合式继承优缺点，组合式继承缺点为调用了两次父类构造函数，优点为解决了引用值被共享问题。而寄生式继承缺点为没有解决引用值被共享问题，只要将两者结合就得到完美的继承方式。</p><p>🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">son, parent</span>) &#123;</span><br><span class="line">  <span class="comment">// 寄生式继承，利用父类构造函数的原型对象创建出一个新的对象，解决组合式继承创建两个父类问题</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Objcet</span>.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>)；</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将新对象的constructor构造函数执行子类</span></span><br><span class="line">newObj.<span class="property">constructor</span> = son;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将子类构造函数的原型指向心的  原型式继承</span></span><br><span class="line">  son.<span class="property">protoytype</span> = newObj; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 构造函数继承</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 实现继承</span></span><br><span class="line"><span class="title function_">createObj</span>(<span class="title class_">Son</span>, <span class="title class_">Person</span>)</span><br><span class="line"><span class="comment">// 更简洁的方式  在组合式继承的基础上  直接将son的原型通过API指向person的原型</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;zx&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;lw&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="深拷贝-浅拷贝"><a class="markdownIt-Anchor" href="#深拷贝-浅拷贝"></a> 深拷贝、浅拷贝</h4><h5 id="浅拷贝"><a class="markdownIt-Anchor" href="#浅拷贝"></a> 浅拷贝</h5><p>浅拷贝只是复制对象的值类型，通过<code>Object.assign</code>或者扩展运算符即可实现</p><h5 id="深拷贝"><a class="markdownIt-Anchor" href="#深拷贝"></a> 深拷贝</h5><p>通过递归实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否为对象</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !==<span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据obj类型创建数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? &#123;&#125; : [];</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 循环遍历obj，处理子元素为对象，递归拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newOb[key] = <span class="title function_">deepClone</span>(obj[key])</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="事件循环机制eventloop浏览器"><a class="markdownIt-Anchor" href="#事件循环机制eventloop浏览器"></a> 事件循环机制EventLoop（浏览器）</h4><h5 id="栈-队列理解"><a class="markdownIt-Anchor" href="#栈-队列理解"></a> 栈、队列理解</h5><ul><li><code>栈（Stack）</code>中的任务<strong>后进先出</strong>，js中的执行栈是一个存储函数的栈结构，栈中的任务执行遵循先进后出的原则依次执行。</li><li><code>队列（Queue）</code>中的任务<strong>先进先出</strong>，js运行时创建一个任务[[…/…/1-blog/数据结构/JavaScript数据结构之——队列|队列]]，用来处理列表（事件）和待执行的回调函数</li></ul><h5 id="宏观任务-微观任务"><a class="markdownIt-Anchor" href="#宏观任务-微观任务"></a> 宏观任务、微观任务</h5><p>js中的任务分为两种：<strong>宏观任务</strong><code>(MacroTask|Task)</code>、<strong>微观任务</strong><code>(MicorTask)</code>。</p><ul><li>宏任务：<code>script全部代码</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>I/O</code>、<code>UI Rendering</code></li><li>微任务：<code>Promise.then</code>、<code>Process.nexTick(Node独有)</code>、<code>MutationObserver</code></li></ul><h5 id="同步任务-异步任务"><a class="markdownIt-Anchor" href="#同步任务-异步任务"></a> 同步任务、异步任务</h5><p>js有一个<strong>主线程</strong>和一个<strong>执行栈（调用栈）</strong>，所有的任务都会放到执行栈中等待被主线程执行。</p><p>js代码在执行时，所有函数都会压入<strong>执行栈</strong>中。同步任务会按照<strong>后进先出</strong>原则依次执行，直到执行栈清空。异步任务会在异步任务有了结果后，将注册的回掉函数放入异步任务队列中，<strong>等待主线程空闲后（执行栈中的同步任务执行完毕）</strong>。</p><p>异步队列中的任务又分为<strong>宏观任务</strong>和<strong>微观任务</strong>，当当前执行栈清空后，处理异步队列中的任务时，首先会判断是否有微观任务可执行，如果有就将微观任务压入执行栈中执行。当微观队列中的任务在执行栈被执行完毕，再来异步队列中将宏观任务放入执行栈。</p><p>简单的来说：</p><ol><li>执行同步代码，这属于宏观任务</li><li>所有代码执行完毕，执行栈清空，执行异步队列中任务</li><li>异步队列中，先执行微观任务</li><li>微观任务执行完毕，再执行宏观任务</li></ol><h4 id="3-study前端手写基础函数节流防抖节流防抖"><a class="markdownIt-Anchor" href="#3-study前端手写基础函数节流防抖节流防抖"></a> [[3-study/前端/手写基础函数#节流防抖|节流防抖]]</h4><p>节流（throttle）：在n秒内只允许执行一次，</p><p>[[…/…/1-blog/防抖debounce理解|防抖]]（debounce）：在n秒内多次触发但不执行，而是在n秒后执行，如果n秒内触发则重新计算。</p><h4 id="事件冒泡-事件委托"><a class="markdownIt-Anchor" href="#事件冒泡-事件委托"></a> 事件冒泡、事件委托</h4><p>事件发生的三个阶段：<strong>捕获阶段</strong>、<strong>目标阶段</strong>、<strong>冒泡阶段</strong></p><ul><li>事件冒泡：在一个对象上触发某类事件，如果此对象绑定了事件，就会触发事件，如果没有，就会向这个对象的父级对象传播，最终父级对象触发事件。<ul><li>如何阻止：<ul><li>普通浏览器：<code>event.stopPropagation()</code></li><li>IE浏览器：<code>event.cancelBubble = true</code>;</li></ul></li></ul></li><li>事件委托：利用浏览器事件冒泡机制。事件在冒泡的过程中会传到父节点，并且父节点可以通过事件对象获取到目标节点，可以吧子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件<ul><li>事件委托可以不必要为每一个子节点都绑定监听事件，减少内存上的消耗。</li><li>使用事件委托还可以实现事件的动态绑定，比如新增一个子节点，并不需要为此单独增加一个监听事件，可以由父元素中的监听函数来处理。</li></ul></li></ul><h4 id="对dom元素进行增删改查"><a class="markdownIt-Anchor" href="#对dom元素进行增删改查"></a> 对DOM元素进行增删改查</h4><h5 id="增"><a class="markdownIt-Anchor" href="#增"></a> 增</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>()</span><br></pre></td></tr></table></figure><h5 id="删"><a class="markdownIt-Anchor" href="#删"></a> 删</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">removeAttribute</span>()</span><br><span class="line">element.<span class="title function_">removeChild</span>()</span><br></pre></td></tr></table></figure><h5 id="改"><a class="markdownIt-Anchor" href="#改"></a> 改</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">innerHTML</span>()</span><br><span class="line">element.<span class="title function_">setAttribute</span>()</span><br></pre></td></tr></table></figure><h5 id="查"><a class="markdownIt-Anchor" href="#查"></a> 查</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getElementById()</span><br><span class="line">getElementsByClassName()</span><br><span class="line">getElementsByTagName()</span><br><span class="line">querySelector()</span><br><span class="line">querySelectorAll()</span><br></pre></td></tr></table></figure><h4 id="ajax-axios-fetch区别"><a class="markdownIt-Anchor" href="#ajax-axios-fetch区别"></a> ajax、axios、fetch区别</h4><p><strong>ajax</strong></p><ul><li>基于原生的XHR开发</li><li>本身针对MVC编程，不符合现在前端MVVM潮流</li></ul><p><strong>axios</strong></p><ul><li><p>从浏览器中创建<code>XMLHttpRequest</code></p></li><li><p>支持<code>promise</code></p></li><li><p>支持请求拦击和响应拦截</p></li><li><p>从node.js创建http请求</p></li><li><p>客服端支持防止<code>CSRF/XSRF</code></p></li></ul><p><strong>fetch</strong></p><ul><li>浏览器原生实现的请求方式，ajax的替代品</li><li>只对网络请求报错，对400、500都当做成功的请求，需要封装</li><li>fetch默认不会带cookie，需要添加配置项</li><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li><li>fetch没有办法原生监测请求的进度，而XHR可以</li></ul><h2 id="es6"><a class="markdownIt-Anchor" href="#es6"></a> ES6</h2><h3 id="var-let-const区别"><a class="markdownIt-Anchor" href="#var-let-const区别"></a> var、let、const区别</h3><ul><li><code>var</code>声明变量可以重复声明，而<code>let</code>不可以</li><li><code>var</code>是不受限于块级作用域，而<code>let</code>受限</li><li><code>var</code>存在变量提升，<code>let</code>和<code>const</code>不存在变量提升</li><li><code>cons</code>t声明的变量不可变</li><li><code>const</code>声明之后必须赋值，否则会报错</li></ul><h3 id="3-study前端手写基础函数promisepromise"><a class="markdownIt-Anchor" href="#3-study前端手写基础函数promisepromise"></a> [[3-study/前端/手写基础函数#promise|Promise]]</h3><p><code>Promise</code>是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p><p>它有三种状态</p><ul><li><code>pending</code>初始状态</li><li><code>fulfilled</code>操作成功</li><li><code>rejected</code>操作失败。</li></ul><p><code>Promise</code>状态改变只有两种可能</p><ul><li>从<code>pending</code>------&gt;<code>fulfilled</code></li><li>从<code>pending</code>------&gt;<code>rejected</code></li></ul><p><code>Promise</code>构造函数接收一个参数和一个带有<code>resolve</code>和<code>reject</code>参数的回调函数。</p><ul><li><code>resolve</code>的作用是将<code>Promise</code>状态从<code>pending</code>变为<code>fulfilled</code>，在异步操作成功时调用，并将异步结果返回，作为参数传递出去</li><li><code>reject</code>的作用是将<code>Promise</code>状态从<code>pending</code>变为<code>rejected</code>，在异步操作失败后，将异步操作错误的结果，作为参数传递出去</li></ul><p><code>Promise</code>实例方法</p><ul><li><code>promise.then()</code>  对应<code>resolve</code>成功的处理</li><li><code>promise.catch()</code>对应<code>reject</code>失败的处理</li><li><code>promise.call()</code>将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例，返回的实例就是普通的<code>Promise</code>。有一个失败，代表该<code>Primise</code>失败。当所有的子<code>Promise</code>完成，返回值时全部值的数组</li><li><code>promise.race()</code>类似<code>promise.all()</code>，区别在于有任意一个完成就算完成（例如：将异步和定时器放在一起，设置请求超时）</li></ul><h3 id="箭头函数和普通函数的区别"><a class="markdownIt-Anchor" href="#箭头函数和普通函数的区别"></a> 箭头函数和普通函数的区别</h3><ul><li>箭头函数时<strong>匿名函数</strong>，不能作为构造函数，不能使用<code>new</code></li><li>箭头函数不绑定<code>arguments</code></li><li>箭头函数没有自己的<code>this</code>，将所在的上下文的<code>this</code>作为自己的<code>this</code>值</li><li>没有<code>prototype</code></li><li><code>call()</code>、<code>applay()</code>、<code>bind()</code>方法不能改变箭头函数中的<code>this</code>指向</li></ul><h3 id="foreach和map的区别"><a class="markdownIt-Anchor" href="#foreach和map的区别"></a> forEach和map的区别</h3><ul><li><code>forEach</code>返回值是<code>undefined</code>，不可以链式调用</li><li><code>map()</code>返回一个新的数组，不改变原数组。<code>forEach</code>改变原数组。</li></ul><h3 id="set-map的区别"><a class="markdownIt-Anchor" href="#set-map的区别"></a> Set、Map的区别</h3><h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h4><ul><li>创建：<code>  new Set([1, 1, 2, 3, 3, 4, 2])</code></li><li><code>add(value)</code>：添加某个值，返回Set结构本身。</li><li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li><li><code>clear()</code>：清除所有成员，没有返回值。</li></ul><h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h4><ul><li><code>set(key, val):</code> 向<code>Map</code>中添加新元素</li><li><code>get(key):</code> 通过键值查找特定的数值并返回</li><li><code>has(key): </code>判断<code>Map</code>对象中是否有<code>Key</code>所对应的值，有返回<code>true</code>,否则返回<code>false</code></li><li><code>delete(key): </code>通过键值从<code>Map</code>中移除对应的数据</li><li><code>clear():</code> 将这个<code>Map</code>中的所有元素删除</li></ul><h4 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h4><ul><li><code>Map</code>是一种键值对的集合，和对象不同的是，键可以是任意值</li><li><code>Map</code>可以遍历，可以和各种数据格式转换</li><li><code>Set</code>是类似数组的一种的数据结构，但在Set中没有重复的值</li></ul><h3 id="谈谈你对es6对理解"><a class="markdownIt-Anchor" href="#谈谈你对es6对理解"></a> 谈谈你对ES6对理解</h3><ul><li>解构赋值</li><li>扩展运算符</li><li>模版字符串</li><li>箭头函数</li><li><code>async/await</code></li><li><code>Class</code></li><li>引入<code>Moldule</code>语法</li><li><code>class</code>类</li></ul><h2 id="vue"><a class="markdownIt-Anchor" href="#vue"></a> Vue</h2><h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3><h4 id="mvvm"><a class="markdownIt-Anchor" href="#mvvm"></a> MVVM</h4><p><code>MVVM</code>是一种软件架构模式，在vue中 M 代表<code>model</code>层（数据模型），负责数据模型。V代表<code>View</code>层（视图层），VM代表<code>ViewModel</code>（视图模型），它是<code>Model</code>和<code>View</code>之间的桥梁，数据会绑定到<code>viewModel</code>层，并自动将数据渲染到页面层，视图变化时会通知<code>viewModel</code>更新数据</p><h4 id="vue生命周期"><a class="markdownIt-Anchor" href="#vue生命周期"></a> Vue生命周期</h4><p><strong>创建前后：</strong></p><ul><li><code>beforeCreated（创建前）：</code> 数据观测和初始化事件还未开始，不能访问<code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code>上的数据方法。</li><li><code>created(创建后)：</code>实例创建完成，可以访问<code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code>上的数据方法，但此时渲染节点还未挂在到DOM上，所以不能访问。</li></ul><p><strong>挂载前后：</strong></p><ul><li><code>beforeMounted（挂载前）:</code> Vue实例还未挂在到页面html上，此时可以发起服务器请求</li><li><code>mounted（挂载后）:</code>Vue实例已经挂在完毕，可以操作DOM</li></ul><p><strong>更新前后：</strong></p><ul><li><code>beforeUpdate（更新前）:</code> 数据更新之前调用，还未渲染页面</li><li><code>updated（更新后）:</code>DOM重新渲染，此时数据和界面都是新的。</li></ul><p><strong>销毁前后：</strong></p><ul><li><code>beforeDestoryed（销毁前）:</code>实例销毁前调用，这时候能够获取到<code>this</code></li><li><code>destoryed（销毁后）:</code>实例销毁后调用，实例完全被销毁。</li></ul><h4 id="watch和computed的区别"><a class="markdownIt-Anchor" href="#watch和computed的区别"></a> watch和computed的区别</h4><p>watch：监听属性，用来监听数据的变化，没有缓存，当监听到的数据发生变化时都会执行毁掉函数</p><p>computed：计算属性，被监听的值有缓存，只有它依赖的属性值发生变化后，下一次获取computed的值时才会重新计算computed的值。（只有依赖发生变化后才会重新计算）</p><h4 id="v-for中key的作用"><a class="markdownIt-Anchor" href="#v-for中key的作用"></a> v-for中key的作用</h4><p>key是为了更高效的对比虚拟DOM中的每个节点是否相同，避免页面更新时重复更新节点</p><h4 id="v-if和v-show的区别"><a class="markdownIt-Anchor" href="#v-if和v-show的区别"></a> v-if和v-show的区别</h4><p><code>v-if</code>元素不可见 删除dom元素</p><p><code>v-show</code>元素可见  通过设置元素的<code>display：none</code>样式属性</p><h4 id="组件中的data为什么是一个函数"><a class="markdownIt-Anchor" href="#组件中的data为什么是一个函数"></a> 组件中的data为什么是一个函数</h4><p>因为对象是一个引用类型，如果data时一个对象的情况下会造成多个组件共用一个data，data为一个函数，每个组件都会有自己的私有数据空间，不会干扰其他组件的运行。</p><h4 id="vue组件通信"><a class="markdownIt-Anchor" href="#vue组件通信"></a> Vue组件通信</h4><h5 id="父子组件"><a class="markdownIt-Anchor" href="#父子组件"></a> 父子组件</h5><p>父传子</p><ul><li>props</li><li>$children</li><li>$refs</li></ul><p>子传父</p><ul><li>$emit</li><li>$parent</li></ul><h5 id="兄弟组件"><a class="markdownIt-Anchor" href="#兄弟组件"></a> 兄弟组件</h5><ul><li>provied</li><li>inject</li><li>eventBus</li><li>Vuex</li></ul><h4 id="vuex的基本使用"><a class="markdownIt-Anchor" href="#vuex的基本使用"></a> Vuex的基本使用</h4><p>Vuex用于vue中的数据状态管理，有五种属性：</p><ol><li><code>state</code>：<code>Vuex</code>的基本数据，用于存储变量</li><li><code>getter</code>：从<code>state</code>派生出来的数据，当相遇<code>state</code>的计算属性，在这里可以对<code>state</code>数据进行过滤、筛选等操作</li><li><code>mutation</code>：提交更新<code>state</code>数据的方法</li><li><code>action</code>：和<code>mutation</code>功能相似，都是用来提交更新，但<code>action</code>提交的是<code>mutation</code>，而不是直接变更数据，并且<code>action</code>可以包含异步操作</li><li><code>module</code>：模块化Vuex，每个模块都有自己的<code>state</code>、<code>mutation</code>、<code>actoion</code>、<code>getter</code></li></ol><h5 id="mutation和action的区别"><a class="markdownIt-Anchor" href="#mutation和action的区别"></a> mutation和action的区别</h5><ul><li><code>mutation</code>更专注于修改<code>state</code>，必须是同步执行。</li><li><code>action</code>提交的是<code>mutation</code>，而不是直接更新数据，可以是异步的。</li><li><code>action</code>可以整合多个<code>mutation</code></li></ul><h4 id="vuex和localstory的区别"><a class="markdownIt-Anchor" href="#vuex和localstory的区别"></a> Vuex和localstory的区别</h4><ul><li><code>Vuex</code>存储在内存中，页面关闭刷新就会消失。而<code>localstorage</code>存储在本地，读取内存比读取硬盘速度要快</li><li><code>Vuex</code>应用于组件之间的传值，<code>localstorage</code>主要用于不同页面之间的传递</li><li><code>Vuex</code>是响应式的，<code>localstorage</code>需要刷新</li></ul><h4 id="路由守卫"><a class="markdownIt-Anchor" href="#路由守卫"></a> 路由守卫</h4><ul><li>全局前置钩子：<code>beforeEach</code>、<code>beforeResolve</code>、<code>afterEach</code></li><li>路由独享守卫：<code>beforeEnter</code></li><li>组件内钩子：<code>beforeRouterEnter</code>、<code>beforeRouterUpdate</code>、<code>beforeRouterLeave</code></li></ul><h4 id="hash和history的区别"><a class="markdownIt-Anchor" href="#hash和history的区别"></a> hash和history的区别</h4><h5 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> hash</h5><p>hash模式是vue开发中的默认模式，地址栏URL携带<code>#</code>，<code>#</code>后为路由。</p><p>原理是通过<code>onhashchange()</code>事件监听路由<code>hash</code>的变化，这个好处就是当<code>hash</code>值发生变化，不需要向后端发起请求，<code>window</code>就可以监听事件的改变，并按照规则加载项对应的代码。除此之外，<code>hash</code>值的变化对应的<code>URL</code>都会被浏览器记录下来，这样就能实现浏览器历史页面的前进后退。</p><h5 id="history"><a class="markdownIt-Anchor" href="#history"></a> history</h5><p>vue还提供<code>history</code>模式，在<code>history</code>模式下URL中没有<code>#</code>，相比hash模式更加好看。但是需要后台配置支持。</p><p><code>history</code>的原理是利用<code>HTML5中hostory</code>提供的<code>pushState</code>、<code>replaceState</code>这两个API，这两个API记录了浏览器历史栈，并且当在修改<code>URL</code>时不会触发页面刷新和后台请求。</p><h4 id="动态路由"><a class="markdownIt-Anchor" href="#动态路由"></a> 动态路由</h4><h5 id="定义方式"><a class="markdownIt-Anchor" href="#定义方式"></a> 定义方式</h5><ul><li>params传参<ul><li>路由配置： <code>/index/:id</code></li><li>路由跳转：<code>this.$router.push(&#123;name: 'index', params: &#123;id: &quot;zs&quot;&#125;&#125;);</code></li><li>路由参数获取：<code>this.params.id</code></li><li>最后形成的路由：<code>/index/zs</code></li></ul></li><li>query传参<ul><li>路由配置：<code>/index</code>正常的路由配置</li><li>路由跳转：<code>this.$rouetr.push(&#123;path: 'index', query:&#123;id: &quot;zs&quot;&#125;&#125;);</code></li><li>路由参数获取：<code>this.query.id</code></li><li>最后形成的路由：<code>/index?id=zs</code></li></ul></li></ul><h5 id="router-和route"><a class="markdownIt-Anchor" href="#router-和route"></a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext>和</mtext></mrow><annotation encoding="application/x-tex">router 和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">和</span></span></span></span>route</h5><ul><li><code>$router</code>是指整个路由对象，可以使用<code>this.$router.push(&#123;name: ;index'&#125;)</code>进行页面跳转</li><li><code>$route</code>时指当前页面的路由对象，可以使用<code>this.$route.parmas.id</code>来获取当前路由对象传递进来的参数</li></ul><h4 id="vue性能优化"><a class="markdownIt-Anchor" href="#vue性能优化"></a> Vue性能优化</h4><h3 id="原理知识"><a class="markdownIt-Anchor" href="#原理知识"></a> 原理知识</h3><h4 id="双向绑定原理"><a class="markdownIt-Anchor" href="#双向绑定原理"></a> 双向绑定原理</h4><p>data在初始化的时候，会实例化一个<code>Observe</code>类，在它会将data数据进行递归遍历，并且通过<code>definereactive</code>方法，这个方法通过<code>Object.defineProperty</code>方法，给每个值添加上一个<code>getter</code>和一个<code>setter</code>。在数据读取的时候会触发getter进行依赖（Watcher）收集，当数据改变时，会触发<code>setter</code>，对刚刚收集的依赖进行触发，并且更新<code>watcher</code>通知视图进行渲染。</p><h4 id="依赖收集"><a class="markdownIt-Anchor" href="#依赖收集"></a> 依赖收集</h4><p>依赖收集发生在<code>defineReactive()</code>方法中，在方法内<code>new Dep()</code>实例化一个<code>Dep()</code>实例，然后在<code>getter</code>中通过<code>dep.depend()</code>方法对数据依赖进行收集，然后在<code>settter</code>中通过<code>dep.notify()</code>通知更新。整个<code>Dep</code>其实就是一个观察者，吧收集的依赖存储起来，在需要的时候进行调用。在收集数据依赖的时候，会为数据创建一个<code>Watcher</code>，当数据发生改变通知每个<code>Watcher</code>，由<code>Wathcer</code>进行更新渲染。</p><h4 id="objectdefineproperty数据劫持缺陷"><a class="markdownIt-Anchor" href="#objectdefineproperty数据劫持缺陷"></a> Object.defineProperty()数据劫持缺陷</h4><p>该方法只能监听到数据的修改，监听不到数据的新增和删除。vue2中会对数组的新增删除方法<code>push、pop、shift、unshift、splice、sort、reserve</code>通过重写的形式，在拦截里面进行手动收集触发依赖更新。</p><p>在vue2中，需要数据里添加或删除时，使用<code>vue.$set/vue.$delete</code>进行操作。</p><p>在Vue3中，改用<code>proxy</code>对对象进行代理，返回一个代理对象，只需要操作新对象就可以。</p><h4 id="双向绑定原理-2"><a class="markdownIt-Anchor" href="#双向绑定原理-2"></a> 双向绑定原理</h4><p>Vue双向绑定是一个指令<code>v-model</code>，可以将数据动态绑定到视图上，同时视图中变化也可以改变改值。他的本质是 <code>v-bind</code> 和 <code>v-on</code> 的语法糖。在 ⼀个组件上使⽤ <code>v-model </code>，默认会为组件绑定名为 <code>value </code>的 prop 和名为 <code>input </code>的事件。</p><h4 id="nexttick的实现"><a class="markdownIt-Anchor" href="#nexttick的实现"></a> nextTick的实现</h4><p>vue中的<code>nextTick</code>是浏览器<code>eventLoop</code>是应用。<code>nextTick</code>是将回调函数放到一个异步队列中，保证在异步更新DOM的<code>watcher</code>后面，从而获取到更新后的DOM。</p><p>Vue在更新DOM时是异步执行的。只要侦听到数据变化，<code>Vue</code>将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</p><h4 id="怎么理解-vue-中的虚拟-dom"><a class="markdownIt-Anchor" href="#怎么理解-vue-中的虚拟-dom"></a> 怎么理解 vue 中的虚拟 DOM</h4><p>虚拟DOM，就是用一个<code>JS</code>对象来描述一个<code>DOM</code>节点。<code>Vue</code>是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作<code>DOM</code>,而操作真实<code>DOM</code>又是非常耗费性能的，这是因为浏览器的标准就把 <code>DOM</code> 设计的非常复杂，所以一个真正的 <code>DOM</code> 元素是非常庞大的。<code>VNode</code>类中包含了描述一个真实<code>DOM</code>节点所需要的一系列属性，<code>tag</code>表示节点的标签名，<code>text</code>表示节点中包含的文本，<code>children</code>表示该节点包含的子节点等。</p><h4 id="模版编译原理"><a class="markdownIt-Anchor" href="#模版编译原理"></a> 模版编译原理</h4><p>模版编译主要过程：<code>template ---&gt; ast ---&gt; render</code>，分别对象三个方法</p><ul><li><code>parse</code> 函数解析 <code>template</code></li><li><code>optimize</code> 函数优化静态内容</li><li><code>generate</code> 函数创建 <code>render</code> 函数字符串</li></ul><p>调用<code>parse</code>方法，将<code>template</code>转化为<code>AST</code>（抽象语法树），<code>AST</code>定义了三种类型，一种<code>html</code>标签，一种文本，一种插值表达式，并且通过 <code>children</code> 这个字段层层嵌套形成了树状的结构。</p><p><code>optimize</code>方法对<code>AST</code>树进行静态内容优化，分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化。</p><p><code>generate</code>将<code>AST</code>抽象语法树编译成 <code>render</code>字符串，最后通过<code>new Function(render)</code>生成可执行的<code>render</code>函数</p><h4 id="diff算法逻辑"><a class="markdownIt-Anchor" href="#diff算法逻辑"></a> diff算法逻辑</h4><p><code>diff</code>算法发生在视图更新阶段，也就是当数据发生变化的时候，<code>diff</code>会对新就虚拟DOM进行对比，只渲染有变化的部分。</p><p>当数据发生变化的时候，依赖对应的<code>watcher</code>会通知更新，生成一个新的<code>vnode</code>，新的<code>vnode</code>会去和旧的<code>vnode</code>进行对比更新。</p><p>整个更新的过程就是调用path函数，主要做了三件事：</p><ul><li>创建节点：新的<code>vnode</code>中有而旧的<code>vnode</code>中的节点，在旧<code>vnode</code>中进行创建</li><li>删除节点：新的<code>vnode</code>中没有二旧的<code>vnode</code>中有，在旧的<code>vnode</code>中删除</li><li>更新节点：新的<code>vnode</code>和旧的<code>vnode</code>中都有，以新的<code>vnode</code>位主，更新旧的<code>vnode</code></li></ul><h4 id="new-vue的流程"><a class="markdownIt-Anchor" href="#new-vue的流程"></a> new Vue的流程</h4><p>合并配置，调用一些初始化函数，触发生命周期钩子函数，调用<code>$mount</code>开启下一个阶段。</p><h4 id="keep-live原理"><a class="markdownIt-Anchor" href="#keep-live原理"></a> keep-live原理</h4><p><code>keep-alive</code>是Vue.js的一个内置组件。它能够将不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。</p><p>通过<code>include、exclude</code>来匹配和排除缓存，<code>max</code>定义缓存的上限。</p><p><code>keep-alive</code>内部其实是一个函数式组件，没有<code>template</code>标签。在<code>render</code>中通过获取组件的<code>name</code>和<code>include、exclude</code>进行匹配。匹配不成功，则不需要进行缓存，直接返回该组件的Vnode。</p><p>匹配成功就进行缓存，获取组件的<code>key</code>在<code>this.cache</code>中进行查找，如果存在就直接将缓存的组件实例覆盖到当前的Vnode上，然后将当前组件的<code>key</code>从<code>keys</code>中进行删除，然后在<code>push(key)</code>添加到尾部，这样做是为了改变<code>key</code>当前的位置，也就实现了<code>max</code>功能。</p><p>不存在的话，就需要对组件进行缓存。将当前组件<code>push(key)</code>添加到尾部，然后再判断当前缓存的max是否超出指定个数，如果超出直接将第一个组件销毁（缓存淘汰策略LRU）。</p><blockquote><p>LRU（<strong>Least recently used</strong>，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p></blockquote><h2 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化"></a> 性能优化</h2><h3 id="网站优化"><a class="markdownIt-Anchor" href="#网站优化"></a> 网站优化</h3><ul><li>使用浏览器缓存机制</li><li>资源懒加载、预加载</li><li>骨架屏</li><li>合理使用雪碧图、字体图标、</li></ul><h3 id="代码优化"><a class="markdownIt-Anchor" href="#代码优化"></a> 代码优化</h3><ul><li>减少回流重绘</li><li>减少DOM的操作</li><li>节流防抖</li><li>使用事件委托</li><li>将CSS文件放在头部、js文件放在底部</li></ul><h3 id="请求优化"><a class="markdownIt-Anchor" href="#请求优化"></a> 请求优化</h3><ul><li>使用CDN加速</li><li>开启nginx，Gzip压缩</li><li>使用强缓存、协商缓存</li><li>减少、合并请求</li></ul><h3 id="webpack优化"><a class="markdownIt-Anchor" href="#webpack优化"></a> webpack优化</h3><ul><li>按需加载</li><li>代码打包体积压缩</li><li>移除console</li><li>压缩图片、字体等本地资源</li><li>分离css文件，单独进行打包</li></ul><h2 id="浏览器相关"><a class="markdownIt-Anchor" href="#浏览器相关"></a> 浏览器相关</h2><h3 id="跨域"><a class="markdownIt-Anchor" href="#跨域"></a> 跨域</h3><p>浏览器的同源策略会导致跨域问题</p><h4 id="同源策略"><a class="markdownIt-Anchor" href="#同源策略"></a> 同源策略</h4><p>同源指的是：<strong>协议</strong>、<strong>端口号</strong>、<strong>域名</strong>必须一致。</p><p>同源策略的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作</p><h4 id="解决跨域问题"><a class="markdownIt-Anchor" href="#解决跨域问题"></a> 解决跨域问题</h4><ul><li>CORS：服务器开启跨域资源共享</li><li>JSONP：利用JavaScript标签不存在跨域限制，只支持GET请求</li><li>Nginx：反向代理</li></ul><h3 id="本地存储"><a class="markdownIt-Anchor" href="#本地存储"></a> 本地存储</h3><h4 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> Cookie</h4><ul><li>存储小，只有4k</li><li>不同域之间不能共享</li><li>不安全，容易被拦截</li></ul><h4 id="sessionstorage"><a class="markdownIt-Anchor" href="#sessionstorage"></a> SessionStorage</h4><ul><li>存储在内存中，体积相对较大</li><li>页面关闭，数据会删除</li><li>相对Cookie安全</li></ul><h4 id="localstorage"><a class="markdownIt-Anchor" href="#localstorage"></a> LocalStorage</h4><ul><li>体积大，可以存储更多内容</li><li>生命周期长，需要手动删除</li><li>存储在硬盘，不会像cookie一样被请求携带</li></ul><h3 id="从输入一个-url-地址到浏览器完成渲染的整个过程"><a class="markdownIt-Anchor" href="#从输入一个-url-地址到浏览器完成渲染的整个过程"></a> 从输入一个 URL 地址到浏览器完成渲染的整个过程</h3><ol><li>浏览器输入<code>URL</code>并回车</li><li>浏览器查找当前是否有缓存</li><li><code>DNS</code>解析<code>URL</code>得到<code>IP</code><ol><li>浏览器<code>DNS</code>缓存</li><li><code>host</code>文件缓存</li></ol></li><li>建立<code>TCP</code>连接（三次握手）</li><li>发送<code>HTTP</code>请求</li><li>服务器处理请求，浏览器得到响应数据</li><li>浏览器解析渲染页面<ol><li>解析<code>DOM</code>生成<code>DOM</code>树</li><li>解析<code>CSS</code>生成<code>CSS</code>树</li><li>合并<code>DOM</code>树和<code>CSS</code>树，生成渲染树</li><li>浏览器开始渲染页面（回流重绘发生在这个阶段）</li></ol></li><li><code>TCP</code>连接关闭（四次挥手）</li></ol><h2 id="网络协议-安全相关"><a class="markdownIt-Anchor" href="#网络协议-安全相关"></a> 网络协议、安全相关</h2><h3 id="tcp-udp协议"><a class="markdownIt-Anchor" href="#tcp-udp协议"></a> TCP、UDP协议</h3><p><code>TCP</code>和<code>UDP</code>都是在传输层定义的两种传输协议。基于<code>UDP</code>协议传输不能保证数据准确无误的送达，但<code>UDP</code>不仅可以支持一对一的传输方式，还可以支持一对一、一对多等形式。也不需要像<code>TCP</code>一样建立连接，所以传输速度快。</p><p><code>TCP</code>的目的是提供可靠的数据，并且需要在传输前建立连接（三次握手）。只支持一对一进行传输。</p><p><strong>区别：</strong></p><ul><li><code>TCP</code>协议可靠，<code>UDP</code>协议不可靠</li><li><code>TCP</code>面向连接，<code>UDP</code>采用无连接</li><li><code>TCP</code>可以保证数据顺序，<code>UDP</code>不能</li><li><code>TCP</code>一对一传输，<code>UDP</code>可以一对多、多对一等形式</li></ul><h3 id="http和https区别"><a class="markdownIt-Anchor" href="#http和https区别"></a> HTTP和HTTPS区别</h3><ul><li><code>HTTP</code>是明文传输，不安全。<code>HTTPS</code>基于<code>SSL</code>进行加密传输，比较安全。</li><li><code>HTTPS</code>需要<code>CA</code>证书，<code>HTTP</code>不需要。</li><li><code>HTTP</code>端口为<code>80</code>，<code>HTTPS</code>端口为<code>443</code></li></ul><h3 id="http状态码"><a class="markdownIt-Anchor" href="#http状态码"></a> HTTP状态码</h3><ul><li>1XX: 请求正在处理</li><li>2XX：正常状态码<ul><li>200 ：请求处理成功</li><li>201 ： 请求成功并且服务器创建了新资源</li><li>202 ：服务器已经接收请求，但尚未处理</li></ul></li><li>3XXX：重定向状态<ul><li>301 ：请求重定向</li><li>302:  临时重定向</li><li>303:  临时重定向，使用get请求新的url</li><li>304：浏览器缓存相关</li></ul></li><li>4XX：错误状态码<ul><li>400: 服务器无法理解请求格式，需要修改请求内容后再次发起请求</li><li>401: 请求未授权</li><li>403: 禁止访问</li><li>404: 服务器上无法找到请求资源</li></ul></li><li>5XX：服务器错误<ul><li>500: 服务端错误</li><li>503: 服务器暂时无法处理请求</li></ul></li></ul><h3 id="http三次握手-四次挥手"><a class="markdownIt-Anchor" href="#http三次握手-四次挥手"></a> HTTP三次握手、四次挥手</h3><h4 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h4><p>三次握手是在建立<code>TCP</code>连接时，客户端和服务端总共发送三个包。进行三次握手的主要目的就是为了确认双方的接受能力和发送能力都是正常的，为后面传输可靠数据做准备。</p><p><strong>报文：</strong></p><ul><li>序号：表示发送的数据字节流，确保TCP传输有序，对每个字节编号</li><li>确认序号：发送方期待接收的下一序列号，接收成功后的数据字节序列号加 1。只有<code>ACK=1</code>时才有效。</li><li><code>ACK</code>：确认序号的标志，<code>ACK=1</code>表示确认号有效，<code>ACK=0</code>表示报文不含确认序号信息</li><li><code>SYN</code>：连接请求序号标志，用于建立连接，<code>SYN=1</code>表示请求连接</li><li><code>FIN</code>：结束标志，用于释放连接，<code>FIN=1</code>表示关闭本方数据流</li></ul><p><strong>三次握手：</strong></p><ol><li>第一次握手：客户端给服务端发一个 <code>SYN </code>报文，并指明客户端的初始化序列号<code> ISN</code>，此时客户端处于 <code>SYN_SEND</code> 状态。</li><li>务器收到客户端的<code> SYN</code> 报文之后，会以自己的<code>SYN</code>报文作为应答，并且也是指定了自己的初始化序列号<code> ISN</code>。同时会把客户端的 <code>ISN + 1 </code>作为<code>ACK</code>的值，表示自己已经收到了客户端的<code> SYN</code>，此时服务器处于 <code>SYN_REVD </code>的状态。</li><li>客户端收到<code>SYN</code>报文之后，会发送一个 <code>ACK </code>报文，当然，也是一样把服务器的 <code>ISN + 1 </code>作为 <code>ACK </code>的值，表示已经收到了服务端的 <code>SYN </code>报文，此时客户端处于<code> ESTABLISHED</code> 状态。服务器收到 <code>ACK </code>报文之后，也处于 <code>ESTABLISHED 状</code>态，此时，双方已建立起了连接。</li></ol><h4 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h4><ol><li>客户端会发送一个<code>FIN</code>报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1 </code>状态。</li><li>服务端收到 <code>FIN</code> 之后，会发送 <code>ACK</code> 报文，且把客户端的序列号值 +1 作为 <code>ACK </code>报文的序列号值，表明已经收到客户端的报文了，此时服务端处于<code> CLOSE_WAIT</code> 状态。</li><li>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 <code>FIN </code>报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK </code>的状态。</li><li>客户端收到<code> FIN</code> 之后，一样发送一个<code>ACK</code>报文作为应答，且把服务端的序列号值 +1 作为自己 <code>ACK </code>报文的序列号值，此时客户端处于 <code>TIME_WAIT </code>状态。需要过一阵子以确保服务端收到自己的 <code>ACK</code> 报文之后才会进入 <code>CLOSED </code>状态，服务端收到 <code>ACK </code>报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。</li></ol><h4 id="为什么需要四次挥手"><a class="markdownIt-Anchor" href="#为什么需要四次挥手"></a> 为什么需要四次挥手</h4><p>因为当服务端收到客户端的<code>SYN</code>连接请求报文后，可以直接发送<code>SYN+ACK</code>报文。其中<code>ACK</code>报文是用来应答的，<code>SYN</code>报文是用来同步的。但是关闭连接时，当服务端收到<code>FIN</code>报文时，很可能并不会立即关闭<code>SOCKET</code>，所以只能先回复一个<code>ACK</code>报文，告诉客户端，“你发的<code>FIN</code>报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送<code>FIN</code>报文，因此不能一起发送。故需要四次挥手。</p><h3 id="http缓存"><a class="markdownIt-Anchor" href="#http缓存"></a> HTTP缓存</h3><h4 id="强缓存"><a class="markdownIt-Anchor" href="#强缓存"></a> 强缓存</h4><p>使用强制缓存策略，如果缓存资源有效，就直接使用缓存资源，不需要向服务器发送请求。强制缓存通过两种方式来设置，在<code>request headers</code>中的<code>Expires</code>属性和<code>Cache-Contorl</code>属性。</p><p><code>Expires</code>属性，指定资源的过期时间。在过期时间以内，改资源可以被缓存使用，不需要向浏览器发送请求。这个时间依赖于服务器时间，会存在服务器时间和客户端时间不一致。</p><p><code>Cache-Control</code>属性：</p><ul><li><code>private</code>： 仅浏览器可以缓存</li><li><code>public</code>：浏览器和代理服务器都可以缓存</li><li><code>max-age=xxx</code> 过期时间，单位为秒</li><li><code>no-cache</code> 不进行强缓存，但会有协商缓存</li><li><code>no-store </code>不强缓存，也不协商缓存</li></ul><p>如果<code>request header</code>中，<code>Cache- Control</code>的值中有<code>max-age=xxx</code>，这个时候走强缓存。如果值为<code>no-cache</code>，表明没有命中，走协商缓存。如值为<code>no-store</code>，不使用缓存。</p><h4 id="协商缓存"><a class="markdownIt-Anchor" href="#协商缓存"></a> 协商缓存</h4><p>如果没有命中强制缓存，在设置协商缓存情况下，先向服务器发送一个请求，如果资源没有发生修改，则返回一个<code>304</code>的状态，让浏览器使用本地的缓存副本。如果资源发生修改，则返回修改后的资源。在<code>request headers</code>中的<code>Etag</code>属性和<code>Last-Modified</code>属性，来进行设置。其中，<code>ETage</code>优先于<code>Last-Modified</code>。</p><p>命中协商缓存条件：</p><ul><li><code>Cache-Control: no-cache</code></li><li><code>max-age</code>时间过期</li></ul><p><strong>Last-Modified（文件的修改时间）：</strong></p><p>服务器在响应头中添加<code>Last-Modified</code>属性，来指出资源最后一次修改时间。当浏览器发起请求时，会在<code>request headers</code>中添加一个<code>If-None-Since</code>属性，值为上一次请求的资源返回的<code>Last-Modified</code>值。服务端会通过这个属性和资源最后一次修改时间进行对比，以此来判断资源是否修改。如果资源没有修改，请求返回304状态，客户端使用本地缓存。如果资源有修改，则返回修改的资源。</p><p>这种方式有一个缺点，<code>Last-Modified</code>标记的时间只能精确到秒。</p><p><strong>ETag（文件改动）：</strong></p><p>同样在服务器返回资源的时候，在头信息中添加<code>ETag</code>属性，这个属性是资源的唯一标识符。当资源改变时，这个值也会改变。在一下次请求资源时，会在<code>request headers</code>中添加一个<code>If-None-Match</code>属性，值为上一次请求的资源返回的<code>ETag</code>值。服务端会通过这个属性和资源最后一次修改时间进行对比，以此来判断资源是否修改。这种方式比<code>Last-Modified</code>更加准确。</p><h4 id="区别-2"><a class="markdownIt-Anchor" href="#区别-2"></a> 区别</h4><ul><li>强缓存优先级高于协商缓存</li><li>强缓存不需要发请求，协商缓存需要。</li><li>强缓存返回的状态码为<code>200</code>，协商缓存返回<code>304</code></li><li>ctrl+F5强制刷新会跳过所有缓存，而F5刷新跳过强缓存，但是会检查协商缓存。</li></ul><h3 id="post和get的区别"><a class="markdownIt-Anchor" href="#post和get的区别"></a> POST和GET的区别</h3><ul><li>传递的参数不同，<code>POST</code>传递的参数在<code>request body</code>中，<code>GET</code>传递的参数在<code>url</code>后拼接</li><li><code>POST</code>相对<code>GET</code>请求安全</li><li><code>GET</code>请求长度有限制，<code>POST</code>没有</li><li><code>GET</code>请求会被浏览器主动缓存，<code>POST</code>不会，要手动设置</li><li><code>GET</code>请求一般用于查询，<code>POST</code>一般用于提交某种信息进行某些修改操作</li></ul><h3 id="xss-csrf攻击"><a class="markdownIt-Anchor" href="#xss-csrf攻击"></a> XSS、csrf攻击</h3><h4 id="xss跨站脚本攻击"><a class="markdownIt-Anchor" href="#xss跨站脚本攻击"></a> XSS（跨站脚本攻击）</h4><p><code>Xss(cross-site scripting)</code> 是一种代码注入攻击，攻击者往<code>Web</code>页面里插入恶意 <code>html</code> 标签或者 <code>javascript </code>代码。在骗取用户点击后获取用户，获取用户信息。</p><p><strong>避免方式：</strong></p><ul><li><code>url</code>参数通过<code>encodeURIComponent</code>方法进行转义</li><li>尽量不使用<code>InnerHtml</code>插入<code>HTML</code>内容</li><li>对用户输入的地方和变量都需要仔细检查长度和对 ”&lt;”,”&gt;”,”;”,”’” 等字符做过滤</li></ul><h4 id="csrf跨站请求伪造"><a class="markdownIt-Anchor" href="#csrf跨站请求伪造"></a> CSRF（跨站请求伪造）</h4><p><code>CSRF</code>（<code>Cross-site request forgery</code>）攻击者盗用你的身份信息，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p><strong>避免方式：</strong></p><ul><li>添加验证码验证</li><li>使用<code>token</code><ul><li>服务端给用户生成一个<code>token</code>，加密后传递给用户</li><li>用户在提交请求时，需要携带这个<code>token</code></li><li>服务端验证<code>token</code>是否正确</li></ul></li></ul><h3 id="前端工程化"><a class="markdownIt-Anchor" href="#前端工程化"></a> 前端工程化</h3><h3 id="webpack的loader和plugin的区别"><a class="markdownIt-Anchor" href="#webpack的loader和plugin的区别"></a> webpack的loader和plugin的区别</h3><h4 id="loader"><a class="markdownIt-Anchor" href="#loader"></a> loader</h4><p>loader是导出一个函数的javascript模块，webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到<code>loader</code>。如babel-loader、Css-loader、image-loader、url-loader、Saas-loader…</p><h4 id="plugin"><a class="markdownIt-Anchor" href="#plugin"></a> plugin</h4><p>Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。如html-webpack-plugin、mini-css-extract-plugin、uglifyjs-webpack-plugin</p><h2 id="手写系列"><a class="markdownIt-Anchor" href="#手写系列"></a> 手写系列🤮</h2><h3 id="节流防抖"><a class="markdownIt-Anchor" href="#节流防抖"></a> 节流防抖</h3><h3 id="new操作符"><a class="markdownIt-Anchor" href="#new操作符"></a> new操作符</h3><h3 id="call-bind-apply实现"><a class="markdownIt-Anchor" href="#call-bind-apply实现"></a> call、bind、apply实现</h3><h3 id="发布订阅模式"><a class="markdownIt-Anchor" href="#发布订阅模式"></a> 发布订阅模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 事件列表</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventList</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">name, callBack</span>) &#123;</span><br><span class="line">    <span class="comment">// 以 name 为 key  创建容器   如果有容器就不用创建</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventList</span>[name]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">eventList</span>[name] = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把事件放入容器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventList</span>[name].<span class="title function_">push</span>([callBack])</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发</span></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">name, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventList</span>[name]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;没有找到事件！&#x27;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器中取出事件进行调用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eventList</span>[name].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">item</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只触发一次</span></span><br><span class="line">  <span class="title function_">once</span>(<span class="params">name, callBack</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventList</span>[name]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 利用off  在callBack执行后  关闭订阅</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onceFn</span>(<span class="params">callBack</span>) &#123;</span><br><span class="line">      <span class="title function_">callBack</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(name, callBack);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(name, onceFn)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭监听  若第二个参数没有  移除 name 下所有的事件</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">name, callBack</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">eventList</span>[name]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callBack) &#123;</span><br><span class="line">      <span class="comment">// 只移除对应的callBack</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">eventList</span>[name] = <span class="variable language_">this</span>.<span class="property">eventList</span>[name].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;<span class="keyword">return</span> item !== callBack&#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// name容器长度为0 直接删除整个 name 事件订阅发布</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">eventList</span>[name].<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">eventList</span>[name];</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有 callBack  直接删除整个 name 事件订阅发布</span></span><br><span class="line">      <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">eventList</span>[name];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数柯里化实现"><a class="markdownIt-Anchor" href="#函数柯里化实现"></a> 函数柯里化实现</h3><h4 id="promise"><a class="markdownIt-Anchor" href="#promise"></a> promise</h4><h3 id="实现一个队列"><a class="markdownIt-Anchor" href="#实现一个队列"></a> 实现一个队列</h3><h3 id="数组去重"><a class="markdownIt-Anchor" href="#数组去重"></a> 数组去重</h3><h3 id="深浅拷贝"><a class="markdownIt-Anchor" href="#深浅拷贝"></a> 深浅拷贝</h3><h3 id="交换两个变量的值"><a class="markdownIt-Anchor" href="#交换两个变量的值"></a> 交换两个变量的值</h3><h3 id="数组扁平化"><a class="markdownIt-Anchor" href="#数组扁平化"></a> 数组扁平化</h3><h2 id="输出结果"><a class="markdownIt-Anchor" href="#输出结果"></a> 输出结果</h2><h3 id="闭包-2"><a class="markdownIt-Anchor" href="#闭包-2"></a> 闭包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;   </span><br><span class="line">　　<span class="keyword">var</span> object = &#123;   </span><br><span class="line">　　　　name : <span class="string">&quot;My Object&quot;</span>,   </span><br><span class="line">　　　　getNameFunc : <span class="keyword">function</span>(<span class="params"></span>)&#123;   </span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;   </span><br><span class="line">　　　　　　　　<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;   </span><br><span class="line">　　　　　&#125;;   </span><br><span class="line">　　　　&#125;   </span><br><span class="line">&#125;;   </span><br><span class="line"><span class="title function_">alert</span>(object.<span class="title function_">getNameFunc</span>()());  <span class="comment">//&quot;The Window&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aaa</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> a=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">bbb</span>(<span class="params"></span>) &#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="title function_">alert</span>(a);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> bbb</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ccc=<span class="title function_">aaa</span>();</span><br><span class="line"><span class="title function_">ccc</span>();  <span class="comment">//结果为1</span></span><br><span class="line"><span class="title function_">ccc</span>();  <span class="comment">//结果为2</span></span><br><span class="line"><span class="keyword">var</span> ddd=<span class="title function_">aaa</span>();</span><br><span class="line"><span class="title function_">ddd</span>();  <span class="comment">//结果为1</span></span><br><span class="line"><span class="title function_">ddd</span>();  <span class="comment">//结果为2</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/gebilaofan/2021-FE-Review">github 同步</a></p><blockquote><p>参考：</p><p><a href="https://juejin.cn/post/6941194115392634888#heading-2">2021」高频前端面试题</a></p><p><a href="https://juejin.cn/post/6989422484722286600#heading-43">2021年我的前端[[…/…/4-前端要努力/前端面试/1、面试准备|面试准备]]</a></p><p><a href="https://juejin.cn/post/6914831351271292936#heading-60">震惊！前端300基础面试题+答案、分类学习整理（良心制作）持续更新</a></p><p><a href="https://juejin.cn/post/6917816624040902670#heading-21">高级知识点</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d56cc46a99b4f7d9f114171e9738058~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:151</summary>
      
    
    
    <content src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d56cc46a99b4f7d9f114171e9738058~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp" type="image"/>
    
    
    <category term="面试" scheme="https://wakaka378.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://wakaka378.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>js面向对象—封装</title>
    <link href="https://wakaka378.github.io/458c45be1d2c.html"/>
    <id>https://wakaka378.github.io/458c45be1d2c.html</id>
    <published>2020-06-20T13:00:27.000Z</published>
    <updated>2023-06-14T13:02:23.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js设计模式一面向对象封装"><a class="markdownIt-Anchor" href="#js设计模式一面向对象封装"></a> js设计模式(一)面向对象—封装</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>最近一直在看<code>typescript</code>，主要的一个目的是为<code>vue3.x</code>做准备。3.x版本尤雨溪大神采用<code>typescript</code>重写底层，具体内容可以查看<a href="https://juejin.im/post/6844903687207272462">[译] 尤雨溪：Vue 3.0 计划-掘金</a>。在<code>typescript</code>里，几乎完全采用ES6语法，其中最为重要的还是<code>class</code>类的使用，学到这块就有点懵逼了。什么？继承还可以这样玩？什么共有私有什么派生类？？？我之前学了个假js吧？？？</p><p>于是回头来重新梳理学习一下面对对象编程，这一系列文章全部是基于<strong>ES5</strong>语法规则，别跟我说为啥不直接用<code>ES6</code>,<code>ES6</code>它最终也是编译成<code>ES5</code>运行。<br />小子只是个前端菜鸟，对编程还没有太深入的了解，只是个代码搬运工。如果文章有什么错误或者是理解上的错误，还请指条明路，感激不尽。</p><p>这一系列将以面对对象三个特性<code>封装</code>、<code>继承</code>、<code>多态</code>为题进行讲解，更好的理解面对对象编程。</p><h2 id="面对过程编程和面对对象编程oop"><a class="markdownIt-Anchor" href="#面对过程编程和面对对象编程oop"></a> 面对过程编程和面对对象编程(OOP)</h2><h3 id="面对过程编程"><a class="markdownIt-Anchor" href="#面对过程编程"></a> 面对过程编程</h3><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p><h3 id="面对对象编程"><a class="markdownIt-Anchor" href="#面对对象编程"></a> 面对对象编程</h3><p>面对对象编程就是将你的需求抽象成一个对象，针对这个对象分析其特征和动作，这个对象我们称之为<em>类</em></p><h2 id="对象基础知识"><a class="markdownIt-Anchor" href="#对象基础知识"></a> 对象基础知识</h2><h3 id="对象理解"><a class="markdownIt-Anchor" href="#对象理解"></a> 对象理解</h3><p>程序员经常会拿对象来开玩笑：没对象？自己new一个呗，要啥样都可以。那到底什么是对象呢？js中有一个说法是<em>万物皆对象</em>，<strong>对象就是可以拥有属性和方法的一个集合</strong>。人，是一个对象，他有吃饭睡觉的属性，有上班赚钱的方法。所有的一切都可以抽象为一个对象，只不过每个对象都属于自己的属性和方法。</p><p>什么叫面对对象编程？？？在js中，有两种编程风格。<em>面对过程编程</em>和<em>面对对象编程</em>，我们写轮播图写动画写页面，大部分都是<em>面对过程编程</em>(反正我个人目前是这样)。</p><h4 id="对象三大特征"><a class="markdownIt-Anchor" href="#对象三大特征"></a> 对象三大特征</h4><p><code>封装</code>、<code>继承</code>、<code>多态</code></p><h4 id="一个对象被创建这中间发生什么-new-关键字做了什么面试题"><a class="markdownIt-Anchor" href="#一个对象被创建这中间发生什么-new-关键字做了什么面试题"></a> 一个对象被创建，这中间发生什么 | new 关键字做了什么（面试题）</h4><pre><code> 1、创建一个新的对象，这个对象的类型是 `object` 2、设置这个新的对象的内部、可访问性和[[prototype]]属性为构造函数（指prototype.construtor所指向的构造函数）中设置的 3、将步骤1新创建的对象作为this的上下文  4、果该函数没有返回对象，则返回this。</code></pre><h3 id="原型和原型链"><a class="markdownIt-Anchor" href="#原型和原型链"></a> 原型和原型链</h3><ul><li>原型</li></ul><blockquote><p>JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。我们可以把所有对象实例需要共享的属性和方法直接定义在 <strong>prototype</strong> 对象上。这个对象的所有属性和方法，都会被构造函数的所拥有。<br />prototype作为对象的内部属性，我们一般通过实例化对象的<code>__proto__</code>这个属性进行访问。<br />在原型对象中还有一个属性<strong>constructor</strong>，这个属性对应创建所有指向该原型的实例的构造函数</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/20/172d0ea9eef2a3fd~tplv-t2oaga2asx-image.image" alt="image.png" /></p><ul><li>原型链</li></ul><blockquote><p>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回null。</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/20/172d0ea9e8523c43~tplv-t2oaga2asx-image.image" alt="image.png" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>= age</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">action</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;hello word&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;尤雨溪&#x27;</span>, <span class="number">18</span>) <span class="comment">// 实例化Person这个对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>) <span class="comment">// 尤雨溪</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">他们之间的关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    构造函数的原型 == 实例化p.__proto__</span></span><br><span class="line"><span class="comment">    构造函数 == 构造函数原型的constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === p.<span class="property">__proto__</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">constructor</span> === <span class="title class_">Person</span>) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="面对对象封装"><a class="markdownIt-Anchor" href="#面对对象封装"></a> 面对对象—封装</h2><h3 id="什么是封装"><a class="markdownIt-Anchor" href="#什么是封装"></a> 什么是封装</h3><blockquote><p>封装就是把客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口。也就是说，封装就是将属性和方法组成一个类的过程就称之为封装。</p></blockquote><h3 id="对象封装的几种形式"><a class="markdownIt-Anchor" href="#对象封装的几种形式"></a> 对象封装的几种形式</h3><h4 id="对象字面量"><a class="markdownIt-Anchor" href="#对象字面量"></a> 对象字面量</h4><ul><li>优点：代码简单易懂</li><li>缺点：创建多个对象会产生大量的代码，编写麻烦，且并没有实例与原型的概念</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span>  <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;尤雨溪&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="string">&quot;18&quot;</span>,</span><br><span class="line"></span><br><span class="line">    action : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;hello word!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">name</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">action</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空对象 给空对象添加方法属性</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">name</span> = <span class="string">&#x27;尤雨溪&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">age</span>=  <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">action</span>  = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="string">&#x27;hello word!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h4><ul><li>对象字面量的形式在创建多个对象的时候会产生大量代码，如果我们把创建新对象、添加对象属性、返回对象的过程放到这个函数中，每次需要创建对象的时候调用函数即可。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  person.<span class="property">name</span> = name;</span><br><span class="line">  person.<span class="property">age</span> = age;</span><br><span class="line"></span><br><span class="line">  person.<span class="property">action</span>= <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;hello word!&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成实例</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="title function_">createPerson</span>(<span class="string">&#x27;尤雨溪&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">createPerson</span>(<span class="string">&#x27;阮一峰&#x27;</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>)</span><br><span class="line">p.<span class="title function_">action</span>()</span><br></pre></td></tr></table></figure><ul><li>优点：避免创建大量对象时代码的臃肿</li><li>缺点： p1与p2之间没有内在联系</li></ul><h4 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h4><blockquote><p>所谓&quot;构造函数&quot;，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用<strong>new</strong>运算符，就能生成实例，并且this变量会绑定在实例对象上。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过this来添加属性方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">action</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;hello word&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;尤雨溪&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;阮一峰&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面我们说过，通过<strong>new</strong>关键字实例化出来的对象，都会有一个<code>constructor</code>属性指向他们的构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">constructor</span> === <span class="title class_">Person</span>)     <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">constructor</span> === <span class="title class_">Person</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>优点：实例化对象和构造函数之间存在关联</li><li>缺点：浪费内存，构造函数中定义的方法名<code>action</code>一样，但实例化出来的对象名不一样，造成一个内存的浪费。</li></ul><h4 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式"></a> 原型模式</h4><blockquote><p>上面我们说过，每个对象被实例化的时候，都会有一个原型<strong>prototype</strong>属性，这个属性是可以被其他对象继承的。所以我们可以将对象共有的属性方法，放到原型上，这样每次通过<code>new</code>出来的对象，在构造函数中的方法被多次创建。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过this来添加属性方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将共同拥有的方法挂在到原型上</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">action</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;hello wodr&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;尤雨溪&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;阮一峰&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">action</span>()</span><br><span class="line">p2.<span class="title function_">action</span>()</span><br></pre></td></tr></table></figure><h2 id="属性和方法的类型"><a class="markdownIt-Anchor" href="#属性和方法的类型"></a> 属性和方法的类型</h2><p>通过原型模式我们可以将方法属性直接放在原型上，所有的实例对象都可以访问这个属性方法，我们称为<strong>公有方法/属性</strong>。熟悉ES6的朋友知道，在用<code>class</code>定义类的时候，我们可以定义里面属性方法的类型。是保护类型，还是公开类型，还是私有类型，<strong>不同类型之间是不能相互访问的</strong>。在ES6中我们可以通过<code>public</code>等关键字来定义，那我们ES5是怎样区分他们的一个类型呢？</p><p>我之前在学习面对对象这一块的时候没有太过注意这一块内容，现在我们开发也很少注意到这一块内容。其实在快速开发的时期，我们很少注意到这些javascrip基础理论知识，更缺乏对原生js的理解。</p><p>在面向对象中，每个属性都有它的一个类型，可以分为<strong>共有</strong>、<strong>私有</strong>、<strong>静态</strong>三种。</p><h3 id="共有属性和方法"><a class="markdownIt-Anchor" href="#共有属性和方法"></a> 共有属性和方法</h3><p>从字面量上的意思理解，共有，就是所有对象都有的属性或方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过this来添加属性方法</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name  <span class="comment">// 共有属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将共同拥有的方法挂在到原型上</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">action</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;  <span class="comment">// 共有方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>是干<span class="subst">$&#123;<span class="variable language_">this</span>.job&#125;</span>的`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;尤雨溪&#x27;</span>, <span class="string">&#x27;程序员&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">action</span>()</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，<strong>通过this添加的属性或者在原型上添加的属性和方法都是共有的</strong></p><ul><li>调用规则： 调用公有方法，我们必需先实例化对象</li></ul><h3 id="私有属性和方法"><a class="markdownIt-Anchor" href="#私有属性和方法"></a> 私有属性和方法</h3><p>私有属性的理解可以从函数的作用域出发，函数内部定义的变量在函数外部无法访问。我们看下面栗子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, job</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过this来添加属性方法</span></span><br><span class="line">    <span class="keyword">var</span> name = name  <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="keyword">var</span> job = job</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">action</span> () &#123; <span class="comment">// 私有方法</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span>是干<span class="subst">$&#123;job&#125;</span>的`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;尤雨溪&#x27;</span>,  <span class="string">&#x27;程序员&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>)       <span class="comment">// undefined</span></span><br><span class="line">p.<span class="title function_">action</span>()   <span class="comment">//  p.action is not a function 报错</span></span><br></pre></td></tr></table></figure><p>当实例化创建对象的时候，通过<code>var</code>定义的局部变量是无法在外界被访问，他只能在构造函数内部进行使用，并且不能通过this访问，我们吧代码变动一下再看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, job</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过this来添加属性方法</span></span><br><span class="line">    <span class="keyword">var</span> name = name  <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="keyword">var</span> job = job</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">action1</span> () &#123; <span class="comment">// 私有方法</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span>是干<span class="subst">$&#123;job&#125;</span>的`</span>, <span class="string">&#x27;通过this调用&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">action2</span> () &#123; <span class="comment">// 私有方法</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span>是干<span class="subst">$&#123;job&#125;</span>的`</span>, <span class="string">&#x27;在内部调用&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这样是不能调用的</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">action1</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">action</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;尤雨溪&#x27;</span>,  <span class="string">&#x27;程序员&#x27;</span>)    <span class="comment">//尤雨溪是干程序员的 在内部调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>调用规则： 对象的私有方法和属性,外部是不可以访问的，只能在内部使用</li></ul><h3 id="特权方法"><a class="markdownIt-Anchor" href="#特权方法"></a> 特权方法</h3><p>在函数内部通过<code>this</code>创建的属性和方法，在创建对象时，每个对象自身都会拥有一份并且可以在外部可以访问到。通过<code>this</code>创建的属性可以看作对象的共有属性，而通过<code>this</code>创建的方法不但可以<strong>访问这些对象的共有属性方法，还能访问自身的私有属性方法</strong>，被称之为<strong>特权方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, job</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过this来添加属性方法</span></span><br><span class="line">    <span class="keyword">var</span> name = name  <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job   <span class="comment">// 共有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">action</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 特权方法</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span>是干<span class="subst">$&#123;<span class="variable language_">this</span>.job&#125;</span>的`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;尤雨溪&#x27;</span>, <span class="string">&#x27;程序员&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>)</span><br><span class="line">p.<span class="title function_">action</span>()     <span class="comment">// 尤雨溪是干程序员的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>调用规则：通过实例化，可以访问共有属性方法和私有属性方法</li></ul><h3 id="静态属性和方法"><a class="markdownIt-Anchor" href="#静态属性和方法"></a> 静态属性和方法</h3><p>共有属性方法和私有属性方法都用通过<code>new</code>创建对象才能访问，而静态属性方法不需要通过<code>new</code>关键字创建，就可以直接访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, job</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = name  <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job   <span class="comment">// 共有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">action</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 特权方法</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span>是干<span class="subst">$&#123;<span class="variable language_">this</span>.job&#125;</span>的`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">attr</span> = <span class="string">&#x27;静态属性&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;大家好，我是静态方法&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">attr</span>) <span class="comment">// 静态属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">say</span>() <span class="comment">// 大家好，我是静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;尤雨溪&#x27;</span>, <span class="string">&#x27;程序员&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">attr</span> ) <span class="comment">// undefined</span></span><br><span class="line">p.<span class="title function_">say</span>()     <span class="comment">// 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>调用规则：静态方法无需实例化对象，便可以调用，对象实例不能调用对象的静态方法，只能调用实例自身的静态属性和方法。</li></ul><h3 id="静态类"><a class="markdownIt-Anchor" href="#静态类"></a> 静态类</h3><p>前面我们说过，对象创建有好几种形式，那我们通过字面量的形式创建的对象，它的类型时什么呢？对象字面量形式创建的对象添加的方法只能时静态属性和静态方法，而<strong>包含静态属性和静态方法的类叫静态类</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;尤雨溪&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="string">&quot;18&quot;</span>,</span><br><span class="line"></span><br><span class="line">    action : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello word!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="property">attr</span> = <span class="string">&#x27;我是静态属性&#x27;</span></span><br><span class="line">person.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;大家好，我是静态方法&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>)</span><br><span class="line">person.<span class="title function_">action</span>()</span><br><span class="line"></span><br><span class="line">person.<span class="property">attr</span> </span><br><span class="line">person.<span class="title function_">say</span>()</span><br></pre></td></tr></table></figure><ul><li>调用规则：不需要通过<code>new</code>创建对象</li></ul><h2 id="相关文章"><a class="markdownIt-Anchor" href="#相关文章"></a> 相关文章</h2><p><a href="https://juejin.im/post/6844903687207272462">[译] 尤雨溪：Vue 3.0 计划-掘金</a><br /><a href="https://blog.csdn.net/weixin_44440256/article/details/87867523">js面向过程编程与面向对象编程的区别</a><br /><a href="https://segmentfault.com/a/1190000015843072">JS面向对象编程之封装</a><br /><a href="https://www.cnblogs.com/xiongzaiqiren/p/6733985.html">Javascript 面向对象(共有方法，私有方法，特权方法，静态属性和方法，静态类)示例讲解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js设计模式一面向对象封装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#js设计模式一面向对象封装&quot;&gt;&lt;/a&gt; js设计模式(一)面向对象—封装&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor</summary>
      
    
    
    
    <category term="Js" scheme="https://wakaka378.github.io/categories/Js/"/>
    
    <category term="设计模式" scheme="https://wakaka378.github.io/categories/Js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Js" scheme="https://wakaka378.github.io/tags/Js/"/>
    
    <category term="面对对象" scheme="https://wakaka378.github.io/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="设计模式" scheme="https://wakaka378.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>vue中使用vue-socket.io</title>
    <link href="https://wakaka378.github.io/05671be6ec24.html"/>
    <id>https://wakaka378.github.io/05671be6ec24.html</id>
    <published>2020-06-19T16:00:00.000Z</published>
    <updated>2023-06-14T13:01:04.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>vue项目中有使用到<code>socket</code>长连接，之前一直都是都是使用<code>vue-socke.io</code><a href="https://github.com/MetinSeylan/Vue-Socket.io">github地址</a>，但最近在使用时，出了一些莫名奇妙的bug，也是为此掉了不少头发，最后还是解决了。关于<code>socket</code>相关内容介绍以及使用场景，这里不会做太多介绍（主要是懒），可以翻看其他文章。本文主要介绍如何使用，以及再使用时需要注意一些什么。关于文章中使用的代码，我放上<a href="https://github.com/gebilaofan/vue-socket.io-demo">github</a>地址。</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>这里我们安装<code>vue.socket.io</code>模块和<code>socket.io-client</code>模块，也可以不用<code>socket.io-client</code>模块。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="selector-tag">i</span> vue-socket<span class="selector-class">.io</span> -S</span><br><span class="line">cnpm <span class="selector-tag">i</span> socket<span class="selector-class">.io-client</span> -S</span><br><span class="line"></span><br><span class="line">yarn vue-socket<span class="selector-class">.io</span></span><br><span class="line">yarn <span class="selector-tag">i</span> socket.io-client</span><br></pre></td></tr></table></figure><h2 id="vue-客户端使用"><a class="markdownIt-Anchor" href="#vue-客户端使用"></a> vue 客户端使用</h2><ul><li>使用<code>socket.io-client</code>连接</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueSocketIO</span> <span class="keyword">from</span> <span class="string">&#x27;vue-socket.io&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SocketIO</span> <span class="keyword">from</span> <span class="string">&quot;socket.io-client&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// socket 连接参数</span></span><br><span class="line"><span class="keyword">const</span> socketOptions = &#123;</span><br><span class="line">  <span class="attr">autoConnect</span>: <span class="literal">false</span>,       <span class="comment">// 自动连接     这里为我项目需求  需要在指定情况下才连接socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">VueSocketIO</span>(&#123;</span><br><span class="line">    <span class="attr">debug</span>: <span class="literal">true</span> ,   <span class="comment">// debug调试，生产建议关闭</span></span><br><span class="line">    <span class="attr">connection</span>: <span class="title class_">SocketIO</span>(<span class="string">&quot;127.0.0.1:1024&quot;</span>, socketOptions),</span><br><span class="line">    store,          <span class="comment">// 如果没有使用到store可以不用写</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="comment">// 这里为全局监听socket事件消息，监听函数这里只写了一点，其实很有很多事件。</span></span><br><span class="line">  <span class="attr">sockets</span>: &#123;</span><br><span class="line">    <span class="title function_">connecting</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正在连接&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">disconnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Socket 断开&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">connect_failed</span>(<span class="params"></span>) &#123;</span><br><span class="line">      cosnole.<span class="title function_">log</span>(<span class="string">&#x27;连接失败&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;socket connected&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>字符串连接</p><p>如果是正常使用，项目启动就连接socket，可以不需要加载<code>socket.io-client</code>模块，直接使用。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">VueSocketIO</span>(&#123;</span><br><span class="line">    <span class="attr">debug</span>: <span class="literal">true</span> ,   <span class="comment">// debug调试，生产建议关闭</span></span><br><span class="line">    <span class="attr">connection</span>: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1024</span>,</span><br><span class="line">    store,          <span class="comment">// 如果没有使用到store可以不用写</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>组件中使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;connect&quot;</span>&gt;</span>连接socket<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sendMessage&quot;</span>&gt;</span>发送数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 连接socket</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">$socket</span>.<span class="title function_">open</span>()       <span class="comment">// 开始连接socket</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 订阅事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">sockets</span>.<span class="title function_">subscribe</span>(<span class="string">&#x27;welcome&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;welcome data &#x27;</span>, data)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;) </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 发送消息</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">sendMessage</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">$socket</span>.<span class="title function_">emit</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;这里是客户端&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">sockets</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">welcome</span>: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;welcome data &#x27;</span>, data)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="客户端使用总结"><a class="markdownIt-Anchor" href="#客户端使用总结"></a> 客户端使用总结</h3><h4 id="客户端自带监听事件"><a class="markdownIt-Anchor" href="#客户端自带监听事件"></a> 客户端自带监听事件</h4><ul><li><code>connect</code>：连接成功</li><li><code>connecting</code>：正在连接</li><li><code>disconnect</code>：断开连接</li><li><code>connect_failed</code>：连接失败</li><li><code>error</code>：错误发生，并且无法被其他事件类型所处理</li><li><code>reconnect_failed</code>：重连失败</li><li><code>reconnect</code>：成功重连</li><li><code>reconnecting</code>：正在重连</li></ul><h4 id="监听自定义事件"><a class="markdownIt-Anchor" href="#监听自定义事件"></a> 监听自定义事件</h4><ul><li>全局监听</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sockets</span>:&#123;</span><br><span class="line">    <span class="attr">welcome</span>: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;welcome data&#x27;</span>, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组件内监听</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">sockets</span>.<span class="title function_">subscribe</span>(<span class="string">&#x27;welcome&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;welcome&#x27;</span>, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="发送消息"><a class="markdownIt-Anchor" href="#发送消息"></a> 发送消息</h4><p><strong>注意</strong>：监听用的是<code>this.sockets</code>，发送消息是<code>this.$socket</code>，不要弄混。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$socket</span>.<span class="title function_">emit</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;这里是客户端&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="关于跨域问题"><a class="markdownIt-Anchor" href="#关于跨域问题"></a> 关于跨域问题</h4><p>socket会存在跨域问题，之前看文章又说到在<code>vue.config.js</code>中配置代理，差不多和后台接口代理配置一样，但我试过好像没啥鸟用，如果有知道的同学麻烦留言告诉一声，实际项目中的解决方式还是后端配置跨域问题。</p><h2 id="服务端使用"><a class="markdownIt-Anchor" href="#服务端使用"></a> 服务端使用</h2><p>这里为啥要讲服务端使用，主要是为了让同学更好的体验socket，其次是为了引出后面的bug，也是一个扩展知识把，是不是觉得自己赚了😄。本地开启socket服务可以更好的进行调试。服务端主要还是使用<code>node</code>，毕竟咱也不会java、python…，这里以及配置了socket跨域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Descripttion: </span></span><br><span class="line"><span class="comment"> * @version: </span></span><br><span class="line"><span class="comment"> * @Author: fanliu</span></span><br><span class="line"><span class="comment"> * @Date: 2020-06-19 18:22</span></span><br><span class="line"><span class="comment"> * @LastEditors: fanliu</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-06-19 18:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建server服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> headers = &#123;&#125;;</span><br><span class="line">  headers[<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>] = <span class="string">&quot;*&quot;</span>;</span><br><span class="line">  headers[<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>] = <span class="string">&quot;POST, GET, PUT, DELETE, OPTIONS&quot;</span>;</span><br><span class="line">  headers[<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>] = <span class="literal">true</span>;</span><br><span class="line">  headers[<span class="string">&quot;Access-Control-Max-Age&quot;</span>] = <span class="string">&#x27;86400&#x27;</span>; <span class="comment">// 24 hours</span></span><br><span class="line">  headers[<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>] = <span class="string">&quot;X-Requested-With, Access-Control-Allow-Origin, X-HTTP-Method-Override, Content-Type, Authorization, Accept&quot;</span>;</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, headers);</span><br><span class="line">  res.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器  监听 1024 端口</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">1024</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server runing at 127.0.0.1:1024&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动socket服务</span></span><br><span class="line"><span class="keyword">var</span> socket = io.<span class="title function_">listen</span>(server, &#123;<span class="attr">origins</span>: <span class="string">&#x27;*:*&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听客户端连接</span></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>,<span class="keyword">function</span>(<span class="params">socket</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;客户端有连接&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听客户端断开</span></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;客户端断开&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给客户端发送消息</span></span><br><span class="line">socket.<span class="title function_">emit</span>(<span class="string">&#x27;welcome&#x27;</span>,<span class="string">&#x27;欢迎连接socket&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 监听客户端消息</span></span><br><span class="line">        socket.<span class="title function_">on</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收客户端发送数据&#x27;</span>, data)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="服务端总结"><a class="markdownIt-Anchor" href="#服务端总结"></a> 服务端总结</h3><p><strong>服务端接收和发送消息和客户端对调的</strong>，客户端<code>emit</code>发送消息，那么服务端这里就要<code>on</code>监听客户端发送的消息，服务的发送同理。</p><h2 id="踩坑"><a class="markdownIt-Anchor" href="#踩坑"></a> 踩坑</h2><h3 id="订阅事件记得要取消"><a class="markdownIt-Anchor" href="#订阅事件记得要取消"></a> 订阅事件记得要取消</h3><p>socket主要还是用来写聊天室，加入socket房间后要订阅房间内所有的聊天内容，这时如果没有取消之前的订阅事件，下次进入会多次订阅消息。也就是别人只发一条消息，你这边接收到的却是两条甚至多条。哪如何取消订阅呢，我的处理方式是在离开当前聊天页面后，自动取消之前所有的订阅事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sockets</span>.<span class="title function_">unsubscribe</span>(eventName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，如果是有指定页面才加入socket房间，退出页面时也要记得关闭socket连接。比如你在<code>created</code>中开始连接socket，在<code>beforeDestroy</code>要记得关闭socket，不然下次进入也会连接socket。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$socket</span>.<span class="title function_">open</span>()</span><br><span class="line">    <span class="comment">// 查看socket是否连接成功</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$socket</span>.<span class="property">connected</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$socket</span>.<span class="title function_">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-error-thissocketssubscribe-is-not-a-function"><a class="markdownIt-Anchor" href="#type-error-thissocketssubscribe-is-not-a-function"></a> Type Error: this.sockets.subscribe is not a function</h3><p>这是我最近遇到的问题，原本以为是自己的this指向有问题，然后从到尾查遍了整个逻辑this，发现并不是这个问题。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/20/172d0d9547cb4d71~tplv-t2oaga2asx-image.image" alt="" /></p><p>在打印<code>this.sockets</code>之后我发现问题</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/20/172d0da331a5ad65~tplv-t2oaga2asx-image.image" alt="" /><br /><code>subscribe</code>订阅事件并没有直接存在，而是某个对象的属性，于是尝试了一下<code>this.sockets.listenner.subscribe</code>发现能用了。</p><p>你以为这就结束了？？？接着我又发现问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sockets</span>:&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">welcome</span>: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;welcome data &#x27;</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且订阅的事件中，socket日志显示<code>component: undefined</code>没有看到数据</p><p>全局的订阅事件没有生效，并且socket自带的连接事件也没有启动打印。我直接傻了😢，之前使用的时候还没有这些问题，百度一大堆无果后，开始像官方求助。于是找到了问题。<br /><a href="">Vue-Socket.io: #connect subscribe, component: undefined</a></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/20/172d0de8634dcf66~tplv-t2oaga2asx-image.image" alt="" /></p><p>大概的意思是说，出现问题的都是3.0.9的版本，将版本后可以解决这个问题。这也是我为啥要把socket服务端写进了的原因。自己本地写了一个小demo后，还真的是版本的问题，随后就有了这篇文章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;vue项目中有使用到&lt;code&gt;socket&lt;/code&gt;长连接，之前一直都是都是使用&lt;code&gt;vue-socke.io&lt;/code&gt;&lt;a h</summary>
      
    
    
    <content src="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fsocket.io%2Fdocs%2Fv3%2Frooms%2F&amp;psig=AOvVaw0UK_Q777zAycdk-2Os5DYk&amp;ust=1686833914528000&amp;source=images&amp;cd=vfe&amp;ved=0CBEQjRxqFwoTCNDuyJjowv8CFQAAAAAdAAAAABAO" type="image"/>
    
    
    <category term="Vue" scheme="https://wakaka378.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://wakaka378.github.io/tags/Vue/"/>
    
    <category term="socket.io" scheme="https://wakaka378.github.io/tags/socket-io/"/>
    
  </entry>
  
</feed>
